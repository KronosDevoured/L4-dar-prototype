<!DOCTYPE html>
<html lang="en">
    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.164.0/build/three.module.js"
  }
}
</script>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>L4 Aerial Car Control Tool</title>
<link rel="icon" type="image/svg+xml" href="favicon.svg" />
<style>
  /* === CSS BASE START === */
  html,body{margin:0;padding:0;height:100%;background:#ffffff;color:#0e0f12;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overscroll-behavior:none}
  body{background:linear-gradient(180deg,#f6f7fb 0%,#eef1f6 45%,#e9edf3 100%);}
  *, *::before, *::after{box-sizing:border-box}
  *{-webkit-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none}
  #gl{position:fixed;inset:0;z-index:0;display:block}
  #hud{position:fixed;inset:0;z-index:1;display:block;touch-action:none}
  /* === CSS BASE END === */

  /* === HAMBURGER === */
  #menuBtn{
    position:fixed;top:.6rem;right:.6rem;z-index:3;width:44px;height:44px;
    border-radius:12px;border:1px solid #3a3d45;background:#181a20;display:grid;place-items:center;
    box-shadow:0 2px 10px rgba(0,0,0,.25)
  }
  #menuBtn .bar{display:block;width:20px;height:2px;background:#e8e8ea;margin:3px 0}
  #menuBtn.active{background:#0066ff;border-color:#4c8dff}

  /* === THEME BUTTON (Sun/Moon) === */
  #themeBtn{
    position:fixed;top:.6rem;right:3.5rem;z-index:3;width:44px;height:44px;
    border:none;background:transparent;font-size:1.8rem;cursor:pointer;
    display:grid;place-items:center;padding:0;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,.3));
  }
  #themeBtn:hover{transform:scale(1.1)}
  #themeBtn:active{transform:scale(0.95)}

  /* Fullscreen button */
  #fullscreenBtn{
    position:fixed;top:.6rem;right:7rem;z-index:3;width:44px;height:44px;
    border:2px solid #4c8dff;background:rgba(76,141,255,0.15);
    font-size:2rem;cursor:pointer;border-radius:8px;
    display:grid;place-items:center;padding:0;
    filter: drop-shadow(0 2px 8px rgba(76,141,255,.4));
    color:#4c8dff;
  }
  #fullscreenBtn:hover{transform:scale(1.1);background:rgba(76,141,255,0.25);}
  #fullscreenBtn:active{transform:scale(0.95)}

  /* === OVERLAY MENU PANEL === */
  #menuOverlay{
    position:fixed; inset:0; z-index:4; display:none;
    background:rgba(10,12,16,0.45); -webkit-backdrop-filter: blur(3px); backdrop-filter: blur(3px);
    overflow-x:hidden;
  }
  #menuPanel{
    position:absolute; left:50%; top:12vh; transform:translateX(-50%);
    width:min(960px, calc(100vw - 2rem)); max-height:76vh; overflow:auto;
    background:rgba(24,26,32,.96); color:#e8e8ea; border:1px solid #3a3d45; border-radius:14px;
    box-shadow:0 20px 60px rgba(0,0,0,.35);
    overflow-x:hidden;
  }
  .mp-header{
    position:sticky; top:0; background:rgba(24,26,32,.98); z-index:1;
    padding:.9rem clamp(.8rem, 2vw, 1rem); border-bottom:1px solid #33373f; display:flex; align-items:center; justify-content:space-between;
  }
  .mp-title{font-weight:700;letter-spacing:.2px}
  .mp-close{border:1px solid #3a3d45;background:#181a20;color:#e8e8ea;border-radius:10px;padding:.35rem .6rem;font-weight:600}
  .mp-body{
    padding:clamp(.6rem,2vw,1rem);
    display:grid; grid-template-columns: 1fr; gap:14px;
  }

  .card{
    background:#15171d; border:1px solid #33373f; border-radius:12px; padding:.9rem;
  }
  .card h3{
    margin:.1rem 0 .7rem; font-size:1rem; opacity:.95; cursor:pointer; user-select:none;
    display:flex; align-items:center; justify-content:space-between;
  }
  .card h3:hover{opacity:1; color:#4c8dff;}
  .card h3::after{
    content:'â–¼'; font-size:.8rem; transition: transform 0.2s;
  }
  .card.collapsed h3::after{
    transform: rotate(-90deg);
  }
  .card-content{
    overflow:hidden; transition: max-height 0.3s ease, opacity 0.2s ease;
  }
  .card.collapsed .card-content{
    max-height:0 !important; opacity:0;
  }
  .row{display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; margin:.45rem 0; width:100%;}
  .tip{
    font-size:.86rem; opacity:.85; line-height:1.5; margin:.5rem 0;
    padding:.5rem .7rem; background:rgba(255,255,255,.03);
    border-left:3px solid #4c8dff; border-radius:4px;
  }
  .btn{border:1px solid #3a3d45;padding:.45rem .7rem;border-radius:999px;background:#181a20;color:#e8e8ea;font-weight:600;letter-spacing:.2px;cursor:pointer}
  .btn.active{background:#0066ff;border-color:#4c8dff}
  .tag{
    background:#181a20;border:1px solid #3a3d45;padding:.25rem .5rem;
    border-radius:999px;font-size:.82rem;white-space:nowrap;
    cursor:text;user-select:text;
  }
  .tag:hover{border-color:#4c8dff}
  .tag:focus{outline:2px solid #4c8dff;background:#1f2229}

  .sl{
    display:flex; align-items:center; gap:.6rem; flex-wrap:nowrap;
    width:100%; min-width:0;
  }
  .sl label{
    font-size:.88rem; opacity:.92; flex:0 0 150px; min-width:120px; max-width:220px;
  }
  .sl input[type=range]{
    accent-color:#4c8dff;
    flex:1 1 auto; min-width:0; max-width:100%; width:100%;
  }
  .sl .tag{flex:0 0 auto}

  @media (max-width:520px){
    .sl{flex-wrap:wrap}
    .sl label{flex:1 0 100%}
    .sl input[type=range]{flex:1 0 100%}
    .sl .tag{margin-left:auto}
  }

  select{background:#181a20;color:#e8e8ea;border:1px solid #3a3d45;border-radius:10px;padding:.35rem .5rem;max-width:100%}

  /* Hints (stick/DAR) */
  #joyHint,#darHint{position:fixed; z-index:2; pointer-events:none;background:rgba(24,26,32,.92); border:1px solid #3a3d45; color:#cfd3dc;
    padding:.35rem .55rem; border-radius:10px; font-size:.85rem; white-space:nowrap; transform:translate(-50%,-50%); opacity:0; transition:opacity .25s ease;}
  #joyHint.show,#darHint.show{opacity:1;}

  /* XYZ gizmo frame */
  #gizmoFrame{
    position:fixed; right:.6rem; top:64px; width:84px; height:84px; z-index:2;
    border-radius:10px; border:1px solid #3a3d45; background:rgba(24,26,32,.5);
    box-shadow:0 8px 24px rgba(0,0,0,.2); pointer-events:none;
  }
</style>
</head>
<body>
  <!-- CANVASES -->
  <canvas id="gl"></canvas>
  <canvas id="hud"></canvas>
  <div id="gizmoFrame"></div>

  <!-- HAMBURGER -->
  <button id="menuBtn" type="button" title="Open Menu"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button>

  <!-- FULLSCREEN TOGGLE -->
  <button id="fullscreenBtn" type="button" title="Toggle Fullscreen">â›¶</button>

  <!-- THEME TOGGLE (Sun/Moon) -->
  <button id="themeBtn" type="button" title="Toggle Day/Night Mode">ðŸŒ™</button>

  <!-- OVERLAY MENU -->
  <div id="menuOverlay">
    <div id="menuPanel">
      <div class="mp-header">
        <div class="mp-title">L4 Controls & Settings</div>
        <button class="mp-close" id="menuCloseBtn" type="button">Close</button>
      </div>
      <div class="mp-body">

        <!-- Rotation -->
        <div class="card">
          <h3>Rotation</h3>
          <div class="row">
            <button id="rollL" class="btn" type="button">Air Roll Left</button>
            <button id="rollR" class="btn active" type="button">Air Roll Right</button>
            <button id="rollFree" class="btn" type="button">Air Roll (Free)</button>
            <button id="ringMode" class="btn" type="button">Ring Mode</button>
            <button id="restart" class="btn" type="button">Restart</button>
            <button id="orbitCW" class="btn" type="button">Orbit CW</button>
            <button id="orbitCCW" class="btn" type="button">Orbit CCW</button>
          </div>

          <div class="row">
            <label>Air Roll Mode:</label>
            <button id="toggleMode" class="btn active" type="button">Toggle</button>
          </div>

          <div class="tip">
            <b>Tip:</b> With Air Roll Right, rotate the stick clockwise. With Air Roll Left, rotate the stick counter-clockwise.
          </div>
        </div>

<!-- Dynamics -->
<div class="card">
  <h3>Dynamics</h3>

  <div class="row">
    <button id="resetPhysicsDefaults" class="btn" type="button">Reset to Defaults</button>
  </div>

  <div class="row sl">
    <label for="accelPitch">Max Pitch Accel (Â°/sÂ²)</label>
    <input id="accelPitch" type="range" min="120" max="1200" step="5" value="714"/>
    <span class="tag" id="accelPitchTag">714</span>
  </div>

  <div class="row sl">
    <label for="accelYaw">Max Yaw Accel (Â°/sÂ²)</label>
    <input id="accelYaw" type="range" min="120" max="1200" step="5" value="521"/>
    <span class="tag" id="accelYawTag">521</span>
  </div>

  <div class="row sl">
    <label for="accelRoll">Max Roll Accel (Â°/sÂ²)</label>
    <input id="accelRoll" type="range" min="120" max="2400" step="5" value="2153"/>
    <span class="tag" id="accelRollTag">2153</span>
  </div>

  <div class="row sl">
    <label for="curveRange">Input Curve</label>
    <input id="curveRange" type="range" min="1.0" max="2.2" step="0.05" value="1.0"/>
    <span class="tag" id="curveTag">1.00</span>
  </div>

  <div class="row sl">
    <label for="dampRange">Damp (No-DAR)</label>
    <input id="dampRange" type="range" min="0.0" max="6.0" step="0.05" value="2.96"/>
    <span class="tag" id="dampTag">2.96</span>
  </div>

  <div class="row sl">
    <label for="dampDARRange">Damp (DAR)</label>
    <input id="dampDARRange" type="range" min="0.0" max="6.0" step="0.05" value="4.35"/>
    <span class="tag" id="dampDARTag">4.35</span>
  </div>

  <div class="row sl">
    <label for="brakeRange">Release Brake</label>
    <input id="brakeRange" type="range" min="0.0" max="6.0" step="0.1" value="0.0"/>
    <span class="tag" id="brakeTag">0.0</span>
  </div>

  <div class="row sl">
    <label for="wmaxRange">Max Ï‰ (global)</label>
    <input id="wmaxRange" type="range" min="4.0" max="24.0" step="0.1" value="5.5"/>
    <span class="tag" id="wmaxTag">5.5</span>
  </div>

  <div class="row sl">
    <label for="wmaxPitch">Max Pitch Ï‰</label>
    <input id="wmaxPitch" type="range" min="4.0" max="24.0" step="0.5" value="24.0"/>
    <span class="tag" id="wmaxPitchTag">24.0</span>
  </div>

  <div class="row sl">
    <label for="wmaxYaw">Max Yaw Ï‰</label>
    <input id="wmaxYaw" type="range" min="4.0" max="24.0" step="0.5" value="24.0"/>
    <span class="tag" id="wmaxYawTag">24.0</span>
  </div>

  <div class="row sl">
    <label for="wmaxRoll">Max Roll Ï‰</label>
    <input id="wmaxRoll" type="range" min="4.0" max="24.0" step="0.5" value="24.0"/>
    <span class="tag" id="wmaxRollTag">24.0</span>
  </div>
</div>
<!-- Car -->
<div class="card">
  <h3>Car</h3>
  <div class="row sl">
    <label for="presetSel">Body</label>
    <select id="presetSel">
      <option value="placeholder">Placeholder (140Ã—56Ã—240)</option>
      <option value="octane" selected>Octane proportions</option>
      <option value="dominus">Dominus proportions</option>
    </select>
  </div>
</div>
        <!-- View / HUD -->
        <div class="card">
          <h3>View & HUD</h3>

          <div class="row">
            <button id="arrowToggle" class="btn active" type="button">Show Arrow</button>
            <button id="circleToggle" class="btn active" type="button">Show Circle</button>
          </div>

          <div class="row sl">
            <label for="zoomSlider">Zoom</label>
            <input id="zoomSlider" type="range" min="0.20" max="4.00" step="0.01" value="1.00" />
            <span class="tag" id="zoomVal">1.00Ã—</span>
          </div>

          <div class="row sl">
            <label for="stickSizeSlider">Stick Size</label>
            <input id="stickSizeSlider" type="range" min="60" max="180" step="1" value="100" />
            <span class="tag" id="stickVal">100</span>
          </div>

          <div class="row sl">
            <label for="arrowSlider">Arrow Size</label>
            <input id="arrowSlider" type="range" min="0.60" max="4.00" step="0.01" value="4.00" />
            <span class="tag" id="arrowVal">4.00Ã—</span>
          </div>

          <div class="row sl">
            <label for="circleScale">Circle Scale</label>
            <input id="circleScale" type="range" min="0.2" max="2.0" step="0.05" value="0.3"/>
            <span class="tag" id="circleScaleTag">0.30Ã—</span>
          </div>

          <div class="row sl">
            <label for="circleTilt">Circle Tilt Angle</label>
            <input id="circleTilt" type="range" min="0" max="45" step="1" value="34"/>
            <span class="tag" id="circleTiltTag">38Â°</span>
          </div>

          <div class="row sl">
            <label for="circleTiltModifier">Circle Tilt Modifier</label>
            <input id="circleTiltModifier" type="range" min="-45" max="45" step="1" value="0"/>
            <span class="tag" id="circleTiltModifierTag">0Â°</span>
          </div>

          <div class="row sl">
            <label for="brightnessSlider">Car Brightness</label>
            <input id="brightnessSlider" type="range" min="0.5" max="3.0" step="0.1" value="1.0" />
            <span class="tag" id="brightnessVal">1.00Ã—</span>
          </div>
        </div>

        <!-- Ring Mode Settings -->
        <div class="card">
          <h3>Ring Mode</h3>

          <div class="row">
            <label for="ringDifficulty">Difficulty</label>
            <select id="ringDifficulty">
              <option value="easy">Easy</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Hard</option>
            </select>
          </div>

          <div class="row sl">
            <label for="ringCameraSpeed">Camera Transition Speed</label>
            <input id="ringCameraSpeed" type="range" min="0.01" max="0.5" step="0.01" value="0.1" />
            <span class="tag" id="ringCameraSpeedVal">0.10</span>
          </div>

          <div class="tip">
            <b>Ring Mode:</b> Navigate through rings using boost. Lower camera speed = slower, smoother transitions to next ring.
            <br><br>
            <b>Difficulty:</b><br>
            â€¢ Easy: Large rings, slower speed, simple patterns<br>
            â€¢ Normal: Balanced challenge<br>
            â€¢ Hard: Smaller rings, faster speed, complex patterns
          </div>
        </div>

        <!-- Audio Settings -->
        <div class="card">
          <h3>Audio</h3>
          <div class="row">
            <button id="toggleSounds" class="btn active" type="button">Game Sounds</button>
            <span class="tag" id="soundsStatus">Enabled</span>
          </div>
          <div class="row">
            <button id="toggleMusic" class="btn active" type="button">Background Music</button>
            <span class="tag" id="musicStatus">Enabled</span>
          </div>
          <div class="tip">
            <b>Game Sounds:</b> Ring pass/miss sounds and boost rumble<br>
            <b>Background Music:</b> 8-bit style music during Ring Mode
          </div>
        </div>

        <!-- Gamepad -->
        <div class="card">
          <h3>Gamepad</h3>
          <div class="row">
            <button id="gpEnable" class="btn active" type="button">Enable</button>
            <span class="tag" id="gpStatus">Enabled (waiting for gamepad)</span>
          </div>
          <div class="row sl">
            <label for="gpPreset">Preset</label>
            <select id="gpPreset">
              <option value="ps5" selected>PS5 / DualSense</option>
              <option value="xinput">Generic XInput</option>
            </select>
          </div>
          <div class="row">
            <button id="gpRemap" class="btn" type="button">Remap Actionâ€¦</button>
            <select id="gpAction" aria-label="Select action to remap">
              <option value="toggleDAR">Toggle DAR</option>
              <option value="rollLeft">Air Roll Left</option>
              <option value="rollRight">Air Roll Right</option>
              <option value="rollFree">Air Roll (Free)</option>
              <option value="boost">Boost (Ring Mode)</option>
              <option value="pause">Pause (Ring Mode)</option>
              <option value="restart">Restart</option>
              <option value="orbitCW">Orbit Clockwise</option>
              <option value="orbitCCW">Orbit Counter-Clockwise</option>
              <option value="toggleTheme">Toggle Day/Night Mode</option>
              <option value="openMenu">Open/Close Menu</option>
            </select>
            <span class="tag" id="gpBindLabel">â€”</span>
          </div>
          <div class="row">
            <button id="gpResetDefaults" class="btn" type="button">Reset to Defaults</button>
          </div>
          <div class="tip">
            <b>Tip:</b> Left stick moves the on-screen stick. Remap any action, then press a button or push an axis to bind.
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- Hints -->
  <div id="joyHint">Hold outside the stick to reposition (UI hidden)</div>
  <div id="darHint">Tap to toggle roll â€¢ Hold to move</div>

<script type="module">
// Version: 2025-11-29-v2 (localStorage persistence fix)
import * as THREE from "three";
import { GLTFLoader } from "https://unpkg.com/three@0.164.0/examples/jsm/loaders/GLTFLoader.js";

/* ====== Renderer / Scene / Camera ====== */
const gl = document.getElementById('gl');
const hud = document.getElementById('hud');
const renderer = new THREE.WebGLRenderer({canvas: gl, antialias: true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);

// Detect if on mobile/tablet or desktop
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
  || (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
const isDesktop = !isMobile;
console.log('Device type:', isMobile ? 'Mobile/Tablet' : 'Desktop');

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0xeef1f6, 900, 2200);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
const CAM_BASE = { y: 280, z: 760 };
camera.position.set(0, CAM_BASE.y, CAM_BASE.z);
scene.add(camera);

/* Lights */
const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 1.15);
directionalLight.position.set(-350, 700, 900);
directionalLight.castShadow = false;
scene.add(directionalLight);

/* Grid - expanded to look infinite */
const grid = new THREE.Group();
const gridMain = new THREE.GridHelper(10000, 100, 0xd7dde6, 0xE5E9F1); // 10x larger, more divisions
gridMain.material.opacity = 0.65;
gridMain.material.transparent = true;
gridMain.material.depthWrite = false; // Prevent z-fighting
grid.add(gridMain);
grid.rotation.x = -Math.PI/2;
grid.position.y = -160;
scene.add(grid);

/* Colors */
const COL_UP   = 0xff5c5c;
const COL_RIGHT= 0x4c8dff;
const COL_DOWN = 0x53d769;
const COL_LEFT = 0xffd166;

/* Materials */
const MAT_BODY  = new THREE.MeshPhongMaterial({color: 0xdfe5ef, shininess: 50, specular: 0x666666});
const MAT_GLASS = new THREE.MeshPhongMaterial({color: 0x9aa6b7, shininess: 40, specular: 0x222222, transparent:true, opacity:0.65});
const MAT_ACCENT= new THREE.MeshPhongMaterial({color: 0xcbd3df, shininess: 35, specular: 0x222222});
const MAT_DARK  = new THREE.MeshPhongMaterial({color: 0xaeb7c4, shininess: 28, specular: 0x222222});
const MAT_EDGE  = (hex)=> new THREE.LineBasicMaterial({color: hex});
const MAT_TIRE_F= new THREE.MeshLambertMaterial({color: 0x8a93a0});
const MAT_TIRE_B= new THREE.MeshLambertMaterial({color: 0x808896});
const MAT_HUB   = new THREE.MeshBasicMaterial({color: 0x5a6270});

/* Theme configuration */
let isDarkMode; // Will be initialized from localStorage
const THEMES = {
  dark: {
    body: '#000000',
    fog: 0x000000,
    fogNear: 1000,
    fogFar: 2500,
    ambient: 0xffffff,
    ambientIntensity: 1.5,
    directional: 0xffffff,
    directionalIntensity: 1.2,
    gridMain: 0x4a5060,
    gridSub: 0x353945,
    gridOpacity: 0.7,
    gridY: -160
  },
  light: {
    body: '#ffffff',
    fog: 0xeef1f6,
    fogNear: 900,
    fogFar: 2200,
    ambient: 0xffffff,
    ambientIntensity: 0.8,
    directional: 0xffffff,
    directionalIntensity: 1.15,
    gridMain: 0x8a95a5,
    gridSub: 0xb5bec8,
    gridOpacity: 0.85,
    gridY: -160
  }
};

function applyTheme(dark) {
  const theme = dark ? THEMES.dark : THEMES.light;

  // Update body background
  document.body.style.background = dark
    ? '#000000'
    : 'linear-gradient(180deg,#f6f7fb 0%,#eef1f6 45%,#e9edf3 100%)';

  // Update fog
  scene.fog.color.setHex(theme.fog);
  scene.fog.near = theme.fogNear;
  scene.fog.far = theme.fogFar;

  // Update lights with brightness multiplier
  const brightness = dark ? brightnessDark : brightnessLight;
  ambientLight.intensity = theme.ambientIntensity * brightness;
  directionalLight.intensity = theme.directionalIntensity * brightness;

  // Update grid
  gridMain.material.color.setHex(theme.gridMain);
  gridMain.material.opacity = theme.gridOpacity;

  // Update renderer background
  renderer.setClearColor(theme.fog);

  // Update car materials for better visibility in day mode
  if (!dark) {
    // Day mode - brighten the car
    MAT_BODY.color.setHex(0xf5f7fa);
    MAT_GLASS.color.setHex(0xc5d0df);
    MAT_ACCENT.color.setHex(0xe0e6ef);
    MAT_DARK.color.setHex(0xd0d8e2);
    MAT_TIRE_F.color.setHex(0xb0b8c5);
    MAT_TIRE_B.color.setHex(0xa8b0be);
    MAT_HUB.color.setHex(0x8a92a0);
  } else {
    // Night mode - brighter than original
    MAT_BODY.color.setHex(0xecf0f5);
    MAT_GLASS.color.setHex(0xb5c0d0);
    MAT_ACCENT.color.setHex(0xdae0e8);
    MAT_DARK.color.setHex(0xc5cdd8);
    MAT_TIRE_F.color.setHex(0xa0a8b5);
    MAT_TIRE_B.color.setHex(0x98a0ad);
    MAT_HUB.color.setHex(0x7a8290);
  }
}

/* Presets */
const presets = {
  placeholder: { hx:70, hy:28, hz:120 },
  octane:      { hx:85.65, hy:36.8, hz:120 },
  dominus:     { hx:77.9,  hy:29.3, hz:120 }
};
const gltfLoader = new GLTFLoader();

function loadCarModel(presetName) {
  const url = `models/${presetName}.glb`;
  console.log("Loading GLB:", url);

  gltfLoader.load(
    url,
    (gltf) => {
      const model = gltf.scene;

      model.traverse((o) => {
        if (o.isMesh) {
          o.castShadow = false;
          o.receiveShadow = false;
        }
      });

      // Center / height
      model.position.set(0, -BOX.hy, 0);

      // Scale the GLB
      const CAR_SCALE = 1.6;
      model.scale.set(CAR_SCALE, CAR_SCALE, CAR_SCALE);

      // Rotate so nose points along +Z (toward camera)
      // Dominus needs different rotation than Octane
      if (presetName === 'dominus') {
        model.rotation.y = 0; // No rotation - try straight
      } else {
        model.rotation.y = -Math.PI / 2; // -90 degrees (octane)
      }

      car.add(model);
    },
    undefined,
    (err) => {
      console.error("Failed to load", url, err);
    }
  );
}


/* Car builder */
let car=null, BOX=null;
let faceArrow=null, faceTip=null, tornadoCircle=null;

function clearCar(){
  if(!car) return;
  scene.remove(car);
  car.traverse(o=>{
    if (o.geometry) o.geometry.dispose();
    if (o.material) {
      if (Array.isArray(o.material)) {
        o.material.forEach(m => m.dispose && m.dispose());
      } else {
        o.material.dispose && o.material.dispose();
      }
    }
  });
  car = null;
}
function buildCar(boxDims, presetName="placeholder"){
  console.log("buildCar preset:", presetName);

  clearCar();
  BOX = boxDims;
  car = new THREE.Group();
  car.position.y = 110;
  scene.add(car);

  if (presetName === "placeholder") {
    // Hitbox body + fancy fake car
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(BOX.hx*2, BOX.hy*2, BOX.hz*2),
      MAT_BODY
    );
    car.add(body);
    buildPlaceholderFancy();

    // colored face edges ONLY for placeholder
    const vFL = new THREE.Vector3(-BOX.hx, +BOX.hy, +BOX.hz);
    const vFR = new THREE.Vector3(+BOX.hx, +BOX.hy, +BOX.hz);
    const vBR = new THREE.Vector3(+BOX.hx, -BOX.hy, +BOX.hz);
    const vBL = new THREE.Vector3(-BOX.hx, -BOX.hy, +BOX.hz);
    addEdge(vFR, vFL, COL_UP);
    addEdge(vBR, vFR, COL_LEFT);
    addEdge(vBL, vBR, COL_DOWN);
    addEdge(vFL, vBL, COL_RIGHT);
  }

  // GLB for octane/dominus (no hitbox body, no edges)
  if (presetName === "octane" || presetName === "dominus") {
    loadCarModel(presetName);
  }

  // arrow setup stays the same
  const zFace = BOX.hz + 0.6;
  const faceGeom = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0,0,zFace),
    new THREE.Vector3(0,0,zFace)
  ]);
  faceArrow = new THREE.Line(faceGeom, new THREE.LineBasicMaterial({color: 0x333333}));
  car.add(faceArrow);

  faceTip = new THREE.Mesh(new THREE.ConeGeometry(6,12,12), new THREE.MeshBasicMaterial({color: 0x333333}));
  faceTip.position.set(0,0,zFace);
  car.add(faceTip);
  faceArrow.visible = false;
  faceTip.visible = false;

  // Tornado circle visualizer
  const circleGeom = new THREE.CircleGeometry(1, 64);
  circleGeom.vertices = circleGeom.attributes.position.array;
  const circleMat = new THREE.LineBasicMaterial({color: 0x00ff00, transparent: true, opacity: 0.9, linewidth: 2});
  const circlePoints = [];
  for (let i = 0; i <= 64; i++) {
    const angle = (i / 64) * Math.PI * 2;
    circlePoints.push(new THREE.Vector3(Math.cos(angle), Math.sin(angle), 0));
  }
  const circleLineGeom = new THREE.BufferGeometry().setFromPoints(circlePoints);
  tornadoCircle = new THREE.Line(circleLineGeom, circleMat);
  tornadoCircle.position.set(0, 0, zFace);
  car.add(tornadoCircle);
  tornadoCircle.visible = false;
}
function addEdge(a,b,color){
  const geo = new THREE.BufferGeometry().setFromPoints([a,b]);
  const line = new THREE.Line(geo, MAT_EDGE(color));
  car.add(line);
}
function addWheel(x, z, r=18, w=12){
  const g = new THREE.CylinderGeometry(r, r, w, 16);
  const front = new THREE.Mesh(g, MAT_TIRE_F);
  const back  = new THREE.Mesh(g, MAT_TIRE_B);
  front.rotation.z = Math.PI/2; back.rotation.z  = Math.PI/2;
  const y = -BOX.hy- r*0.55;
  front.position.set(x, y, z + w/2);
  back .position.set(x, y, z - w/2);
  const hub = new THREE.Mesh(new THREE.CylinderGeometry(r*0.35, r*0.35, w*0.6, 10), MAT_HUB);
  hub.rotation.z = Math.PI/2; hub.position.set(x, y, z);
  const grp = new THREE.Group(); grp.add(back, front, hub); car.add(grp);
}
function addCabin(width, height, length, yOffset, zOffset){
  const cabin = new THREE.Mesh(new THREE.BoxGeometry(width, height, length), MAT_GLASS);
  cabin.position.set(0, yOffset, zOffset);
  car.add(cabin);
}
function addSpoiler(width, thickness, depth, yOffset, zOffset){
  const spoiler = new THREE.Mesh(new THREE.BoxGeometry(width, thickness, depth), MAT_ACCENT);
  spoiler.position.set(0, yOffset, zOffset);
  const st1 = new THREE.Mesh(new THREE.BoxGeometry(thickness, yOffset*0.5, thickness), MAT_ACCENT);
  const st2 = st1.clone();
  st1.position.set(-width*0.35, yOffset*0.25, zOffset - depth*0.2);
  st2.position.set(+width*0.35, yOffset*0.25, zOffset - depth*0.2);
  car.add(spoiler, st1, st2);
}
function addBumper(width, height, depth, yOffset, zOffset){
  const bumper = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), MAT_DARK);
  bumper.position.set(0, yOffset, zOffset);
  car.add(bumper);
}
function addFlares(xw, zw, r=10, w=6){
  const hemi = new THREE.CylinderGeometry(r, r, w, 10, 1, false, 0, Math.PI);
  const mat = MAT_ACCENT;
  const y = -BOX.hy + r*0.2;
  function flare(px, pz, flip){
    const f = new THREE.Mesh(hemi, mat);
    f.rotation.z = Math.PI/2;
    f.rotation.y = flip? Math.PI : 0;
    f.position.set(px, y, pz);
    car.add(f);
  }
  flare(+xw+6, +zw, false);
  flare(-xw-6, +zw, true);
  flare(+xw+6, -zw, true);
  flare(-xw-6, -zw, false);
}
function buildPlaceholderFancy(){
  const xOff = BOX.hx-10, zOff = BOX.hz*0.68;
   addWheel(+xOff, -zOff);
  addWheel(-xOff, -zOff);
  addWheel(+xOff, +zOff);
  addWheel(-xOff, +zOff);
  
  addFlares(xOff, zOff, 10, 6);
  addCabin(BOX.hx*1.0, BOX.hy*0.9, BOX.hz*0.55, BOX.hy*0.65, -BOX.hz*0.1);
  addSpoiler(BOX.hx*1.0, 6, 24, BOX.hy*0.8, -BOX.hz*0.95);
  addBumper(BOX.hx*0.9, 10, 18, -BOX.hy*0.7, +BOX.hz*0.98);
}
function buildOctane(){
  const xOff = BOX.hx-6, zOff = BOX.hz*0.64;
  addWheel(+xOff, -zOff, 19, 12); addWheel(-xOff, -zOff, 19, 12);
  addWheel(+xOff, +zOff, 18, 12); addWheel(-xOff, +zOff, 18, 12);
  addFlares(xOff, zOff, 12, 7);
  addCabin(BOX.hx*0.95, BOX.hy*1.1, BOX.hz*0.60, BOX.hy*0.85, -BOX.hz*0.05);
  addSpoiler(BOX.hx*1.2, 6, 30, BOX.hy*0.9, -BOX.hz*1.02);
  addBumper(BOX.hx*0.85, 12, 20, -BOX.hy*0.6, +BOX.hz*1.02);
}
function buildDominus(){
  const xOff = BOX.hx-8, zOff = BOX.hz*0.70;
  addWheel(+xOff, -zOff, 18, 12); addWheel(-xOff, -zOff, 18, 12);
  addWheel(+xOff, +zOff, 18, 12); addWheel(-xOff, +zOff, 18, 12);
  addFlares(xOff, zOff, 11, 6);
  addCabin(BOX.hx*1.05, BOX.hy*0.75, BOX.hz*0.75, BOX.hy*0.6, -BOX.hz*0.05);
  addSpoiler(BOX.hx*0.9, 5, 18, BOX.hy*0.72, -BOX.hz*1.0);
  addBumper(BOX.hx*1.05, 10, 30, -BOX.hy*0.55, +BOX.hz*1.05);
}

/* HUD utils */
const hctx = hud.getContext('2d');
function sizeHud(){ hud.width = innerWidth; hud.height = innerHeight; }
sizeHud();
function Hclear(){hctx.setTransform(1,0,0,1,0,0); hctx.clearRect(0,0,hud.width,hud.height);}
function Hcircle(x,y,r,strokeStyle,width){hctx.beginPath();hctx.lineWidth=width;hctx.strokeStyle=strokeStyle;hctx.arc(x,y,r,0,Math.PI*2);hctx.stroke();}
function HfillCircle(x,y,r,fillStyle){hctx.beginPath();hctx.fillStyle=fillStyle;hctx.arc(x,y,r,0,Math.PI*2);hctx.fill();}
function Harc(x,y,r,a1,a2,strokeStyle,width){hctx.beginPath();hctx.lineWidth=width;hctx.strokeStyle=strokeStyle;hctx.arc(x,y,r,a1,a2);hctx.stroke();}
function Hline(x1,y1,x2,y2,strokeStyle,width){hctx.beginPath();hctx.lineWidth=width;hctx.strokeStyle=strokeStyle;hctx.moveTo(x1,y1);hctx.lineTo(x2,y2);hctx.stroke();}
function Htri(x,y,a,r,fillStyle){hctx.save();hctx.translate(x,y);hctx.rotate(a);hctx.beginPath();hctx.moveTo(0,-r);hctx.lineTo(r*0.9,r*0.9);hctx.lineTo(-r*0.9,r*0.9);hctx.closePath();hctx.fillStyle=fillStyle;hctx.fill();hctx.restore();}

/* Joystick */
let JOY_BASE_R = 100, JOY_KNOB_R = Math.round(JOY_BASE_R*0.32);
let JOY_CENTER = new THREE.Vector2(130, window.innerHeight-130); // Bottom left
let joyActive=false, joyVec = new THREE.Vector2(0,0), smJoy = new THREE.Vector2(0,0);
const STICK_TAU_MS=8, RELOCATE_HOLD_MS=250, STICK_MIN=0.02;
let activeId=null, relocating=false, holdTimer=null;
let activePointers = new Map(); // Track all active pointers for multi-touch

// Multi-touch state tracking (per pointer ID)
let joyPointerId = null;    // Pointer controlling joystick
let boostPointerId = null;  // Pointer controlling boost button
let darPointerId = null;    // Pointer controlling DAR button
const COLS = {UP:'#ff5c5c', RIGHT:'#4c8dff', DOWN:'#53d769', LEFT:'#ffd166'};

function drawJoystick(){
  const cx=JOY_CENTER.x, cy=JOY_CENTER.y, r=JOY_BASE_R;
  const t=performance.now(); const pulse=1+0.06*Math.sin(t*0.008), halo=r*pulse+10;
  Hcircle(cx,cy,halo, 'rgba(76,141,255,0.28)', 8);
  Harc(cx,cy,r, -Math.PI/4,  Math.PI/4,   COLS.RIGHT, 12);
  Harc(cx,cy,r,  Math.PI/4,  3*Math.PI/4, COLS.UP,    12);
  Harc(cx,cy,r,  3*Math.PI/4,5*Math.PI/4, COLS.LEFT,  12);
  Harc(cx,cy,r,  5*Math.PI/4,7*Math.PI/4, COLS.DOWN,  12);
  Hcircle(cx,cy,r-18, '#b9c1cd', 2);
  Hline(cx-r+12,cy,cx+r-12,cy,'#cfd6e2',1.5);
  Hline(cx,cy-r+12,cx,cy+r-12,'#cfd6e2',1.5);
  const kx=cx+joyVec.x, ky=cy+joyVec.y;
  Hcircle(kx,ky,JOY_KNOB_R,'#4c8dff',4); HfillCircle(kx,ky,JOY_KNOB_R,'#0f1116');
  hctx.fillStyle='#222'; hctx.beginPath(); hctx.arc(cx,cy,3,0,Math.PI*2);hctx.fill();
}
function inJoyLoose(x,y){
  const dx=x-JOY_CENTER.x, dy=y-JOY_CENTER.y;
  const loose=JOY_BASE_R+28;
  const inC = (dx*dx+dy*dy) <= loose*loose;
  const inB = (Math.abs(dx)<=JOY_BASE_R) && (Math.abs(dy)<=JOY_BASE_R+40);
  return inC || inB;
}
function vecFromJoyPx(x,y){
  let dx=x-JOY_CENTER.x, dy=y-JOY_CENTER.y;
  const m=Math.hypot(dx,dy);
  if(m>JOY_BASE_R){const k=JOY_BASE_R/(m||1); dx*=k; dy*=k;}
  return new THREE.Vector2(dx,dy);
}
function clampJoyCenter(){
  JOY_CENTER.x = Math.max(JOY_BASE_R+20, Math.min(innerWidth -(JOY_BASE_R+20), JOY_CENTER.x));
  JOY_CENTER.y = Math.max(JOY_BASE_R+20, Math.min(innerHeight-(JOY_BASE_R+20), JOY_CENTER.y));
}

/* DAR button (toggle + relocate) */
let DAR_R = 44;
let DAR_CENTER = new THREE.Vector2(window.innerWidth-80, window.innerHeight-130); // Bottom right, same height as joystick
let darOn = false, darRelocating = false, darHoldTimer = null, darPressT=0;

/* Boost button (for Ring Mode without gamepad) */
let BOOST_R = 50;
let BOOST_CENTER = new THREE.Vector2(window.innerWidth-80, window.innerHeight-250); // Bottom right, below DAR button
let boostRelocating = false, boostHoldTimer = null, boostPressT=0;
let showBoostButton = isMobile; // Only show on mobile/tablet, not desktop

function drawDAR(){
  const cx=DAR_CENTER.x, cy=DAR_CENTER.y, r=DAR_R;
  HfillCircle(cx,cy,r, darOn ? 'rgba(0,102,255,0.18)' : 'rgba(24,26,32,0.75)');
  Hcircle(cx,cy,r, darOn ? '#4c8dff' : '#3a3d45', darOn ? 5 : 3);
  const a = (airRoll>0) ? Math.PI/2 : -Math.PI/2;
  Htri(cx,cy,a, r*0.55, darOn ? '#0e0f12' : '#e8e8ea');
  Hcircle(cx,cy,r-12, '#bdbdbd', 1.5);
}

function drawBoost(){
  const cx=BOOST_CENTER.x, cy=BOOST_CENTER.y, r=BOOST_R;
  HfillCircle(cx,cy,r, ringModeBoostActive ? 'rgba(255,92,92,0.25)' : 'rgba(24,26,32,0.75)');
  Hcircle(cx,cy,r, ringModeBoostActive ? '#ff5c5c' : '#3a3d45', ringModeBoostActive ? 5 : 3);
  // Draw "B" text
  hctx.fillStyle = ringModeBoostActive ? '#0e0f12' : '#e8e8ea';
  hctx.font = 'bold 24px system-ui';
  hctx.textAlign = 'center';
  hctx.textBaseline = 'middle';
  hctx.fillText('B', cx, cy);
}

function inDAR(x,y){
  const dx=x-DAR_CENTER.x, dy=y-DAR_CENTER.y;
  return (dx*dx+dy*dy) <= (DAR_R*DAR_R);
}
function clampDARCenter(){
  const m=DAR_R+20;
  DAR_CENTER.x = Math.max(m, Math.min(innerWidth - m, DAR_CENTER.x));
  DAR_CENTER.y = Math.max(m, Math.min(innerHeight - m, DAR_CENTER.y));
}

function inBoost(x,y){
  const dx=x-BOOST_CENTER.x, dy=y-BOOST_CENTER.y;
  return (dx*dx+dy*dy) <= (BOOST_R*BOOST_R);
}
function clampBoostCenter(){
  const m=BOOST_R+20;
  BOOST_CENTER.x = Math.max(m, Math.min(innerWidth - m, BOOST_CENTER.x));
  BOOST_CENTER.y = Math.max(m, Math.min(innerHeight - m, BOOST_CENTER.y));
}

/* Hints */
const joyHint = document.getElementById('joyHint');
const darHint = document.getElementById('darHint');
function showHint(el,ms){ el.classList.add('show'); setTimeout(()=>el.classList.remove('show'), ms); }
function positionHints(){
  joyHint.style.left = (JOY_CENTER.x + JOY_BASE_R + 18)+'px';
  joyHint.style.top  = (JOY_CENTER.y - JOY_BASE_R - 18)+'px';
  darHint.style.left = (DAR_CENTER.x + DAR_R + 18)+'px';
  darHint.style.top  = (DAR_CENTER.y - DAR_R - 18)+'px';
}

/* MENU open/close */
const menuBtn=document.getElementById('menuBtn');
const menuOverlay=document.getElementById('menuOverlay');
const menuCloseBtn=document.getElementById('menuCloseBtn');
let chromeShown=false;

// Controller menu navigation
let menuFocusIndex = 0;
let menuFocusableElements = [];
let menuNavigationCooldown = 0;
const MENU_NAV_COOLDOWN = 200; // ms between navigation inputs

function updateMenuFocusableElements() {
  // Get all interactive elements in the menu, including card headers
  menuFocusableElements = Array.from(document.querySelectorAll(
    '#menuPanel .card h3, #menuPanel button, #menuPanel input[type="range"], #menuPanel select'
  )).filter(el => {
    // Only include visible elements
    // For elements inside collapsed cards, check if parent card is collapsed
    const card = el.closest('.card');
    if (card && card.classList.contains('collapsed') && el.tagName !== 'H3') {
      return false; // Don't include elements in collapsed cards
    }
    return el.offsetParent !== null;
  });
}

function findClosestElementInDirection(direction) {
  if (menuFocusableElements.length === 0) return menuFocusIndex;

  const currentEl = menuFocusableElements[menuFocusIndex];
  const isHeader = currentEl.tagName === 'H3';

  // UP/DOWN behavior depends on what's focused
  if (direction === 'down' || direction === 'up') {
    const step = direction === 'down' ? 1 : -1;
    const currentCard = currentEl.closest('.card');

    // If on a card header (H3), jump to next/previous card header
    if (isHeader) {
      for (let i = 1; i < menuFocusableElements.length; i++) {
        const checkIndex = (menuFocusIndex + (i * step) + menuFocusableElements.length) % menuFocusableElements.length;
        const checkEl = menuFocusableElements[checkIndex];

        if (checkEl.tagName === 'H3') {
          return checkIndex;
        }
      }
    } else {
      // If on a control (slider/button), navigate within the card
      for (let i = 1; i < menuFocusableElements.length; i++) {
        const checkIndex = (menuFocusIndex + (i * step) + menuFocusableElements.length) % menuFocusableElements.length;
        const checkEl = menuFocusableElements[checkIndex];
        const checkCard = checkEl.closest('.card');

        // Stay within the same card
        if (checkCard === currentCard) {
          return checkIndex;
        }

        // If we've left the card, wrap to the card header
        const headerIndex = menuFocusableElements.findIndex(el =>
          el.tagName === 'H3' && el.closest('.card') === currentCard
        );
        if (headerIndex !== -1) return headerIndex;
      }
    }

    // Fallback
    return (menuFocusIndex + step + menuFocusableElements.length) % menuFocusableElements.length;
  }

  // LEFT/RIGHT: Navigate within current card (sequential)
  if (direction === 'left' || direction === 'right') {
    const step = direction === 'right' ? 1 : -1;
    const currentCard = currentEl.closest('.card');

    // Try to find next/previous element in same card
    for (let i = 1; i < menuFocusableElements.length; i++) {
      const checkIndex = (menuFocusIndex + (i * step) + menuFocusableElements.length) % menuFocusableElements.length;
      const checkEl = menuFocusableElements[checkIndex];
      const checkCard = checkEl.closest('.card');

      // If still in same card, return this element
      if (checkCard === currentCard) {
        return checkIndex;
      }

      // If we've left the card, wrap back to start/end of current card
      if (direction === 'right') {
        // Wrap to first element in card
        return menuFocusableElements.findIndex(el => el.closest('.card') === currentCard);
      } else {
        // Wrap to last element in card
        for (let j = menuFocusableElements.length - 1; j >= 0; j--) {
          if (menuFocusableElements[j].closest('.card') === currentCard) {
            return j;
          }
        }
      }
    }

    // Fallback to sequential
    return (menuFocusIndex + step + menuFocusableElements.length) % menuFocusableElements.length;
  }

  return menuFocusIndex;
}

function focusMenuElement(index) {
  // Remove previous focus styling
  menuFocusableElements.forEach(el => {
    el.style.outline = '';
    el.style.boxShadow = '';
  });

  if (menuFocusableElements.length === 0) return;

  // Wrap index
  menuFocusIndex = ((index % menuFocusableElements.length) + menuFocusableElements.length) % menuFocusableElements.length;

  // Add focus styling to current element
  const focusedEl = menuFocusableElements[menuFocusIndex];
  focusedEl.style.outline = '3px solid #4c8dff';
  focusedEl.style.boxShadow = '0 0 12px rgba(76, 141, 255, 0.6)';

  // Scroll into view - use 'center' to ensure it's fully visible
  // Use setTimeout to ensure it happens after any layout changes
  setTimeout(() => {
    focusedEl.scrollIntoView({
      block: 'center',
      inline: 'nearest',
      behavior: 'smooth'
    });
  }, 10);
}

function activateMenuElement() {
  if (menuFocusableElements.length === 0) return;
  const el = menuFocusableElements[menuFocusIndex];

  if (el.tagName === 'H3') {
    // Toggle collapse/expand for card headers
    el.click();
  } else if (el.tagName === 'BUTTON') {
    el.click();
  } else if (el.tagName === 'INPUT' && el.type === 'range') {
    // For sliders, we'll allow left/right to adjust them
    // Clicking just focuses it for now
  } else if (el.tagName === 'SELECT') {
    // For select, X button does nothing - use left/right to change options
  }
}

function adjustSliderValue(direction) {
  if (menuFocusableElements.length === 0) return;
  const el = menuFocusableElements[menuFocusIndex];

  if (el.tagName === 'INPUT' && el.type === 'range') {
    const step = parseFloat(el.step) || 1;
    const currentValue = parseFloat(el.value);
    const newValue = currentValue + (direction * step);
    const min = parseFloat(el.min);
    const max = parseFloat(el.max);

    el.value = Math.max(min, Math.min(max, newValue));
    el.dispatchEvent(new Event('input', { bubbles: true }));
  }
}

function adjustSelectValue(direction) {
  if (menuFocusableElements.length === 0) return;
  const el = menuFocusableElements[menuFocusIndex];

  if (el.tagName === 'SELECT') {
    const currentIndex = el.selectedIndex;
    const newIndex = currentIndex + direction;

    // Clamp to valid range
    if (newIndex >= 0 && newIndex < el.options.length) {
      el.selectedIndex = newIndex;
      el.dispatchEvent(new Event('change', { bubbles: true }));
    }
  }
}

// Initialize collapsible cards
let cardsInitialized = false;
function initCollapsibleCards() {
  // Only initialize once to avoid duplicate event listeners
  if (cardsInitialized) return;
  cardsInitialized = true;

  const cards = document.querySelectorAll('.card');
  cards.forEach((card, index) => {
    const h3 = card.querySelector('h3');
    if (!h3) return;

    // Wrap all content after h3 in a card-content div
    if (!card.querySelector('.card-content')) {
      const content = document.createElement('div');
      content.className = 'card-content';

      // Move all children after h3 into content div
      const children = Array.from(card.children);
      children.forEach(child => {
        if (child !== h3) {
          content.appendChild(child);
        }
      });
      card.appendChild(content);

      // Collapse all cards except the first one (Rotation)
      const isRotationCard = h3.textContent.trim() === 'Rotation';
      if (!isRotationCard) {
        card.classList.add('collapsed');
        content.style.maxHeight = '0';
      } else {
        content.style.maxHeight = content.scrollHeight + 'px';
      }
    }

    // Add click handler to h3 (includes the arrow indicator)
    h3.addEventListener('click', (e) => {
      e.stopPropagation(); // Prevent event bubbling
      const content = card.querySelector('.card-content');
      const isCollapsed = card.classList.contains('collapsed');

      if (isCollapsed) {
        card.classList.remove('collapsed');
        content.style.maxHeight = content.scrollHeight + 'px';
      } else {
        card.classList.add('collapsed');
        content.style.maxHeight = '0';
      }

      // Update focusable elements after collapse/expand
      setTimeout(() => {
        updateMenuFocusableElements();
      }, 50);
    });
  });
}

function openMenu(){
  chromeShown=true;
  menuBtn.classList.add('active');
  menuOverlay.style.display='block';

  // Initialize collapsible cards on first open
  initCollapsibleCards();

  // Initialize menu navigation
  updateMenuFocusableElements();
  menuFocusIndex = 0;
  if (menuFocusableElements.length > 0) {
    focusMenuElement(0);
  }
}
function closeMenu(){
  chromeShown=false;
  menuBtn.classList.remove('active');
  menuOverlay.style.display='none';

  // Clear focus styling
  menuFocusableElements.forEach(el => {
    el.style.outline = '';
    el.style.boxShadow = '';
  });

  // CRITICAL: Clear gamepad button state for air roll actions to prevent
  // stale button presses from being processed when menu closes
  gpPrevActionPressed['rollLeft'] = false;
  gpPrevActionPressed['rollRight'] = false;
  gpPrevActionPressed['rollFree'] = false;
}
menuBtn.addEventListener('click',()=> chromeShown ? closeMenu() : openMenu());
menuCloseBtn.addEventListener('click', closeMenu);
menuOverlay.addEventListener('click',(e)=>{ if(e.target===menuOverlay) closeMenu(); });

/* Sliders / select */
const accelPitch=document.getElementById('accelPitch'), accelPitchTag=document.getElementById('accelPitchTag');
const accelYaw=document.getElementById('accelYaw'), accelYawTag=document.getElementById('accelYawTag');
const accelRoll=document.getElementById('accelRoll'), accelRollTag=document.getElementById('accelRollTag');
const curveRange=document.getElementById('curveRange'), curveTag=document.getElementById('curveTag');
const dampRange=document.getElementById('dampRange'),   dampTag=document.getElementById('dampTag');
const dampDARRange=document.getElementById('dampDARRange'), dampDARTag=document.getElementById('dampDARTag');
const brakeRange=document.getElementById('brakeRange'), brakeTag=document.getElementById('brakeTag');
const wmaxRange=document.getElementById('wmaxRange'),   wmaxTag=document.getElementById('wmaxTag');
const wmaxPitchRange=document.getElementById('wmaxPitch'), wmaxPitchTag=document.getElementById('wmaxPitchTag');
const wmaxYawRange=document.getElementById('wmaxYaw'), wmaxYawTag=document.getElementById('wmaxYawTag');
const wmaxRollRange=document.getElementById('wmaxRoll'), wmaxRollTag=document.getElementById('wmaxRollTag');
const circleTiltRange=document.getElementById('circleTilt'), circleTiltTag=document.getElementById('circleTiltTag');
const circleTiltModifierRange=document.getElementById('circleTiltModifier'), circleTiltModifierTag=document.getElementById('circleTiltModifierTag');
const circleScaleRange=document.getElementById('circleScale'), circleScaleTag=document.getElementById('circleScaleTag');
const sizeSlider=document.getElementById('stickSizeSlider'), stickVal=document.getElementById('stickVal');
const zoomSlider=document.getElementById('zoomSlider'), zoomVal=document.getElementById('zoomVal');
const arrowSlider=document.getElementById('arrowSlider'), arrowVal=document.getElementById('arrowVal');
const brightnessSlider=document.getElementById('brightnessSlider'), brightnessVal=document.getElementById('brightnessVal');
const presetSel=document.getElementById('presetSel');

// Load saved settings from localStorage or use defaults
function loadSettings() {
  const saved = localStorage.getItem('darSettings');
  if (saved) {
    try {
      const parsed = JSON.parse(saved);
      console.log('Settings loaded from localStorage:', parsed);
      return parsed;
    } catch (e) {
      console.error('Failed to parse saved settings:', e);
      return {};
    }
  }
  console.log('No saved settings found, using defaults');
  return {};
}

function saveSettings() {
  try {
    const settings = {
      maxAccelPitch, maxAccelYaw, maxAccelRoll,
      inputPow, damp, dampDAR, brakeOnRelease,
      wMax, wMaxPitch, wMaxYaw, wMaxRoll,
      circleTiltAngle, circleTiltModifier, circleScale,
      zoom, arrowScale,
      isDarkMode, airRollIsToggle,
      brightnessDark, brightnessLight,
      gpEnabled, gpBindings,
      showArrow, showCircle,
      ringModeHighScore,
      lastActiveAirRoll,
      ringDifficulty: currentDifficulty,
      gameSoundsEnabled,
      gameMusicEnabled
    };

    // Only save these if the elements exist
    const gpPresetEl = document.getElementById('gpPreset');
    if (gpPresetEl) {
      settings.gpPreset = gpPresetEl.value;
    }

    const presetSelEl = document.getElementById('presetSel');
    if (presetSelEl) {
      settings.selectedCarBody = presetSelEl.value;
    }

    const json = JSON.stringify(settings);
    localStorage.setItem('darSettings', json);
    console.log('Settings saved:', settings);
    console.log('Settings JSON length:', json.length, 'chars');

    // Verify it was saved
    const verification = localStorage.getItem('darSettings');
    if(verification === json){
      console.log('âœ“ Verified: Settings successfully written to localStorage');
    } else {
      console.error('âœ— ERROR: localStorage verification failed!');
    }
  } catch (e) {
    console.error('Failed to save settings:', e);
  }
}

const savedSettings = loadSettings();

// Initialize gamepad bindings early (will be properly set later)
let gpEnabled = savedSettings.gpEnabled ?? true;
let gpBindings = savedSettings.gpBindings ?? null; // Will be set to defaultGpBindings later if still null

// Restore theme mode (default to true = dark mode)
isDarkMode = savedSettings.isDarkMode ?? true;

let maxAccelPitch=savedSettings.maxAccelPitch ?? parseFloat(accelPitch.value),
    maxAccelYaw=savedSettings.maxAccelYaw ?? parseFloat(accelYaw.value),
    maxAccelRoll=savedSettings.maxAccelRoll ?? parseFloat(accelRoll.value),
    inputPow=savedSettings.inputPow ?? parseFloat(curveRange.value),
    damp=savedSettings.damp ?? parseFloat(dampRange.value),
    dampDAR=savedSettings.dampDAR ?? parseFloat(dampDARRange.value),
    brakeOnRelease=savedSettings.brakeOnRelease ?? parseFloat(brakeRange.value),
    wMax=savedSettings.wMax ?? parseFloat(wmaxRange.value),
    wMaxPitch=savedSettings.wMaxPitch ?? parseFloat(wmaxPitchRange.value),
    wMaxYaw=savedSettings.wMaxYaw ?? parseFloat(wmaxYawRange.value),
    wMaxRoll=savedSettings.wMaxRoll ?? parseFloat(wmaxRollRange.value),
    circleTiltAngle=savedSettings.circleTiltAngle ?? parseFloat(circleTiltRange.value),
    circleTiltModifier=savedSettings.circleTiltModifier ?? parseFloat(circleTiltModifierRange.value),
    circleScale=savedSettings.circleScale ?? parseFloat(circleScaleRange.value),
    zoom=savedSettings.zoom ?? parseFloat(zoomSlider.value),
    arrowScale=savedSettings.arrowScale ?? parseFloat(arrowSlider.value);

// Brightness settings (separate for dark and light modes)
let brightnessDark = savedSettings.brightnessDark ?? 1.0;
let brightnessLight = savedSettings.brightnessLight ?? 1.0;

// Audio settings
let gameSoundsEnabled = savedSettings.gameSoundsEnabled ?? true;
let gameMusicEnabled = savedSettings.gameMusicEnabled ?? true;

// Apply loaded values to sliders
accelPitch.value = maxAccelPitch;
accelYaw.value = maxAccelYaw;
accelRoll.value = maxAccelRoll;
curveRange.value = inputPow;
dampRange.value = damp;
dampDARRange.value = dampDAR;
brakeRange.value = brakeOnRelease;
wmaxRange.value = wMax;
wmaxPitchRange.value = wMaxPitch;
wmaxYawRange.value = wMaxYaw;
wmaxRollRange.value = wMaxRoll;
circleTiltRange.value = circleTiltAngle;
circleTiltModifierRange.value = circleTiltModifier;
circleScaleRange.value = circleScale;
zoomSlider.value = zoom;
arrowSlider.value = arrowScale;

/* Air Roll System */
// Air roll values: -1 = left, 0 = off, +1 = right, 2 = free
let airRoll = savedSettings.airRoll ?? 0; // default to off
let lastActiveAirRoll = savedSettings.lastActiveAirRoll ?? -1; // Remember last active for DAR toggle (default to Air Roll Left)
// Default: toggle for keyboard (gpEnabled=false), hold for gamepad (gpEnabled=true)
let airRollIsToggle = savedSettings.airRollIsToggle ?? (savedSettings.gpEnabled === false);

/* Keyboard Input State */
const keyState = new Map(); // Track which keys are currently held down
const keyPrevState = new Map(); // Track previous frame state for edge detection

// Keyboard event listeners
window.addEventListener('keydown', (e) => {
  keyState.set(e.code, true);
});

window.addEventListener('keyup', (e) => {
  keyState.set(e.code, false);
});

// Helper: Check if key was just pressed this frame (edge detection)
function keyJustPressed(code) {
  return keyState.get(code) && !keyPrevState.get(code);
}

// Helper: Check if key is currently held down
function keyHeld(code) {
  return keyState.get(code) || false;
}

function setRoll(dir, skipSave = false){
  airRoll = dir;
  // Remember last active air roll for DAR toggle (but not 0)
  if(dir !== 0) lastActiveAirRoll = dir;
  // Sync darOn with air roll state (on if any air roll is active)
  darOn = (dir !== 0);
  if (!skipSave) saveSettings();
}

function updateMenuButtonStyling(){
  // Menu buttons show which air roll is SELECTED (not active)
  document.getElementById('rollL').classList.toggle('active', lastActiveAirRoll === -1);
  document.getElementById('rollR').classList.toggle('active', lastActiveAirRoll === 1);
  document.getElementById('rollFree').classList.toggle('active', lastActiveAirRoll === 2);
}

function toggleRoll(dir){
  // For toggle mode: tap to activate, tap again to deactivate
  if(airRollIsToggle){
    if(airRoll === dir){
      setRoll(0); // Turn off if already active
    } else {
      setRoll(dir); // Switch to this mode
    }
  } else {
    // For hold mode: handled by gamepad button state
    setRoll(dir);
  }
}

function selectAirRoll(dir){
  // Menu buttons: just select which air roll to use (don't activate it)
  lastActiveAirRoll = dir;
  updateMenuButtonStyling();
  saveSettings();
}

document.getElementById('rollL').addEventListener('click', () => selectAirRoll(-1)); // Air Roll Left
document.getElementById('rollR').addEventListener('click', () => selectAirRoll(1));  // Air Roll Right
document.getElementById('rollFree').addEventListener('click', () => selectAirRoll(2));

// Reset Physics to Defaults button
document.getElementById('resetPhysicsDefaults').addEventListener('click', () => {
  // Clear localStorage to force defaults on next load
  localStorage.removeItem('darSettings');

  // Reload the page to apply defaults
  location.reload();
});

// Toggle/Hold mode button
document.getElementById('toggleMode').addEventListener('click', () => {
  airRollIsToggle = !airRollIsToggle;
  const btn = document.getElementById('toggleMode');
  btn.classList.toggle('active', airRollIsToggle);
  btn.textContent = airRollIsToggle ? 'Toggle' : 'Hold';
  saveSettings();
});

/* Ring Mode */
/*
 * ===== COORDINATE SYSTEM GUIDE - READ THIS BEFORE ROTATING ANYTHING =====
 *
 * THREE.JS WORLD COORDINATES (Standard Right-Handed System):
 * - X axis: LEFT (-) to RIGHT (+) across the screen
 * - Y axis: DOWN (-) to UP (+) on the screen
 * - Z axis: AWAY from camera (-) to TOWARD camera (+) - THIS IS DEPTH
 *
 * CAMERA SETUP:
 * - Camera positioned at positive Z looking toward origin (0,0,0)
 * - From camera's view: +X = right, +Y = up, +Z = toward you, -Z = into screen
 *
 * ===== CRITICAL: UNDERSTANDING ROTATIONS IN THREE.JS =====
 *
 * When you call car.rotation.set(x, y, z), you are setting EULER ANGLES.
 * Three.js applies rotations in XYZ ORDER (this matters!):
 *   1. First: Rotate around X axis
 *   2. Second: Rotate around Y axis (which has now moved due to X rotation)
 *   3. Third: Rotate around Z axis (which has now moved due to X and Y rotations)
 *
 * VISUAL GUIDE - ROTATING FROM USER'S PERSPECTIVE:
 *   - X rotation: Pitch (nose up/down like nodding "yes")
 *   - Y rotation: Yaw (turning left/right like shaking head "no") - THIS IS DEPTH AXIS ROTATION
 *   - Z rotation: Roll (barrel roll, tilting left/right) - THIS IS UP/DOWN AXIS ROTATION
 *
 * IMPORTANT: The Y axis is the DEPTH axis (toward/away from camera)
 *            The Z axis is the UP/DOWN axis (vertical on screen)
 *            Rotating around Y = spinning on the depth axis
 *            Rotating around Z = spinning on the vertical axis
 *
 * ===== CAR MODEL DEFAULT ORIENTATION (at quaternion.identity, NO rotations) =====
 *
 * Default car orientation when spawned with NO rotation applied:
 * - Wheels/Bottom:  Facing UP (+Y, toward top of screen)
 * - Roof:           Facing DOWN (-Y, toward bottom of screen)
 * - Nose/Front:     Facing LEFT (-X, left side of screen)
 * - Rear/Back:      Facing RIGHT (+X, right side of screen)
 * - Right side:     Facing CAMERA (+Z, toward you)
 * - Left side:      Facing AWAY (-Z, away from you into screen)
 *
 * ===== DESIRED ORIENTATION FOR DAR TRAINING =====
 *
 * What we want to achieve:
 * - Roof:           Facing CAMERA (+Z, toward user)
 * - Wheels/Bottom:  Facing AWAY (-Z, into screen depth)
 * - Nose/Front:     Facing UP (+Y, top of screen)
 * - Rear/Back:      Facing DOWN (-Y, bottom of screen)
 * - Right side:     Facing RIGHT (+X)
 * - Left side:      Facing LEFT (-X)
 *
 * ===== FINAL WORKING ROTATION =====
 *
 * car.rotation.set(Math.PI * 1.5, 0, Math.PI)
 * Breaking it down:
 *   - X: +270Â° (Math.PI * 1.5) - Pitches nose UP, this gets us nose pointing up
 *   - Y: 0Â° - No depth rotation needed
 *   - Z: +180Â° (Math.PI) - Barrel roll to flip roof toward camera
 *
 * WHY THIS WORKS:
 * 1. Start: Car at identity (roof down, nose left, right-side toward camera)
 * 2. X rotation +270Â°: Pitches the car so nose points up (like tilting forward 3/4 turn)
 * 3. Z rotation +180Â°: Barrel rolls the car to flip roof toward camera
 *
 * ===== CAR MODEL LOCAL SPACE (GLB file internal axes) =====
 *
 * The GLB model has its own coordinate system baked in:
 * - Model +Z local: Points toward nose/front of car
 * - Model +X local: Points toward right side of car
 * - Model +Y local: Points toward roof of car
 *
 * Different car models may be exported with different default orientations:
 * - Dominus GLB: rotation.y = 0 (nose already points in correct direction)
 * - Octane GLB: rotation.y = -Math.PI/2 (-90Â°) needed to align nose correctly
 *
 * ===== ROTATION TESTING HISTORY (for reference) =====
 *
 * Attempts that DIDN'T work:
 * - (0, 0, Math.PI): Nose facing camera instead of up
 * - (Math.PI, 0, 0): Roof down, nose away from screen
 * - (Math.PI, -Math.PI/2, 0): Roof down, nose left
 * - (Math.PI/2, 0, Math.PI/2): Nose DOWN, rear UP, roof LEFT
 * - (0, -Math.PI/2, -Math.PI/2): Roof correct, but nose LEFT instead of UP
 * - (Math.PI/2, 0, -Math.PI/2): Various incorrect orientations
 * - (Math.PI, 0, -Math.PI/2): Still incorrect
 *
 * What WORKED: (Math.PI * 1.5, 0, Math.PI) - Nose UP confirmed, roof toward camera
 *
 * ===== RING MODE PHYSICS =====
 *
 * - Car is locked at world origin (0, 0, 0) - never moves in 3D space
 * - Visual movement simulated by translating car on 2D plane using ringModePosition
 * - Movement occurs in X-Y plane (left/right and up/down on screen)
 * - Rings spawn at negative Z (far from camera) and move toward positive Z (toward camera)
 * - This creates the illusion that the car is flying through depth
 *
 * ===== REMEMBER THIS TO AVOID CONFUSION =====
 *
 * If you need to rotate the car in the future:
 * 1. Y axis rotation = spinning around the DEPTH axis (toward/away from camera)
 * 2. Z axis rotation = spinning around the UP/DOWN axis (vertical on screen)
 * 3. X axis rotation = pitching nose up/down
 * 4. Rotations are applied in X-Y-Z order, so later rotations operate on moved axes
 * 5. Test one axis at a time in 90Â° increments to understand the effect
 * 6. The current working rotation is: car.rotation.set(Math.PI * 1.5, 0, Math.PI)
 *
 */
let ringModeActive = false;
let ringModeScore = 0;
let ringModeHighScore = savedSettings.ringModeHighScore ?? 0; // Track high score across sessions
let ringModeLives = 5;
let ringModeRingCount = 0;
let ringCameraSpeed = 0.1;

// Ring Mode Physics
let ringModeVelocity = new THREE.Vector2(0, 0); // XY velocity only
let ringModePosition = new THREE.Vector2(0, 0); // Car position in 2D plane
const RING_MAX_SPEED = 1400; // Max speed cap (~60 mph equivalent, more controllable)
const RING_BOOST_ACCEL = 1200; // Boost acceleration (balanced with reduced gravity)
const RING_GRAVITY = -600; // Constant downward gravity (reduced for slower speeds)
const RING_GRID_BOUNDS = 1500; // Movement boundary (3x larger: 500 * 3)
let ringModeBoostActive = false;
let ringModeStarted = false; // Track if player has started (boosted at least once)
let ringModePaused = false; // Track pause state

// Boost flame effects
let boostFlames = [];

// Audio context for ring pass sound
let audioContext = null;
function playRingPassSound() {
  if (!gameSoundsEnabled) return; // Check if sounds are enabled

  try {
    // Create audio context on first use (user interaction required)
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }

    // Create a dull, hollow "thunk" sound
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    // Lower frequency for dull thunk (C3 note = 130.8 Hz)
    oscillator.frequency.setValueAtTime(130.8, audioContext.currentTime);
    oscillator.type = 'triangle'; // Warmer, less harsh than sine

    // Quick attack and decay for "thunk" effect
    gainNode.gain.setValueAtTime(0.25, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.15);

    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.15);
  } catch (e) {
    console.warn('Audio playback failed:', e);
  }
}

function playRingMissSound() {
  if (!gameSoundsEnabled) return; // Check if sounds are enabled

  try {
    // Create audio context on first use (user interaction required)
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }

    // Create an obnoxious high-pitched "ding" sound
    const oscillator = audioContext.createOscillator();
    const gainNode = audioContext.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioContext.destination);

    // High frequency for bright ding (E6 note = 1318.5 Hz)
    oscillator.frequency.setValueAtTime(1318.5, audioContext.currentTime);
    oscillator.type = 'sine'; // Bright, sharp tone

    // Sharp attack and longer decay for "ding" effect
    gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
    gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.3);

    oscillator.start(audioContext.currentTime);
    oscillator.stop(audioContext.currentTime + 0.3);
  } catch (e) {
    console.warn('Audio playback failed:', e);
  }
}

// Boost rumble sound (continuous while boosting)
let boostRumbleOscillator = null;
let boostRumbleGain = null;

// Background music (chill beat with drums)
let musicBassOsc = null;
let musicChordOsc = null;
let musicKickOsc = null;
let musicHihatNoise = null;
let musicSnareNoise = null;
let musicGain = null;
let musicIntervalId = null;
let musicBeatIndex = 0;

// Chill chord progression (Am - F - C - G in Hz)
const chordProgression = [
  220,  // A (Am)
  174.6, // F
  261.6, // C
  196    // G
];

function startBackgroundMusic() {
  if (!gameMusicEnabled) return; // Check if music is enabled
  if (musicIntervalId) return; // Already playing

  try {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }

    // Create main gain for all music
    musicGain = audioContext.createGain();
    musicGain.connect(audioContext.destination);
    musicGain.gain.setValueAtTime(0.15, audioContext.currentTime); // Overall volume

    // Bass oscillator (sine wave for smooth bass)
    musicBassOsc = audioContext.createOscillator();
    const bassGain = audioContext.createGain();
    musicBassOsc.connect(bassGain);
    bassGain.connect(musicGain);
    musicBassOsc.type = 'sine';
    musicBassOsc.frequency.setValueAtTime(110, audioContext.currentTime); // A2
    bassGain.gain.setValueAtTime(0.3, audioContext.currentTime);
    musicBassOsc.start();

    // Chord pad (triangle wave for softer tone)
    musicChordOsc = audioContext.createOscillator();
    const chordGain = audioContext.createGain();
    musicChordOsc.connect(chordGain);
    chordGain.connect(musicGain);
    musicChordOsc.type = 'triangle';
    musicChordOsc.frequency.setValueAtTime(220, audioContext.currentTime); // A3
    chordGain.gain.setValueAtTime(0.15, audioContext.currentTime);
    musicChordOsc.start();

    // Drum pattern function
    function playBeat() {
      const beat = musicBeatIndex % 16; // 16 beat pattern
      const now = audioContext.currentTime;

      // Kick drum (beats 0, 4, 8, 12)
      if (beat % 4 === 0) {
        const kickOsc = audioContext.createOscillator();
        const kickGain = audioContext.createGain();
        kickOsc.connect(kickGain);
        kickGain.connect(musicGain);
        kickOsc.frequency.setValueAtTime(150, now);
        kickOsc.frequency.exponentialRampToValueAtTime(40, now + 0.1);
        kickGain.gain.setValueAtTime(0.5, now);
        kickGain.gain.exponentialRampToValueAtTime(0.01, now + 0.15);
        kickOsc.start(now);
        kickOsc.stop(now + 0.15);
      }

      // Hi-hat (beats 2, 6, 10, 14)
      if (beat % 4 === 2) {
        const noise = audioContext.createBufferSource();
        const noiseBuffer = audioContext.createBuffer(1, 4410, 44100); // 0.1s
        const noiseData = noiseBuffer.getChannelData(0);
        for (let i = 0; i < noiseData.length; i++) {
          noiseData[i] = Math.random() * 2 - 1;
        }
        noise.buffer = noiseBuffer;
        const hihatGain = audioContext.createGain();
        const hihatFilter = audioContext.createBiquadFilter();
        hihatFilter.type = 'highpass';
        hihatFilter.frequency.value = 7000;
        noise.connect(hihatFilter);
        hihatFilter.connect(hihatGain);
        hihatGain.connect(musicGain);
        hihatGain.gain.setValueAtTime(0.1, now);
        hihatGain.gain.exponentialRampToValueAtTime(0.01, now + 0.05);
        noise.start(now);
        noise.stop(now + 0.05);
      }

      // Change chord every 4 beats
      if (beat % 4 === 0) {
        const chordIndex = Math.floor(beat / 4) % chordProgression.length;
        const rootNote = chordProgression[chordIndex];
        musicBassOsc.frequency.setValueAtTime(rootNote / 2, now); // Bass (octave below)
        musicChordOsc.frequency.setValueAtTime(rootNote, now); // Chord root
      }

      musicBeatIndex++;
    }

    playBeat();
    musicIntervalId = setInterval(playBeat, 300); // 100 BPM 16th notes
  } catch (e) {
    console.warn('Music playback failed:', e);
  }
}

function stopBackgroundMusic() {
  if (!musicIntervalId) return;

  try {
    clearInterval(musicIntervalId);
    musicIntervalId = null;

    if (musicGain) {
      musicGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.1);
    }
    if (musicBassOsc) {
      musicBassOsc.stop(audioContext.currentTime + 0.1);
      musicBassOsc = null;
    }
    if (musicChordOsc) {
      musicChordOsc.stop(audioContext.currentTime + 0.1);
      musicChordOsc = null;
    }
    musicGain = null;
    musicBeatIndex = 0;
  } catch (e) {
    console.warn('Stop music failed:', e);
  }
}

function startBoostRumble() {
  if (!gameSoundsEnabled) return; // Check if sounds are enabled
  if (boostRumbleOscillator) return; // Already playing

  try {
    if (!audioContext) {
      audioContext = new (window.AudioContext || window.webkitAudioContext)();
    }

    // Create low rumble sound
    boostRumbleOscillator = audioContext.createOscillator();
    boostRumbleGain = audioContext.createGain();

    boostRumbleOscillator.connect(boostRumbleGain);
    boostRumbleGain.connect(audioContext.destination);

    // Very low frequency for deep rumble (30 Hz - sub-bass)
    boostRumbleOscillator.frequency.setValueAtTime(30, audioContext.currentTime);
    boostRumbleOscillator.type = 'sawtooth'; // Rough, engine-like sound

    // Low volume so it doesn't drown out ring sounds
    boostRumbleGain.gain.setValueAtTime(0.03, audioContext.currentTime); // Quarter volume

    boostRumbleOscillator.start(audioContext.currentTime);
  } catch (e) {
    console.warn('Boost rumble failed:', e);
  }
}

function stopBoostRumble() {
  if (!boostRumbleOscillator) return;

  try {
    // Fade out quickly
    boostRumbleGain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + 0.05);
    boostRumbleOscillator.stop(audioContext.currentTime + 0.05);
    boostRumbleOscillator = null;
    boostRumbleGain = null;
  } catch (e) {
    console.warn('Stop boost rumble failed:', e);
  }
}

// Camera smooth path tracking
let cameraTargetX = 0; // Smooth interpolated camera target position
let cameraTargetY = 0;

// Reset Ring Mode (for retry button)
function resetRingMode() {
  ringModeScore = 0;
  ringModeLives = DIFFICULTY_SETTINGS[currentDifficulty].initialLives;
  ringModeRingCount = 0;
  ringModeVelocity.set(0, 0);
  ringModePosition.set(0, 0);
  ringSpawnTimer = 0;
  ringSpawnIndex = 0;
  currentColorIndex = 0;
  ringModeStarted = false;
  ringModePaused = false;
  patternRingCount = 0;
  cameraTargetX = 0;
  cameraTargetY = 0;
  clearAllRings();
  clearBoostFlames();

  if (car) {
    car.quaternion.identity();
    car.rotation.set(Math.PI * 1.5, 0, Math.PI);
    car.position.set(0, 0, 0);
  }
  w.set(0,0,0);
  orbitOn = false;

  spawnRing();

  // Restart music
  startBackgroundMusic();
}

// Ring geometry and spawning
let rings = []; // Active rings in the scene
const RING_COLORS = [
  0xff00ff, // Magenta
  0x00ffff, // Cyan
  0xff0080, // Hot pink
  0x00ff00, // Green
  0xffff00, // Yellow
  0xff6600  // Orange
];
let currentColorIndex = 0;

// Preloaded ring resources (cached geometry and materials)
let ringGeometryCache = null;
let ringMaterialCache = new Map(); // Cache materials by color
let ringResourcesPreloaded = false;

// Ring sizing (car is ~30 units wide, ~20 tall, ~45 long based on Octane)
const CAR_WIDTH = 30;
const CAR_HEIGHT = 20;
const INITIAL_RING_SIZE = CAR_WIDTH * 20; // Start at 20x car width (600 units diameter) - MUCH BIGGER
const RING_TUBE_RADIUS = 8; // Thickness of the ring torus

// Ring movement and spawning
const RING_SPAWN_DISTANCE = -1100; // Spawn rings far behind camera (extra ~1.5 seconds reaction time)
const RING_DESPAWN_DISTANCE = 1000; // Remove rings well past camera (allows them to pass behind)
const RING_BASE_SPEED = 200; // Base units per second toward camera
const RING_BASE_SPAWN_INTERVAL = 3.0; // Base seconds between ring spawns
let ringSpawnTimer = 0;
let ringSpawnIndex = 0; // Track spawn order for camera focusing

// Difficulty settings
const DIFFICULTY_SETTINGS = {
  easy: {
    // Ring properties
    sizeMultiplier: 1.5,        // 50% larger rings
    speedMultiplier: 0.7,        // 30% slower
    spawnIntervalMultiplier: 1.3, // More time between rings

    // Progression
    progressionRate: 0,          // No difficulty increase

    // Patterns
    allowedPatterns: ['horizontal_line', 'vertical_line'], // Only straight lines
    patternAmplitudeMultiplier: 1.0,

    // Other
    initialLives: 7              // More forgiving
  },
  normal: {
    // Ring properties
    sizeMultiplier: 1.0,         // Default size
    speedMultiplier: 0.85,       // 15% slower for more reaction time
    spawnIntervalMultiplier: 1.5, // 50% more time between rings

    // Progression
    progressionRate: 1.0,        // Normal progression

    // Patterns
    allowedPatterns: null,       // All patterns (progressive unlock)
    patternAmplitudeMultiplier: 0.55, // Tighter patterns for easier tracking
    excludeRandomPattern: true,  // No harsh cross-map teleports in Normal

    // Other
    initialLives: 5              // Default
  },
  hard: {
    // Ring properties
    sizeMultiplier: 0.7,         // 30% smaller rings
    speedMultiplier: 1.3,        // 30% faster
    spawnIntervalMultiplier: 0.75, // Less time between rings

    // Progression
    progressionRate: 1.5,        // Faster progression

    // Patterns
    allowedPatterns: null,       // All patterns (immediate unlock)
    patternAmplitudeMultiplier: 1.4, // Wider patterns

    // Other
    initialLives: 3              // Less forgiving
  }
};

let currentDifficulty = savedSettings.ringDifficulty ?? 'normal';

// Preload ring resources to prevent lag on first spawn
function preloadRingResources() {
  if (ringResourcesPreloaded) return;

  console.log('[Ring Mode] Preloading resources...');

  // Cache shared geometry (all rings use same torus geometry)
  ringGeometryCache = new THREE.TorusGeometry(INITIAL_RING_SIZE / 2, RING_TUBE_RADIUS, 16, 32);

  // Cache materials for each color
  RING_COLORS.forEach(color => {
    const material = new THREE.MeshStandardMaterial({
      color: color,
      emissive: color,
      emissiveIntensity: 0.8,
      metalness: 0.3,
      roughness: 0.2
    });
    ringMaterialCache.set(color, material);
  });

  // Create a dummy ring offscreen and render it to compile shaders
  const dummyRing = new THREE.Mesh(
    ringGeometryCache,
    ringMaterialCache.get(RING_COLORS[0])
  );
  dummyRing.position.set(0, 0, -5000); // Far offscreen

  // Add point light to compile light shaders too
  const dummyLight = new THREE.PointLight(RING_COLORS[0], 2, 150);
  dummyRing.add(dummyLight);

  scene.add(dummyRing);

  // Render one frame to compile shaders
  renderer.render(scene, camera);

  // Clean up dummy ring
  scene.remove(dummyRing);
  dummyLight.dispose();

  // Preload boost flame geometry/material (compile shaders)
  if (!car) {
    console.warn('[Ring Mode] Car not loaded yet, skipping boost flame preload');
  } else {
    createBoostFlames();
    // Briefly activate to compile shaders
    updateBoostFlames(true, null);
    renderer.render(scene, camera);
    updateBoostFlames(false, null);
  }

  ringResourcesPreloaded = true;
  console.log('[Ring Mode] Resources preloaded successfully!');
}

// Create a ring with neon 80s aesthetic (now uses cached resources)
function createRing(x, y, z, size, speed, spawnIndex) {
  const color = RING_COLORS[currentColorIndex];
  currentColorIndex = (currentColorIndex + 1) % RING_COLORS.length;

  // ALWAYS use cached geometry for performance (prevents lag on spawn)
  // Scale the mesh instead of creating new geometry for different sizes
  const geometry = ringGeometryCache;
  const cachedMaterial = ringMaterialCache.get(color);
  const material = cachedMaterial || new THREE.MeshStandardMaterial({
    color: color,
    emissive: color,
    emissiveIntensity: 0.8,
    metalness: 0.3,
    roughness: 0.2
  });

  const ring = new THREE.Mesh(geometry, material);
  ring.position.set(x, y, z);

  // Scale ring to match requested size (cached geometry is for INITIAL_RING_SIZE)
  const scale = size / INITIAL_RING_SIZE;
  ring.scale.set(scale, scale, scale);

  // Add point light for glow effect
  const light = new THREE.PointLight(color, 2, 150);
  light.position.set(0, 0, 0);
  ring.add(light);

  scene.add(ring);

  return {
    mesh: ring,
    size: size,
    speed: speed,
    passed: false,
    missed: false,
    spawnIndex: spawnIndex // Track when this ring was spawned
  };
}

// Pattern generation variables
let currentPattern = 'random';
let patternProgress = 0; // Progress through current pattern (0-1)
let patternLength = 15; // Number of rings in this pattern
let patternRingCount = 0; // Rings spawned in current pattern
const PATTERN_TYPES = ['sine_horizontal', 'sine_vertical', 'spiral', 'helix', 'figure8', 'vertical_line', 'horizontal_line', 'wave_combo', 'random'];

// Pattern parameters (randomized when pattern changes)
let patternAmplitude = 400; // Wave/spiral amplitude
let patternFrequency = 0.5; // Oscillation frequency
let patternPhase = 0; // Starting phase offset

function selectNewPattern() {
  const settings = DIFFICULTY_SETTINGS[currentDifficulty];

  // Progressive difficulty based on rings completed (affected by difficulty setting)
  const difficultyLevel = Math.floor(ringModeRingCount / 5 * settings.progressionRate); // Increase every 5 rings

  // Use difficulty-specific allowed patterns or progressive unlock
  let availablePatterns = settings.allowedPatterns || PATTERN_TYPES;

  // If no specific pattern restriction, use progressive unlock (Normal/Hard modes)
  if (!settings.allowedPatterns) {
    if (difficultyLevel < 2) {
      // First 10 rings: easier straight/simple patterns
      availablePatterns = ['horizontal_line', 'vertical_line', 'sine_horizontal', 'sine_vertical'];
    } else if (difficultyLevel < 4) {
      // Rings 10-20: introduce more complex patterns
      availablePatterns = ['sine_horizontal', 'sine_vertical', 'wave_combo', 'helix', 'spiral'];
    }
    // After 20 rings: all patterns available

    // Exclude 'random' pattern if difficulty setting requires it (Normal mode)
    if (settings.excludeRandomPattern) {
      availablePatterns = availablePatterns.filter(p => p !== 'random');
    }
  }

  currentPattern = availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
  patternRingCount = 0;
  patternLength = 8 + Math.floor(Math.random() * 12); // 8-20 rings per pattern

  // Progressive amplitude and frequency increase (affected by difficulty)
  const baseAmplitude = (200 + (difficultyLevel * 100)) * settings.patternAmplitudeMultiplier;
  const amplitudeVariance = (200 + (difficultyLevel * 50)) * settings.patternAmplitudeMultiplier;
  patternAmplitude = Math.min(baseAmplitude + Math.random() * amplitudeVariance, RING_GRID_BOUNDS * 0.9);

  const baseFrequency = 0.3 + (difficultyLevel * 0.1); // Faster oscillations as difficulty increases
  patternFrequency = Math.min(baseFrequency + Math.random() * 0.5, 2.0);

  patternPhase = Math.random() * Math.PI * 2;
  console.log(`New pattern: ${currentPattern}, length: ${patternLength}, difficulty: ${difficultyLevel}, amplitude: ${Math.round(patternAmplitude)}`);
}

function getPatternPosition(progress) {
  const t = progress; // 0 to 1 through the pattern
  let x = 0, y = 0;

  switch(currentPattern) {
    case 'sine_horizontal':
      // Horizontal sine wave
      x = Math.sin(t * Math.PI * 2 * patternFrequency + patternPhase) * patternAmplitude;
      y = (Math.random() - 0.5) * 200; // Small random Y variance
      break;

    case 'sine_vertical':
      // Vertical sine wave
      x = (Math.random() - 0.5) * 200;
      y = Math.sin(t * Math.PI * 2 * patternFrequency + patternPhase) * patternAmplitude;
      break;

    case 'spiral':
      // Expanding or contracting spiral
      const spiralRadius = patternAmplitude * (0.3 + t * 0.7);
      const spiralAngle = t * Math.PI * 4 + patternPhase;
      x = Math.cos(spiralAngle) * spiralRadius;
      y = Math.sin(spiralAngle) * spiralRadius;
      break;

    case 'helix':
      // Helix (circular with vertical oscillation)
      const helixAngle = t * Math.PI * 3 + patternPhase;
      x = Math.cos(helixAngle) * patternAmplitude;
      y = Math.sin(t * Math.PI * 2 * patternFrequency) * (patternAmplitude * 0.5);
      break;

    case 'figure8':
      // Figure-8 pattern
      const fig8t = t * Math.PI * 2 + patternPhase;
      x = Math.sin(fig8t) * patternAmplitude;
      y = Math.sin(fig8t * 2) * patternAmplitude * 0.7;
      break;

    case 'vertical_line':
      // Straight vertical line
      x = (Math.random() - 0.5) * 100;
      y = -patternAmplitude + (t * patternAmplitude * 2);
      break;

    case 'horizontal_line':
      // Straight horizontal line
      x = -patternAmplitude + (t * patternAmplitude * 2);
      y = (Math.random() - 0.5) * 100;
      break;

    case 'wave_combo':
      // Combined horizontal and vertical waves
      x = Math.sin(t * Math.PI * 2 * patternFrequency + patternPhase) * patternAmplitude;
      y = Math.cos(t * Math.PI * 2 * patternFrequency * 1.3) * (patternAmplitude * 0.6);
      break;

    case 'random':
    default:
      // Pure random
      x = (Math.random() - 0.5) * RING_GRID_BOUNDS * 0.8;
      y = (Math.random() - 0.5) * RING_GRID_BOUNDS * 0.8;
      break;
  }

  // Distance cap: Limit maximum distance from current player position
  // Max distance = grid radius (center to edge = 1500 units)
  const MAX_RING_DISTANCE = RING_GRID_BOUNDS; // 1500 units (half the total grid width)
  const dx = x - ringModePosition.x;
  const dy = y - ringModePosition.y;
  const distance = Math.sqrt(dx * dx + dy * dy);

  if (distance > MAX_RING_DISTANCE) {
    // Clamp to max distance while preserving direction
    const scale = MAX_RING_DISTANCE / distance;
    x = ringModePosition.x + dx * scale;
    y = ringModePosition.y + dy * scale;
  }

  return { x, y };
}

// Spawn a new ring
function spawnRing() {
  // Check if there's already a ring too close to spawn position
  // Prevent clustering by enforcing minimum Z-distance between rings
  // At base speed (200 u/s) and 3s interval, rings should be ~600 units apart
  const MIN_RING_Z_SPACING = 650; // Minimum units between rings on Z-axis
  const hasCloseRing = rings.some(r => Math.abs(r.mesh.position.z - RING_SPAWN_DISTANCE) < MIN_RING_Z_SPACING);

  if (hasCloseRing) {
    // Skip spawning this ring, try again next interval
    return;
  }

  // Check if we need a new pattern
  if (patternRingCount === 0 || patternRingCount >= patternLength) {
    selectNewPattern();
  }

  // Get position from current pattern
  patternProgress = patternRingCount / patternLength;
  const pos = getPatternPosition(patternProgress);
  const spawnX = pos.x;
  const spawnY = pos.y;
  const spawnZ = RING_SPAWN_DISTANCE;

  patternRingCount++;

  const settings = DIFFICULTY_SETTINGS[currentDifficulty];

  // Calculate progression based on ring count (every 10 rings, affected by difficulty)
  const progressionLevel = Math.floor(ringModeRingCount / 10 * settings.progressionRate);

  // Size: -5% every 10 rings (max 50% reduction), then apply difficulty multiplier
  const sizeReduction = progressionLevel * 0.05;
  const ringSize = INITIAL_RING_SIZE * (1 - Math.min(sizeReduction, 0.5)) * settings.sizeMultiplier;

  // Speed: +5% every 10 rings (max 50% increase), then apply difficulty multiplier
  const speedIncrease = progressionLevel * 0.05;
  let ringSpeed = RING_BASE_SPEED * (1 + Math.min(speedIncrease, 0.5)) * settings.speedMultiplier;

  // Distance-based speed modifier: slow down rings that spawn far away
  const distanceToRing = Math.sqrt(
    (spawnX - ringModePosition.x) ** 2 +
    (spawnY - ringModePosition.y) ** 2
  );
  const MAX_RING_DISTANCE = RING_GRID_BOUNDS; // 1500 units
  const distanceRatio = distanceToRing / MAX_RING_DISTANCE; // 0.0 to 1.0

  // If ring is far away (>50% of max distance), slow it down
  // At max distance (1500 units), speed is reduced by 50%
  if (distanceRatio > 0.5) {
    const slowdownFactor = 1 - ((distanceRatio - 0.5) * 1.0); // 1.0 at 50%, 0.5 at 100%
    ringSpeed *= slowdownFactor;
  }

  const ring = createRing(spawnX, spawnY, spawnZ, ringSize, ringSpeed, ringSpawnIndex++);
  rings.push(ring);
}

// Remove all rings from scene
function clearAllRings() {
  rings.forEach(r => {
    scene.remove(r.mesh);
    // Don't dispose geometry/materials - they're cached and reused!
    // Only dispose if not using cache (fallback case)
    if (r.mesh.geometry !== ringGeometryCache) {
      r.mesh.geometry.dispose();
    }
    if (!ringMaterialCache.has(r.mesh.material.color.getHex())) {
      r.mesh.material.dispose();
    }
  });
  rings = [];
}

// Create boost flame effects
function createBoostFlames() {
  if (!car) return;

  // Create two flame cones for the tailpipes
  const flameGeometry = new THREE.ConeGeometry(16, 60, 8); // 2x bigger (radius: 8->16, height: 30->60)
  const flameMaterial = new THREE.MeshBasicMaterial({
    color: 0xff6600,
    transparent: true,
    opacity: 0.9
  });

  for (let i = 0; i < 2; i++) {
    const flame = new THREE.Mesh(flameGeometry, flameMaterial.clone());
    flame.visible = false;

    // Position in car's local space (at rear of car)
    const offset = (i === 0) ? -12 : 12; // Left and right offset
    flame.position.set(offset, 0, -100); // Local position: left/right, center height, rear

    // Rotate flame cone to point backward/downward (rear of car)
    // X rotation: tip points toward rear
    flame.rotation.set(Math.PI * 0.5, 0, 0); // 90Â° X rotation

    // Add point light for glow
    const light = new THREE.PointLight(0xff6600, 3, 80);
    flame.add(light);

    car.add(flame); // Add as child of car so it moves with the car
    boostFlames.push(flame);
  }
}

// Update boost flame effects
function updateBoostFlames(active, forwardDir) {
  if (boostFlames.length === 0) {
    createBoostFlames();
  }

  if (!car) return;

  boostFlames.forEach((flame, i) => {
    flame.visible = active;

    if (active) {
      // Flames are children of car, so they move automatically with it
      // Just animate the scale and opacity

      // Animate flame size
      const pulse = 0.7 + Math.random() * 0.6;
      flame.scale.set(pulse, pulse * 1.5, pulse);

      // Vary opacity
      flame.material.opacity = 0.7 + Math.random() * 0.3;
    }
  });
}

// Clear boost flames
function clearBoostFlames() {
  boostFlames.forEach(flame => {
    if (flame.parent) flame.parent.remove(flame);
    flame.geometry.dispose();
    flame.material.dispose();
  });
  boostFlames = [];
}

document.getElementById('ringMode').addEventListener('click', () => {
  ringModeActive = !ringModeActive;
  const btn = document.getElementById('ringMode');
  btn.classList.toggle('active', ringModeActive);

  if(ringModeActive){
    // Initialize Ring Mode
    ringModeScore = 0;
    ringModeLives = DIFFICULTY_SETTINGS[currentDifficulty].initialLives;
    ringModeRingCount = 0;
    ringModeVelocity.set(0, 0);
    ringModePosition.set(0, 0);
    ringSpawnTimer = 0;
    ringSpawnIndex = 0; // Reset spawn order tracking
    currentColorIndex = 0;
    ringModeStarted = false; // Reset started state
    ringModePaused = false;  // Reset pause state
    patternRingCount = 0;    // Reset pattern progress
    cameraTargetX = 0; // Reset smooth camera path
    cameraTargetY = 0;
    clearAllRings();

    // Resources already preloaded at startup, just spawn first ring
    spawnRing();

    if (car) {
      car.quaternion.identity();
      car.rotation.set(Math.PI * 1.5, 0, Math.PI); // X: +270Â°, Y: 0Â°, Z: +180Â°
      car.position.set(0, 0, 0); // Lock car to origin in Ring Mode
    }
    w.set(0,0,0);
    orbitOn = false;

    // Start background music when entering Ring Mode
    startBackgroundMusic();
  } else {
    // Exit Ring Mode
    ringModeVelocity.set(0, 0);
    ringModePosition.set(0, 0);
    clearAllRings();
    clearBoostFlames();
    if (car) car.position.set(0, 0, 0);

    // Stop background music when exiting Ring Mode
    stopBackgroundMusic();
    stopBoostRumble(); // Also stop boost rumble
  }
});

const ringCameraSpeedSlider = document.getElementById('ringCameraSpeed');
const ringCameraSpeedVal = document.getElementById('ringCameraSpeedVal');
ringCameraSpeedSlider.addEventListener('input', () => {
  ringCameraSpeed = parseFloat(ringCameraSpeedSlider.value);
  ringCameraSpeedVal.textContent = ringCameraSpeed.toFixed(2);
});

// Ring Mode difficulty selector
const ringDifficultySelector = document.getElementById('ringDifficulty');
ringDifficultySelector.addEventListener('change', () => {
  currentDifficulty = ringDifficultySelector.value;
  saveSettings();
  console.log('Ring Mode difficulty changed to:', currentDifficulty);

  // If Ring Mode is active, restart it with new difficulty
  if (ringModeActive) {
    ringModeScore = 0;
    ringModeLives = DIFFICULTY_SETTINGS[currentDifficulty].initialLives;
    ringModeRingCount = 0;
    ringModeVelocity.set(0, 0);
    ringModePosition.set(0, 0);
    ringSpawnTimer = 0;
    ringSpawnIndex = 0;
    patternRingCount = 0;
    clearAllRings();
    console.log('Ring Mode restarted with new difficulty');
  }
});

// Audio toggles
const toggleSoundsBtn = document.getElementById('toggleSounds');
const soundsStatusTag = document.getElementById('soundsStatus');
const toggleMusicBtn = document.getElementById('toggleMusic');
const musicStatusTag = document.getElementById('musicStatus');

// Set initial button states
toggleSoundsBtn.classList.toggle('active', gameSoundsEnabled);
soundsStatusTag.textContent = gameSoundsEnabled ? 'Enabled' : 'Disabled';
toggleMusicBtn.classList.toggle('active', gameMusicEnabled);
musicStatusTag.textContent = gameMusicEnabled ? 'Enabled' : 'Disabled';

toggleSoundsBtn.addEventListener('click', () => {
  gameSoundsEnabled = !gameSoundsEnabled;
  toggleSoundsBtn.classList.toggle('active', gameSoundsEnabled);
  soundsStatusTag.textContent = gameSoundsEnabled ? 'Enabled' : 'Disabled';

  // Stop boost rumble if sounds are disabled
  if (!gameSoundsEnabled && boostRumbleOscillator) {
    stopBoostRumble();
  }

  saveSettings();
});

toggleMusicBtn.addEventListener('click', () => {
  gameMusicEnabled = !gameMusicEnabled;
  toggleMusicBtn.classList.toggle('active', gameMusicEnabled);
  musicStatusTag.textContent = gameMusicEnabled ? 'Enabled' : 'Disabled';

  // Stop music if disabled
  if (!gameMusicEnabled && musicIntervalId) {
    stopBackgroundMusic();
  } else if (gameMusicEnabled && ringModeActive && ringModeStarted && !musicIntervalId) {
    // Start music if enabled and Ring Mode is active
    startBackgroundMusic();
  }

  saveSettings();
});

document.getElementById('restart').addEventListener('click',()=>{
  if (car) {
    car.quaternion.identity();
    car.rotation.set(Math.PI * 1.5, 0, Math.PI); // X: +270Â°, Y: 0Â°, Z: +180Â°
  }
  w.set(0,0,0);
  orbitOn = false;
  orbitDir = 1;
  document.getElementById('orbitCW').classList.remove('active');
  document.getElementById('orbitCCW').classList.remove('active');
  orbitPhase = 0;
  camera.position.set(0, 220, 650);
  camera.lookAt(0,0,0);
  if (faceArrow) faceArrow.visible = false;
  if (faceTip)   faceTip.visible   = false;

  // Reset Ring Mode if active
  if(ringModeActive){
    ringModeScore = 0;
    ringModeLives = DIFFICULTY_SETTINGS[currentDifficulty].initialLives;
    ringModeRingCount = 0;
  }
});
let orbitOn=false, orbitDir=1;
document.getElementById('orbitCW').addEventListener('click',()=>{
  const btn = document.getElementById('orbitCW');
  if (orbitOn && orbitDir === 1) {
    // Turn off if already orbiting CW
    orbitOn = false;
    btn.classList.remove('active');
  } else {
    // Turn on CW orbit
    orbitOn = true;
    orbitDir = 1;
    btn.classList.add('active');
    document.getElementById('orbitCCW').classList.remove('active');
  }
});
document.getElementById('orbitCCW').addEventListener('click',()=>{
  const btn = document.getElementById('orbitCCW');
  if (orbitOn && orbitDir === -1) {
    // Turn off if already orbiting CCW
    orbitOn = false;
    btn.classList.remove('active');
  } else {
    // Turn on CCW orbit
    orbitOn = true;
    orbitDir = -1;
    btn.classList.add('active');
    document.getElementById('orbitCW').classList.remove('active');
  }
});

/* Theme toggle (main screen button) */
document.getElementById('themeBtn').addEventListener('click',()=>{
  isDarkMode = !isDarkMode;
  applyTheme(isDarkMode);
  const btn = document.getElementById('themeBtn');
  btn.textContent = isDarkMode ? 'ðŸŒ™' : 'â˜€ï¸';
  syncTags(); // Update brightness slider to show correct value for new theme
  saveSettings();
});

// Fullscreen toggle
document.getElementById('fullscreenBtn').addEventListener('click', () => {
  if (!document.fullscreenElement) {
    // Enter fullscreen
    document.documentElement.requestFullscreen().catch(err => {
      console.log(`Error attempting to enable fullscreen: ${err.message}`);
    });
  } else {
    // Exit fullscreen
    if (document.exitFullscreen) {
      document.exitFullscreen();
    }
  }
});

// Update fullscreen button icon when fullscreen state changes
document.addEventListener('fullscreenchange', () => {
  const btn = document.getElementById('fullscreenBtn');
  if (document.fullscreenElement) {
    btn.textContent = 'â›¶'; // Fullscreen exit icon
    btn.title = 'Exit Fullscreen';
  } else {
    btn.textContent = 'â›¶'; // Fullscreen enter icon
    btn.title = 'Enter Fullscreen';
  }
});

// Stop music when page loses focus (tab switching, app backgrounding)
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Page is hidden - stop all audio
    stopBackgroundMusic();
    stopBoostRumble();
  } else {
    // Page is visible again - restart music if Ring Mode is active
    if (ringModeActive && ringModeStarted && gameMusicEnabled) {
      startBackgroundMusic();
    }
  }
});

/* Arrow and Circle toggles */
let showArrow = savedSettings.showArrow ?? true;
let showCircle = savedSettings.showCircle ?? true;

document.getElementById('arrowToggle').addEventListener('click',()=>{
  showArrow = !showArrow;
  const btn = document.getElementById('arrowToggle');
  btn.classList.toggle('active', showArrow);
  btn.textContent = showArrow ? 'Show Arrow' : 'Hide Arrow';
  saveSettings();
});

document.getElementById('circleToggle').addEventListener('click',()=>{
  showCircle = !showCircle;
  const btn = document.getElementById('circleToggle');
  btn.classList.toggle('active', showCircle);
  btn.textContent = showCircle ? 'Show Circle' : 'Hide Circle';
  saveSettings();
});

function syncTags(){
  accelPitchTag.textContent=maxAccelPitch.toFixed(0);
accelYawTag.textContent=maxAccelYaw.toFixed(0);
accelRollTag.textContent=maxAccelRoll.toFixed(0);
  curveTag.textContent=inputPow.toFixed(2);
  dampTag.textContent=damp.toFixed(2);
  brakeTag.textContent=brakeOnRelease.toFixed(1);
  wmaxTag.textContent=wMax.toFixed(1);
  wmaxPitchTag.textContent=wMaxPitch.toFixed(1);
  wmaxYawTag.textContent=wMaxYaw.toFixed(1);
  wmaxRollTag.textContent=wMaxRoll.toFixed(1);
  circleTiltTag.textContent=`${circleTiltAngle.toFixed(0)}Â°`;
  circleTiltModifierTag.textContent=`${circleTiltModifier.toFixed(0)}Â°`;
  circleScaleTag.textContent=`${circleScale.toFixed(2)}Ã—`;
  stickVal.textContent = String(Math.round(JOY_BASE_R));
  zoomVal.textContent = `${(zoom||1).toFixed(2)}Ã—`;
  arrowVal.textContent = `${(arrowScale||1).toFixed(2)}Ã—`;
  const currentBrightness = isDarkMode ? brightnessDark : brightnessLight;
  brightnessVal.textContent = `${currentBrightness.toFixed(2)}Ã—`;
  brightnessSlider.value = currentBrightness;
}
syncTags();

// Make all tag elements editable
function setupEditableTags() {
  const tagMappings = [
    {tag: accelPitchTag, slider: accelPitch, setter: (v) => maxAccelPitch = Math.max(0, Math.min(1200, parseFloat(v) || 400))},
    {tag: accelYawTag, slider: accelYaw, setter: (v) => maxAccelYaw = Math.max(0, Math.min(1200, parseFloat(v) || 400))},
    {tag: accelRollTag, slider: accelRoll, setter: (v) => maxAccelRoll = Math.max(0, Math.min(1200, parseFloat(v) || 400))},
    {tag: curveTag, slider: curveRange, setter: (v) => inputPow = Math.max(1, Math.min(4, parseFloat(v) || 1.0))},
    {tag: dampTag, slider: dampRange, setter: (v) => damp = Math.max(0, Math.min(6, parseFloat(v) || 2.96))},
    {tag: dampDARTag, slider: dampDARRange, setter: (v) => dampDAR = Math.max(0, Math.min(6, parseFloat(v) || 4.35))},
    {tag: brakeTag, slider: brakeRange, setter: (v) => brakeOnRelease = Math.max(0, Math.min(6, parseFloat(v) || 0))},
    {tag: wmaxTag, slider: wmaxRange, setter: (v) => wMax = Math.max(6, Math.min(24, parseFloat(v) || 6))},
    {tag: wmaxPitchTag, slider: wmaxPitchRange, setter: (v) => wMaxPitch = Math.max(6, Math.min(24, parseFloat(v) || 8.5))},
    {tag: wmaxYawTag, slider: wmaxYawRange, setter: (v) => wMaxYaw = Math.max(6, Math.min(24, parseFloat(v) || 9))},
    {tag: wmaxRollTag, slider: wmaxRollRange, setter: (v) => wMaxRoll = Math.max(4, Math.min(24, parseFloat(v) || 6))},
    {tag: circleTiltTag, slider: circleTiltRange, setter: (v) => circleTiltAngle = Math.max(0, Math.min(45, parseFloat(v) || 34))},
    {tag: circleTiltModifierTag, slider: circleTiltModifierRange, setter: (v) => circleTiltModifier = Math.max(-45, Math.min(45, parseFloat(v) || 0))},
    {tag: circleScaleTag, slider: circleScaleRange, setter: (v) => circleScale = Math.max(0.2, Math.min(2.0, parseFloat(v) || 0.3))},
    {tag: zoomVal, slider: zoomSlider, setter: (v) => { zoom = Math.max(0.2, Math.min(4.0, parseFloat(v) || 1)); applyZoom(); }},
    {tag: arrowVal, slider: arrowSlider, setter: (v) => arrowScale = Math.max(0.6, Math.min(4, parseFloat(v) || 4))},
    {tag: brightnessVal, slider: brightnessSlider, setter: (v) => {
      const val = Math.max(0.5, Math.min(3, parseFloat(v) || 1));
      if (isDarkMode) brightnessDark = val; else brightnessLight = val;
      applyTheme(isDarkMode);
    }}
  ];

  tagMappings.forEach(mapping => {
    mapping.tag.contentEditable = true;
    mapping.tag.style.cursor = 'text';

    mapping.tag.addEventListener('click', (e) => {
      e.target.select?.() || document.execCommand('selectAll', false, null);
    });

    mapping.tag.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        e.target.blur();
      }
    });

    mapping.tag.addEventListener('blur', (e) => {
      const rawValue = e.target.textContent.replace(/[^\d.-]/g, '');
      mapping.setter(rawValue);
      mapping.slider.value = parseFloat(rawValue) || 0;
      syncTags();
      saveSettings();
    });
  });
}
setupEditableTags();

accelPitch.addEventListener('input',()=>{maxAccelPitch=parseFloat(accelPitch.value)||400; syncTags(); saveSettings();});
accelYaw.addEventListener('input',()=>{maxAccelYaw=parseFloat(accelYaw.value)||400; syncTags(); saveSettings();});
accelRoll.addEventListener('input',()=>{maxAccelRoll=parseFloat(accelRoll.value)||400; syncTags(); saveSettings();});
curveRange.addEventListener('input',()=>{inputPow=parseFloat(curveRange.value)||1.0; syncTags(); saveSettings();});
dampRange .addEventListener('input',()=>{damp=parseFloat(dampRange.value)||2.96; syncTags(); saveSettings();});
dampDARRange .addEventListener('input',()=>{dampDAR=parseFloat(dampDARRange.value)||4.35; syncTags(); saveSettings();});
brakeRange.addEventListener('input',()=>{brakeOnRelease=parseFloat(brakeRange.value)||0.0; syncTags(); saveSettings();});
wmaxRange .addEventListener('input',()=>{wMax=parseFloat(wmaxRange.value)||6.0; syncTags(); saveSettings();});
wmaxPitchRange.addEventListener('input',()=>{wMaxPitch=parseFloat(wmaxPitchRange.value)||8.5; syncTags(); saveSettings();});
wmaxYawRange.addEventListener('input',()=>{wMaxYaw=parseFloat(wmaxYawRange.value)||9.0; syncTags(); saveSettings();});
wmaxRollRange.addEventListener('input',()=>{wMaxRoll=parseFloat(wmaxRollRange.value)||6.0; syncTags(); saveSettings();});
circleTiltRange.addEventListener('input',()=>{circleTiltAngle=parseFloat(circleTiltRange.value)||38; syncTags(); saveSettings();});
circleTiltModifierRange.addEventListener('input',()=>{circleTiltModifier=parseFloat(circleTiltModifierRange.value)||0; syncTags(); saveSettings();});
circleScaleRange.addEventListener('input',()=>{circleScale=parseFloat(circleScaleRange.value)||0.3; syncTags(); saveSettings();});
sizeSlider.addEventListener('input',()=>{JOY_BASE_R=parseInt(stickSizeSlider.value,10)||100; JOY_KNOB_R=Math.round(JOY_BASE_R*0.32); clampJoyCenter(); positionHints(); syncTags();});
zoomSlider.addEventListener('input',()=>{zoom=parseFloat(zoomSlider.value)||1.0; applyZoom(); syncTags(); saveSettings();});
arrowSlider.addEventListener('input',()=>{arrowScale=parseFloat(arrowSlider.value)||4.0; syncTags(); saveSettings();});
brightnessSlider.addEventListener('input',()=>{
  const val = parseFloat(brightnessSlider.value) || 1.0;
  if (isDarkMode) {
    brightnessDark = val;
  } else {
    brightnessLight = val;
  }
  applyTheme(isDarkMode);
  syncTags();
  saveSettings();
});
presetSel .addEventListener('change',()=>{
  const name = presetSel.value;
  buildCar(presets[name], name);
  car.quaternion.identity();
  car.rotation.set(Math.PI * 1.5, 0, Math.PI); // X: +270Â°, Y: 0Â°, Z: +180Â°
  w.set(0,0,0);
  saveSettings(); // Save selected car body
});

/* Pointer handlers */
hud.addEventListener('pointerdown',(e)=>{
  try{hud.setPointerCapture(e.pointerId);}catch(_){}

  // Track this pointer
  activePointers.set(e.pointerId, {x: e.clientX, y: e.clientY});

  // Check for retry button click on game over screen
  if(ringModeActive && ringModeLives <= 0){
    const retryButtonWidth = 200;
    const retryButtonHeight = 50;
    const retryButtonX = innerWidth / 2 - retryButtonWidth / 2;
    const retryButtonY = innerHeight / 2 + 30;

    if(e.clientX >= retryButtonX && e.clientX <= retryButtonX + retryButtonWidth &&
       e.clientY >= retryButtonY && e.clientY <= retryButtonY + retryButtonHeight){
      resetRingMode();
      e.preventDefault(); return;
    }
  }

  // Multi-touch: assign this pointer to a specific control FIRST (before checking relocation)
  if(showBoostButton && inBoost(e.clientX,e.clientY)){
    boostPointerId = e.pointerId;
    // ringModeBoostActive is now set in updateKeyboardInput() based on boostPointerId
    e.preventDefault(); return;
  }

  // Check for two-finger gesture outside buttons (for boost relocation)
  // IMPORTANT: Only check this AFTER we've checked if user pressed boost button
  if(activePointers.size === 2){
    const pointers = Array.from(activePointers.values());
    const allOutsideButtons = pointers.every(p =>
      (showBoostButton ? !inBoost(p.x, p.y) : true) && !inDAR(p.x, p.y) && !inJoyLoose(p.x, p.y)
    );
    if(allOutsideButtons){
      boostRelocating = true;
      e.preventDefault(); return;
    }
  }

  if(inDAR(e.clientX,e.clientY)){
    darPointerId = e.pointerId;
    darPressT = performance.now();

    // In toggle mode: toggle on press
    if(airRollIsToggle){
      if(airRoll === 0){
        setRoll(lastActiveAirRoll);
      } else {
        setRoll(0);
      }
      darOn = (airRoll !== 0);
    } else {
      // In hold mode: activate immediately on press
      if(airRoll === 0){
        setRoll(lastActiveAirRoll);
      }
      darOn = true;
    }

    clearTimeout(darHoldTimer);
    darHoldTimer = setTimeout(()=>{
      if(darPointerId===e.pointerId){
        darRelocating = true; showHint(darHint, 2000);
      }
    }, RELOCATE_HOLD_MS);
    e.preventDefault(); return;
  }

  if(inJoyLoose(e.clientX,e.clientY)){
    joyPointerId = e.pointerId;
    joyActive=true;
    joyVec = vecFromJoyPx(e.clientX,e.clientY);
    e.preventDefault(); return;
  }

  // If not on any control, set as active for relocation
  if(!chromeShown){
    activeId = e.pointerId;
    clearTimeout(holdTimer);
    holdTimer = setTimeout(()=>{
      if(activeId===e.pointerId && !chromeShown){
        relocating = true; showHint(joyHint, 1800);
      }
    }, RELOCATE_HOLD_MS);
  }
  e.preventDefault();
},{passive:false});
hud.addEventListener('pointermove',(e)=>{
  // Update pointer position in tracking
  if(activePointers.has(e.pointerId)){
    activePointers.set(e.pointerId, {x: e.clientX, y: e.clientY});
  }

  // Handle each pointer independently based on what it's controlling
  if(e.pointerId === joyPointerId && joyActive){
    joyVec = vecFromJoyPx(e.clientX,e.clientY);
    e.preventDefault();
  }

  // DAR relocation uses darPointerId
  if(e.pointerId === darPointerId && darRelocating){
    DAR_CENTER.set(e.clientX,e.clientY);
    clampDARCenter();
    positionHints();
    e.preventDefault();
  }

  // Joystick and boost relocation use activeId
  if(e.pointerId === activeId){
    if(boostRelocating){ BOOST_CENTER.set(e.clientX,e.clientY); clampBoostCenter(); }
    else if(relocating){ JOY_CENTER.set(e.clientX,e.clientY); clampJoyCenter(); positionHints(); }
    e.preventDefault();
  }
},{passive:false});
function endPtr(e){
  // Remove pointer from tracking
  activePointers.delete(e.pointerId);

  // If we were relocating boost and lost a finger, stop relocating
  if(boostRelocating && activePointers.size < 2){
    boostRelocating = false;
  }

  try{hud.releasePointerCapture(e.pointerId);}catch(_){}

  // Handle each pointer release independently
  if(e.pointerId === boostPointerId){
    // ringModeBoostActive is now automatically cleared in updateKeyboardInput() when boostPointerId = null
    boostPointerId = null;
  }

  if(e.pointerId === darPointerId){
    if(!darRelocating && inDAR(e.clientX,e.clientY)){
      const heldMs = performance.now() - darPressT;
      if(heldMs < RELOCATE_HOLD_MS){
        // In toggle mode: nothing to do (already toggled on press)
        // In hold mode: deactivate on release
        if(!airRollIsToggle){
          setRoll(0);
          darOn = false;
        }
      }
    }
    clearTimeout(darHoldTimer);
    darRelocating = false;
    darPointerId = null;
  }

  if(e.pointerId === joyPointerId){
    joyActive = false;
    joyVec.set(0,0);
    joyPointerId = null;
  }

  if(e.pointerId === activeId){
    clearTimeout(holdTimer);
    relocating = false;
    activeId = null;
  }

  e.preventDefault();
}
hud.addEventListener('pointerup',endPtr,{passive:false});
hud.addEventListener('pointercancel',endPtr,{passive:false});

/* ====== GAMEPAD SUPPORT (PS5 / Generic, remappable) ====== */
const gpEnableBtn = document.getElementById('gpEnable');
const gpStatusTag = document.getElementById('gpStatus');
const gpPresetSel = document.getElementById('gpPreset');
const gpActionSel = document.getElementById('gpAction');
const gpRemapBtn  = document.getElementById('gpRemap');
const gpBindLabel = document.getElementById('gpBindLabel');

// Gamepad state variables (gpEnabled and gpBindings initialized earlier)
let gpIndex   = -1;
let gpRemapping = false;
let gpRemapReady = false;  // true when all buttons/axes are released and ready to capture
let gpPrevActionPressed = {};
const GP_DEADZONE = 0.15;

const defaultGpBindings = {
  toggleDAR:   { kind:'button', index: 1 },
  rollLeft:    { kind:'button', index: 4 },
  rollRight:   { kind:'button', index: 5 },
  rollFree:    { kind:'button', index: 7 },
  boost:       { kind:'button', index: 0 },
  pause:       { kind:'button', index: 9 },  // Options/Start button
  restart:     { kind:'button', index: 10 }, // Moved from 9
  orbitCW:     { kind:'button', index: 2 },
  orbitCCW:    { kind:'button', index: 3 },
  toggleTheme: { kind:'button', index: 8 },
  openMenu:    { kind:'button', index: 6 }
};

// Set default bindings if not loaded from savedSettings
if (!gpBindings) {
  gpBindings = defaultGpBindings;
}
console.log('Loaded gamepad bindings:', gpBindings);

// Restore gamepad preset selection
if (savedSettings.gpPreset) {
  gpPresetSel.value = savedSettings.gpPreset;
  console.log('Restored preset:', savedSettings.gpPreset);
}

const GP_PRESETS = {
  ps5: {
    toggleDAR:   { kind:'button', index: 0 },  // Cross (X)
    rollLeft:    { kind:'button', index: 2 },  // Square
    rollRight:   { kind:'button', index: 1 },  // Circle
    rollFree:    { kind:'button', index: 4 },  // L1
    boost:       { kind:'button', index: 5 },  // R1
    pause:       { kind:'button', index: 12 }, // D-pad Up
    restart:     { kind:'button', index: 13 }, // D-pad Down
    orbitCW:     { kind:'button', index: 15 }, // D-pad Right
    orbitCCW:    { kind:'button', index: 14 }, // D-pad Left
    toggleTheme: { kind:'button', index: 8 },  // Share/Select
    openMenu:    { kind:'button', index: 9 }   // Options/Start
  },
  xinput: {
    toggleDAR:   { kind:'button', index: 1 },  // B
    rollLeft:    { kind:'button', index: 4 },  // LB
    rollRight:   { kind:'button', index: 5 },  // RB
    rollFree:    { kind:'button', index: 7 },  // RT
    boost:       { kind:'button', index: 0 },  // A
    pause:       { kind:'button', index: 9 },  // Start
    restart:     { kind:'button', index: 10 }, // Xbox button
    orbitCW:     { kind:'button', index: 2 },  // X
    orbitCCW:    { kind:'button', index: 3 },  // Y
    toggleTheme: { kind:'button', index: 8 },  // Back
    openMenu:    { kind:'button', index: 6 }   // LT
  }
};

function bindingToLabel(b){
  if(!b) return 'â€”';
  if(b.kind==='button') return `Button ${b.index}`;
  const d = b.dir>0 ? '+' : 'âˆ’';
  return `Axis ${b.axis}${d}`;
}
function setBindingPreset(name){
  // Apply preset without confirmation
  const p = GP_PRESETS[name] || GP_PRESETS.ps5;
  gpBindings = JSON.parse(JSON.stringify(p));
  updateBindLabel();
  saveSettings();
}
function updateBindLabel(){
  const act = gpActionSel.value;
  gpBindLabel.textContent = bindingToLabel(gpBindings[act]);
}

gpEnableBtn.addEventListener('click',()=>{
  gpEnabled = !gpEnabled;
  gpEnableBtn.classList.toggle('active', gpEnabled);
  gpStatusTag.textContent = gpEnabled ? 'Enabled' : 'Disabled';
  saveSettings();
});
gpPresetSel.addEventListener('change', ()=> setBindingPreset(gpPresetSel.value));
gpActionSel.addEventListener('change', updateBindLabel);
gpRemapBtn.addEventListener('click',()=>{
  gpRemapping = true;
  gpBindLabel.textContent = 'Press button / move axisâ€¦';
});
document.getElementById('gpResetDefaults').addEventListener('click',()=>{
  setBindingPreset(gpPresetSel.value);
  gpStatusTag.textContent = 'Bindings reset to defaults';
  setTimeout(() => {
    const { pad } = readPads();
    if (pad) gpStatusTag.textContent = `Connected: ${pad.id}`;
    else gpStatusTag.textContent = gpEnabled ? 'Enabled (waiting for gamepad)' : 'No gamepad';
  }, 2000);
});

// Only set default preset if no saved bindings exist (don't reset user's custom bindings!)
if (!savedSettings.gpBindings) {
  setBindingPreset('ps5');
}
updateBindLabel();

addEventListener('gamepadconnected', (e)=>{
  if(gpIndex<0){ gpIndex = e.gamepad.index; }
  gpStatusTag.textContent = `Connected: ${e.gamepad.id}`;
});
addEventListener('gamepaddisconnected', (e)=>{
  if(e.gamepad.index===gpIndex){ gpIndex=-1; }
  gpStatusTag.textContent = gpEnabled ? 'Enabled (waiting for gamepad)' : 'No gamepad';
});

function readPads(){
  const arr = (navigator.getGamepads?.() || []);
  if(gpIndex<0){
    for(let i=0;i<arr.length;i++){
      const p = arr[i];
      if(p && p.mapping==='standard'){ gpIndex=i; break; }
    }
  }
  return { pad: (gpIndex>=0 ? arr[gpIndex] : null), all: arr };
}

function isPressedForBinding(pad, binding){
  if(!binding || !pad) return false;
  if(binding.kind==='button'){
    const b = pad.buttons[binding.index];
    return !!(b && (b.value||0) > 0.5);
  }
  if(binding.kind==='axis'){
    const v = pad.axes[binding.axis] || 0;
    return binding.dir>0 ? (v>0.6) : (v<-0.6);
  }
  return false;
}

function execBinding(action){
  switch(action){
    case 'toggleDAR':
      // Toggle the currently selected air roll on/off
      if(airRoll === 0){
        // If no air roll active, activate the last active one
        setRoll(lastActiveAirRoll);
      } else {
        // If air roll active, deactivate it
        setRoll(0);
      }
      darOn = (airRoll !== 0); // Update darOn to match air roll state
      break;
    case 'rollLeft':
      toggleRoll(-1);
      break;
    case 'rollRight':
      toggleRoll(+1);
      break;
    case 'rollFree':
      toggleRoll(2);
      break;
    case 'restart': {
      if (car) {
        car.quaternion.identity();
        car.rotation.set(Math.PI * 1.5, 0, Math.PI); // X: +270Â°, Y: 0Â°, Z: +180Â°
      }
      w.set(0,0,0);
      orbitOn = false;
      orbitDir = 1;
      document.getElementById('orbitCW').classList.remove('active');
      document.getElementById('orbitCCW').classList.remove('active');
      orbitPhase = 0;
      camera.position.set(0, 220, 650);
      camera.lookAt(0,0,0);
      if (faceArrow) faceArrow.visible = false;
      if (faceTip)   faceTip.visible   = false;

      // Reset Ring Mode if active
      if (ringModeActive) {
        ringModeVelocity.set(0, 0);
        ringModePosition.set(0, 0);
        ringModeScore = 0;
        ringModeLives = DIFFICULTY_SETTINGS[currentDifficulty].initialLives;
        ringModeRingCount = 0;
        ringModeStarted = false;
        ringSpawnIndex = 0; // Reset spawn order tracking
        clearAllRings();
        console.log('Ring Mode restarted');
      }
      break;
    }
    case 'orbitToggle':
      orbitOn = !orbitOn;
      orbitDir = orbitOn ? 1 : 1;
      if (orbitOn) {
        document.getElementById('orbitCW').classList.add('active');
        document.getElementById('orbitCCW').classList.remove('active');
      } else {
        document.getElementById('orbitCW').classList.remove('active');
        document.getElementById('orbitCCW').classList.remove('active');
      }
      break;
    case 'orbitCW':
      // Toggle orbit CW
      if (orbitOn && orbitDir === 1) {
        orbitOn = false;
        document.getElementById('orbitCW').classList.remove('active');
      } else {
        orbitOn = true;
        orbitDir = 1;
        document.getElementById('orbitCW').classList.add('active');
        document.getElementById('orbitCCW').classList.remove('active');
      }
      break;
    case 'orbitCCW':
      // Toggle orbit CCW
      if (orbitOn && orbitDir === -1) {
        orbitOn = false;
        document.getElementById('orbitCCW').classList.remove('active');
      } else {
        orbitOn = true;
        orbitDir = -1;
        document.getElementById('orbitCCW').classList.add('active');
        document.getElementById('orbitCW').classList.remove('active');
      }
      break;
    case 'toggleTheme':
      isDarkMode = !isDarkMode;
      applyTheme(isDarkMode);
      const themeBtn = document.getElementById('themeBtn');
      themeBtn.textContent = isDarkMode ? 'ðŸŒ™' : 'â˜€ï¸';
      syncTags();
      saveSettings();
      break;
    case 'pause':
      if (ringModeActive) {
        ringModePaused = !ringModePaused;
        if (ringModePaused) {
          openMenu(); // Open menu when paused
        }
      }
      break;
    case 'openMenu':
      if (chromeShown) closeMenu();
      else openMenu();
      break;
    default: break;
  }
}

function handleRemap(pad){
  if(!gpRemapping || !pad) return;

  // First, wait for all buttons and axes to be released
  if(!gpRemapReady){
    let allReleased = true;

    // Check if any button is pressed
    for(let i=0; i<pad.buttons.length; i++){
      if(pad.buttons[i] && (pad.buttons[i].value||0) > 0.5){
        allReleased = false;
        break;
      }
    }

    // Check if any axis is deflected
    if(allReleased){
      for(let a=0; a<pad.axes.length; a++){
        const v = pad.axes[a] || 0;
        if(Math.abs(v) > 0.6){
          allReleased = false;
          break;
        }
      }
    }

    if(allReleased){
      gpRemapReady = true;
      gpBindLabel.textContent = 'Ready! Press button / move axisâ€¦';
    }
    return;
  }

  // Now we're ready to capture the new binding
  for(let i=0;i<pad.buttons.length;i++){
    if(pad.buttons[i] && (pad.buttons[i].value||0) > 0.5){
      const action = gpActionSel.value;
      gpBindings[action] = { kind:'button', index:i };
      console.log(`Remapped ${action} to button ${i}`);
      console.log('Current gpBindings:', JSON.parse(JSON.stringify(gpBindings)));
      gpRemapping = false;
      gpRemapReady = false;
      updateBindLabel();
      saveSettings();
      console.log('saveSettings() called after remapping');
      return;
    }
  }
  for(let a=0;a<pad.axes.length;a++){
    const v = pad.axes[a] || 0;
    if(Math.abs(v) > 0.6){
      const action = gpActionSel.value;
      gpBindings[action] = { kind:'axis', axis:a, dir: (v>0? +1 : -1) };
      console.log(`Remapped ${action} to axis ${a} dir ${v>0?'+':'-'}`);
      console.log('Current gpBindings:', JSON.parse(JSON.stringify(gpBindings)));
      gpRemapping = false;
      gpRemapReady = false;
      updateBindLabel();
      saveSettings();
      console.log('saveSettings() called after remapping');
      return;
    }
  }
}

// Helper: Check if gamepad is currently pressing any air roll buttons
function isGamepadPressingAirRoll(){
  if(!gpEnabled) return false;
  const { pad } = readPads();
  if(!pad) return false;

  // Check if any air roll bindings are currently pressed
  if(gpBindings.rollLeft && isPressedForBinding(pad, gpBindings.rollLeft)) return true;
  if(gpBindings.rollRight && isPressedForBinding(pad, gpBindings.rollRight)) return true;
  if(gpBindings.rollFree && isPressedForBinding(pad, gpBindings.rollFree)) return true;

  return false;
}

function updateKeyboardInput(){
  // Keyboard controls: W/A/S/D = movement, Q/E = air roll, Shift = free roll, Space = boost
  // I = menu toggle, Esc = pause (Ring Mode only)

  // Handle menu toggle (I key) - must be before early return
  if(keyJustPressed('KeyI')){
    if(chromeShown){
      closeMenu();
    } else {
      openMenu();
    }
  }

  // Update previous key state for next frame (MUST be done every frame!)
  keyState.forEach((value, key) => {
    keyPrevState.set(key, value);
  });

  // If menu is open, don't process game input
  if(chromeShown) return;

  // Handle pause (Esc key - Ring Mode only)
  if(keyJustPressed('Escape') && ringModeActive){
    ringModePaused = !ringModePaused;
    console.log('Ring Mode paused:', ringModePaused);
  }

  // Movement (WASD) - only when not dragging joystick manually
  if(!joyActive && !relocating && !darRelocating){
    let kx = 0, ky = 0;

    if(keyHeld('KeyW')) ky -= 1; // Up
    if(keyHeld('KeyS')) ky += 1; // Down
    if(keyHeld('KeyA')) kx -= 1; // Left
    if(keyHeld('KeyD')) kx += 1; // Right

    // Normalize diagonal movement
    const mag = Math.hypot(kx, ky);
    if(mag > 0){
      kx /= mag;
      ky /= mag;
      joyVec.set(kx * JOY_BASE_R, ky * JOY_BASE_R);
    } else if(!gpEnabled || !readPads().pad){
      // Only clear joystick if no gamepad input either
      joyVec.set(0, 0);
    }
  }

  // Keyboard air roll handling depends on mode
  if(airRollIsToggle){
    // Toggle mode: toggle on key press (edge detection)
    if(keyJustPressed('KeyQ')){
      toggleRoll(-1);
    }
    if(keyJustPressed('KeyE')){
      toggleRoll(1);
    }
    if(keyJustPressed('ShiftLeft') || keyJustPressed('ShiftRight')){
      toggleRoll(2);
    }
  } else {
    // Hold mode: keyboard activates while held, deactivates when released
    const gpControllingAirRoll = isGamepadPressingAirRoll();
    const darButtonPressed = (darPointerId !== null);

    // Air Roll Left (Q)
    if(keyHeld('KeyQ')){
      if(airRoll !== -1) setRoll(-1);
    } else if(!keyHeld('KeyE') && !keyHeld('ShiftLeft') && !keyHeld('ShiftRight') && !gpControllingAirRoll && !darButtonPressed){
      // Only release if no other air roll keys are held AND gamepad/DAR button isn't controlling it
      if(airRoll === -1) setRoll(0);
    }

    // Air Roll Right (E)
    if(keyHeld('KeyE')){
      if(airRoll !== 1) setRoll(1);
    } else if(!keyHeld('KeyQ') && !keyHeld('ShiftLeft') && !keyHeld('ShiftRight') && !gpControllingAirRoll && !darButtonPressed){
      if(airRoll === 1) setRoll(0);
    }

    // Air Roll Free (Shift)
    if(keyHeld('ShiftLeft') || keyHeld('ShiftRight')){
      if(airRoll !== 2) setRoll(2);
    } else if(!keyHeld('KeyQ') && !keyHeld('KeyE') && !gpControllingAirRoll && !darButtonPressed){
      if(airRoll === 2) setRoll(0);
    }
  }

  // Boost (Space) - for Ring Mode
  // Combine keyboard and touch input (touch is handled separately in pointerdown/up)
  const keyboardBoost = keyHeld('Space');
  const touchBoost = (boostPointerId !== null); // If pointer assigned to boost, it's being held
  ringModeBoostActive = keyboardBoost || touchBoost;
}

function updateGamepadInput(){
  if(!gpEnabled) return;
  const { pad } = readPads();
  if(!pad){
    gpStatusTag.textContent = 'Enabled (waiting for gamepad)';
    return;
  }
  gpStatusTag.textContent = `Connected: ${pad.id}`;

  // If remapping, ONLY handle remapping - block everything else
  if(gpRemapping){
    handleRemap(pad);
    return; // Don't process any other input while remapping
  }

  // Handle menu navigation when menu is open (but not while remapping)
  if(chromeShown && menuFocusableElements.length > 0){
    const currentTime = Date.now();

    // D-pad and left stick navigation
    const dpadUp = pad.buttons[12]?.pressed || false;
    const dpadDown = pad.buttons[13]?.pressed || false;
    const dpadLeft = pad.buttons[14]?.pressed || false;
    const dpadRight = pad.buttons[15]?.pressed || false;

    const lx = pad.axes[0] || 0;
    const ly = pad.axes[1] || 0;
    const stickUp = ly < -0.5;
    const stickDown = ly > 0.5;
    const stickLeft = lx < -0.5;
    const stickRight = lx > 0.5;

    const focusedEl = menuFocusableElements[menuFocusIndex];

    // Check if enough time has passed since last navigation
    if(currentTime - menuNavigationCooldown >= MENU_NAV_COOLDOWN){
      const isSlider = focusedEl && focusedEl.tagName === 'INPUT' && focusedEl.type === 'range';
      const isSelect = focusedEl && focusedEl.tagName === 'SELECT';

      // Handle UP/DOWN navigation (always navigates, never adjusts values)
      if(dpadUp || stickUp){
        const newIndex = findClosestElementInDirection('up');
        focusMenuElement(newIndex);
        menuNavigationCooldown = currentTime;
      } else if(dpadDown || stickDown){
        const newIndex = findClosestElementInDirection('down');
        focusMenuElement(newIndex);
        menuNavigationCooldown = currentTime;
      } else if(dpadLeft || stickLeft){
        // Left: adjust slider/select if focused on one, otherwise navigate
        if(isSlider){
          adjustSliderValue(-1);
        } else if(isSelect){
          adjustSelectValue(-1);
        } else {
          const newIndex = findClosestElementInDirection('left');
          focusMenuElement(newIndex);
        }
        menuNavigationCooldown = currentTime;
      } else if(dpadRight || stickRight){
        // Right: adjust slider/select if focused on one, otherwise navigate
        if(isSlider){
          adjustSliderValue(1);
        } else if(isSelect){
          adjustSelectValue(1);
        } else {
          const newIndex = findClosestElementInDirection('right');
          focusMenuElement(newIndex);
        }
        menuNavigationCooldown = currentTime;
      }
    }

    // X button (Cross) to activate/select (button 0)
    const xPressed = pad.buttons[0]?.pressed || false;
    const xWasPressed = !!gpPrevActionPressed['menu_x'];
    if(xPressed && !xWasPressed){
      activateMenuElement();
    }
    gpPrevActionPressed['menu_x'] = xPressed;

    // Circle button to close menu (button 1)
    const circlePressed = pad.buttons[1]?.pressed || false;
    const circleWasPressed = !!gpPrevActionPressed['menu_circle'];
    if(circlePressed && !circleWasPressed){
      closeMenu();
    }
    gpPrevActionPressed['menu_circle'] = circlePressed;

    // Check for openMenu binding to allow closing menu with it
    if(gpBindings.openMenu){
      const openMenuPressed = isPressedForBinding(pad, gpBindings.openMenu);
      const openMenuWasPressed = !!gpPrevActionPressed['openMenu'];
      if(openMenuPressed && !openMenuWasPressed){
        closeMenu();
      }
      gpPrevActionPressed['openMenu'] = openMenuPressed;
    }

    // Don't process normal game input when menu is open
    return;
  }

  // Left stick â†’ on-screen stick (natural Y: up=up)
  if(!joyActive && !relocating && !darRelocating){
    const lx = pad.axes[0] || 0;
    const ly = pad.axes[1] || 0;
    const mag = Math.hypot(lx, ly);
    let nx = 0, ny = 0;
    if(mag > GP_DEADZONE){
      const k = (mag - GP_DEADZONE) / (1 - GP_DEADZONE);
      nx = (lx / (mag||1)) * k;
      ny = (ly / (mag||1)) * k;
    }
    joyVec.set(nx * JOY_BASE_R, ny * JOY_BASE_R);
  }

  // Check boost button state (hold-based, not toggle)
  if(gpBindings.boost){
    ringModeBoostActive = isPressedForBinding(pad, gpBindings.boost);
  }

  // Fire actions on rising edge (or handle hold mode for air rolls)
  for(const action of Object.keys(gpBindings)){
    const nowPressed = isPressedForBinding(pad, gpBindings[action]);
    const wasPressed = !!gpPrevActionPressed[action];

    // Boost is handled separately (hold-based)
    if(action === 'boost'){
      gpPrevActionPressed[action] = nowPressed;
      continue;
    }

    // Air roll buttons have special hold/toggle behavior
    const isAirRollAction = (action === 'rollLeft' || action === 'rollRight' || action === 'rollFree');

    if(isAirRollAction && !airRollIsToggle){
      // Hold mode: activate on press, deactivate on release
      if(nowPressed && !wasPressed){
        // Just pressed - activate this air roll
        const dir = action === 'rollLeft' ? -1 : action === 'rollRight' ? 1 : 2;
        setRoll(dir);
      } else if(!nowPressed && wasPressed && darPointerId === null){
        // Just released - deactivate if this was the active one
        // BUT don't deactivate if DAR button is currently being held
        const dir = action === 'rollLeft' ? -1 : action === 'rollRight' ? 1 : 2;
        if(airRoll === dir){
          setRoll(0);
        }
      }
    } else {
      // Normal toggle behavior for air rolls in toggle mode, or all other actions
      if(nowPressed && !wasPressed){ execBinding(action); }
    }

    gpPrevActionPressed[action] = nowPressed;
  }
}

/* Physics (independent caps for Pitch/Yaw) */
let w = new THREE.Vector3(0,0,0);
const STICK_DEADZONE = STICK_MIN;
const KP_ROLL = 3.2, KD_ROLL = 0.25;

// === NEW VARIABLES - Add these here ===
let inputHistory = { x: [], y: [] };
const INPUT_HISTORY_SIZE = 3;
let prevAlpha = new THREE.Vector3(0, 0, 0);

// === HELPER FUNCTIONS ===
function smoothInput(jx, jy) {
  inputHistory.x.push(jx);
  inputHistory.y.push(jy);
  if (inputHistory.x.length > INPUT_HISTORY_SIZE) {
    inputHistory.x.shift();
    inputHistory.y.shift();
  }
  
  const avgX = inputHistory.x.reduce((a, b) => a + b, 0) / inputHistory.x.length;
  const avgY = inputHistory.y.reduce((a, b) => a + b, 0) / inputHistory.y.length;
  return { x: avgX, y: avgY };
}

function softClampAngularVelocity(w, max) {
  const mag = w.length();
  if (mag <= max) return;
  
  const excess = mag - max;
  const reduction = Math.min(1.0, excess / max);
  const scale = 1.0 - (reduction * 0.3);
  w.multiplyScalar(scale);
}

// Put these near your other physics constants:
// Increased from 18.0 to 36.0 for much more responsive air control in Ring Mode (DAR)
const KpPitch = 36.0, KdPitch = 4.0;
const KpYaw   = 36.0, KdYaw   = 4.0;
const KpRoll  = 12.0, KdRoll  = 3.0;

function integrate(dt) {
  // Skip physics when menu is open
  if (chromeShown) {
    return;
  }

  // --- 1. Smooth joystick position ---
  const a = 1 - Math.exp(-(dt * 1000) / Math.max(1, STICK_TAU_MS));
  smJoy.lerp(joyVec, a);

  const jx = smJoy.x / JOY_BASE_R;
  const jy = -smJoy.y / JOY_BASE_R; // up is positive
  let mag = Math.hypot(jx, jy);

  let eff = 0;
  let ux = 0, uy = 0;

  if (mag > STICK_DEADZONE) {
    const m2 = (mag - STICK_DEADZONE) / (1 - STICK_DEADZONE);
    const shaped = Math.pow(Math.max(0, m2), inputPow || 1.0); // 0..1
    eff = shaped;

    ux = -jx / (mag || 1); // right = +ux
    uy = jy  / (mag || 1); // up = +uy
  }

  // === RING MODE: Calculate movement forces (normal rotation physics will run below) ===
  if (ringModeActive && !ringModePaused && ringModeLives > 0) {
    // Get car's forward direction from quaternion
    const forward = new THREE.Vector3(0, 0, 1); // Car's local forward (flipped from -1 to 1)
    forward.applyQuaternion(car.quaternion);

    // Project onto XY plane for 2D movement
    const boostDirX = forward.x;
    const boostDirY = forward.y;

    // Track if game has started (first boost press)
    if (ringModeBoostActive && !ringModeStarted) {
      ringModeStarted = true;
    }

    // Boost rumble sound control
    if (ringModeBoostActive && !boostRumbleOscillator) {
      startBoostRumble();
    } else if (!ringModeBoostActive && boostRumbleOscillator) {
      stopBoostRumble();
    }

    // Apply forces
    let accelX = 0;
    let accelY = ringModeStarted ? RING_GRAVITY : 0; // Only apply gravity after first boost

    if (ringModeBoostActive) {
      // Boost in the direction car's nose is facing
      accelX += boostDirX * RING_BOOST_ACCEL;
      accelY += boostDirY * RING_BOOST_ACCEL;
    }

    // Update boost flame visibility and position
    updateBoostFlames(ringModeBoostActive, forward);

    // Integrate velocity
    ringModeVelocity.x += accelX * dt;
    ringModeVelocity.y += accelY * dt;

    // Clamp to max speed
    const speed = ringModeVelocity.length();
    if (speed > RING_MAX_SPEED) {
      ringModeVelocity.multiplyScalar(RING_MAX_SPEED / speed);
    }

    // Integrate position
    ringModePosition.x += ringModeVelocity.x * dt;
    ringModePosition.y += ringModeVelocity.y * dt;

    // Clamp to bounds
    ringModePosition.x = THREE.MathUtils.clamp(ringModePosition.x, -RING_GRID_BOUNDS, RING_GRID_BOUNDS);
    ringModePosition.y = THREE.MathUtils.clamp(ringModePosition.y, -RING_GRID_BOUNDS, RING_GRID_BOUNDS);

    // Check out of bounds (player went too far)
    if (Math.abs(ringModePosition.x) >= RING_GRID_BOUNDS ||
        Math.abs(ringModePosition.y) >= RING_GRID_BOUNDS) {
      // Out of bounds - respawn at next ring position
      ringModeVelocity.set(0, 0);

      // Find next unpassed ring to respawn at
      const nextRing = rings.find(r => !r.passed && !r.missed);
      if (nextRing) {
        // Respawn at the ring's X/Y position
        ringModePosition.set(nextRing.mesh.position.x, nextRing.mesh.position.y);
      } else {
        // No rings available, respawn at center
        ringModePosition.set(0, 0);
      }

      ringModeStarted = false; // Wait for boost before falling
      ringModeLives--; // Lose a life
      console.log('Out of bounds! Lives:', ringModeLives);
    }

    // Continue to normal physics for rotation!
  }

  // --- 2. Front-face arrow (same behavior as before, just using ux,uy,eff) ---
  if (faceArrow && faceTip) {
    const show = showArrow && eff > 0.02;
    faceArrow.visible = show;
    faceTip.visible   = show;

    if (show) {
      const lenMax = Math.min(BOX.hx, BOX.hy) * 0.95;
      const len    = Math.max(10, lenMax * eff * (arrowScale || 1));
      const zFace  = BOX.hz + 0.6;

      const x2 = ux * len;
      const y2 = -uy * len;

      const pos = faceArrow.geometry.attributes.position.array;
      pos[0] = 0;  pos[1] = 0;  pos[2] = zFace;
      pos[3] = x2; pos[4] = y2; pos[5] = zFace;
      faceArrow.geometry.attributes.position.needsUpdate = true;

      const col = (Math.abs(x2) > Math.abs(y2))
        ? (x2 >= 0 ? COL_LEFT : COL_RIGHT)
        : (uy >= 0 ? COL_DOWN : COL_UP);
      faceArrow.material.color.setHex(col);
      faceTip.material.color.setHex(col);

      faceTip.position.set(x2, y2, zFace);
      const ang = Math.atan2(x2, -y2) + Math.PI;
      faceTip.rotation.set(0, 0, ang);
      const s = 0.95 * (arrowScale || 1);
      faceTip.scale.set(s, s, 1);
    }
  }

  // --- 2b. Tornado circle visualizer (shows DAR cone path) ---
  if (tornadoCircle) {
    // Circle only shows for Air Roll Left/Right (not Free), when DAR is active
    const isDAR = (airRoll === -1 || airRoll === 1);
    const shouldShowCircle = showCircle && isDAR && darOn && eff > 0.02;
    tornadoCircle.visible = shouldShowCircle;

    if (shouldShowCircle) {
      const zFace = BOX.hz + 0.6;

      // Calculate circle radius based on stick input
      const baseRadius = Math.min(BOX.hx, BOX.hy) * 0.95;
      const arrowLength = baseRadius * eff * (arrowScale || 1);

      // Circle scale controlled by circleScale slider
      const circleRadius = arrowLength * (circleScale || 0.3);

      // The circle should be offset perpendicular to the arrow direction
      // Air Roll Left (airRoll = -1): offset +90 degrees (counter-clockwise)
      // Air Roll Right (airRoll = +1): offset -90 degrees (clockwise)
      const arrowAngle = Math.atan2(ux, uy); // angle of the arrow in XY plane
      const perpAngle = arrowAngle + (airRoll * Math.PI / 2); // offset 90 degrees based on roll direction

      // Position circle center perpendicular to arrow, distance = circle radius
      const centerX = Math.sin(perpAngle) * circleRadius;
      const centerY = -Math.cos(perpAngle) * circleRadius;

      tornadoCircle.scale.set(circleRadius, circleRadius, 1);
      tornadoCircle.position.set(centerX, centerY, zFace);

      // Update circle color based on stick direction (same as arrow)
      const col = (Math.abs(ux) > Math.abs(uy))
        ? (ux >= 0 ? COL_LEFT : COL_RIGHT)
        : (uy >= 0 ? COL_DOWN : COL_UP);
      tornadoCircle.material.color.setHex(col);

      // Apply tilt rotation toward the car
      // Calculate modifier strength: 0 at stable points (every 45Â°), 1.0 at unstable points (between 45Â° marks)
      // Stable points: 0Â°, 45Â°, 90Â°, 135Â°, 180Â°, 225Â°, 270Â°, 315Â°
      // Using sin(4x) to create 8 peaks per rotation (frequency = 4)
      const arrowAngleDeg = (arrowAngle * 180 / Math.PI + 360) % 360;
      const modifierStrength = Math.abs(Math.sin(4 * arrowAngle)); // 0 at stable, 1 at unstable

      // Apply base tilt + modifier
      const totalTilt = circleTiltAngle + (circleTiltModifier * modifierStrength);
      const tiltRad = (totalTilt * Math.PI) / 180;

      // Reset rotation first
      tornadoCircle.rotation.set(0, 0, 0);

      // Rotate around the axis perpendicular to the arrow (makes circle tilt toward car)
      // Negative tiltRad to tilt toward car instead of away
      tornadoCircle.rotateOnAxis(
        new THREE.Vector3(-Math.cos(perpAngle), -Math.sin(perpAngle), 0).normalize(),
        -tiltRad
      );
    }
  }

  // --- 3. Slider conversions (deg/sÂ² â†’ rad/sÂ²) ---
  let maxAccelPitchRad = (maxAccelPitch * Math.PI) / 180;
  let maxAccelYawRad   = (maxAccelYaw   * Math.PI) / 180;
  let maxAccelRollRad  = (maxAccelRoll  * Math.PI) / 180;

  // --- 3.5. DAR acceleration multipliers (from RL measurements) ---
  if (darOn) {
    maxAccelPitchRad *= 0.997;  // DAR: 714â†’712 deg/sÂ²
    maxAccelYawRad *= 1.00;      // DAR: 521â†’522 deg/sÂ² (no change)
    maxAccelRollRad *= 0.98;     // DAR: 2153â†’2110 deg/sÂ²
  }

  // --- 4. Desired angular velocities (rate control) ---
  let maxPitchSpeed = wMaxPitch;  // rad/s, slider already in "Ï‰"
  let maxYawSpeed   = wMaxYaw;    // rad/s
  let targetRollSpeed = 0;        // rad/s

  // Check if using Air Roll (Free) mode
  const isAirRollFree = (airRoll === 2);

  // DAR tornado spin (measured from Rocket League)
  if (darOn && !isAirRollFree) {
    // RL tornado spin: 0.74 seconds per rotation
    const RL_TORNADO_PERIOD = 0.74;  // seconds
    targetRollSpeed = airRoll * (2 * Math.PI) / RL_TORNADO_PERIOD;  // airRoll = Â±1 for Left/Right
  }

  // stick â†’ desired spin rates
  let wx_des, wy_des, wz_des;

  if (isAirRollFree) {
    // Air Roll (Free): horizontal stick controls roll, vertical controls pitch
    wx_des = maxPitchSpeed * eff * uy; // pitch (up/down)
    wy_des = 0;                         // no yaw
    wz_des = wMaxRoll * eff * (-ux);   // roll (left stick = roll left, right stick = roll right)
  } else {
    // Normal or Air Roll Left/Right: standard controls
    wx_des = maxPitchSpeed * eff * uy; // pitch
    wy_des = maxYawSpeed   * eff * ux; // yaw
    wz_des = targetRollSpeed;          // roll from DAR
  }

  // --- 5. PD control â†’ angular acceleration per axis ---
  const ax_des = KpPitch * (wx_des - w.x) - KdPitch * w.x;
  const ay_des = KpYaw   * (wy_des - w.y) - KdYaw   * w.y;
  const az_des = KpRoll  * (wz_des - w.z) - KdRoll  * w.z;

  const ax = THREE.MathUtils.clamp(ax_des, -maxAccelPitchRad, maxAccelPitchRad);
  const ay = THREE.MathUtils.clamp(ay_des, -maxAccelYawRad,   maxAccelYawRad);
  const az = THREE.MathUtils.clamp(az_des, -maxAccelRollRad,  maxAccelRollRad);

  // --- 6. Integrate angular velocity ---
  w.x += ax * dt;
  w.y += ay * dt;
  w.z += az * dt;

  // --- 7. Damping + release brake ---
  // CRITICAL: Damping only applies when inputs are released!
  const noStick = eff < 0.08;
  if (noStick) {
    const baseDamp = darOn ? dampDAR : damp;
    const dampEff = (baseDamp || 0) + ((!darOn) ? (brakeOnRelease || 0) : 0);
    const scale = Math.exp(-dampEff * dt);
    w.multiplyScalar(scale);
  }

  // --- 8. Per-axis caps + global cap ---
  if (Math.abs(w.x) > wMaxPitch) w.x = Math.sign(w.x) * wMaxPitch;
  if (Math.abs(w.y) > wMaxYaw)   w.y = Math.sign(w.y) * wMaxYaw;

  const wMag = w.length();
  if (wMag > wMax) {
    w.multiplyScalar(wMax / wMag);
  }

  // --- 9. Quaternion integration (unchanged) ---
  const wx = w.x, wy = w.y, wz = w.z, halfdt = 0.5 * dt;
  const q = car.quaternion;
  const rw = -q.x * wx - q.y * wy - q.z * wz;
  const rx =  q.w * wx + q.y * wz - q.z * wy;
  const ry =  q.w * wy + q.z * wx - q.x * wz;
  const rz =  q.w * wz + q.x * wy - q.y * wx;
  q.w += rw * halfdt;
  q.x += rx * halfdt;
  q.y += ry * halfdt;
  q.z += rz * halfdt;
  q.normalize();

  // === RING MODE: Override car position and update rings ===
  if (ringModeActive) {
    // Override car position to stay on grid
    if (car) {
      car.position.x = ringModePosition.x;
      car.position.y = ringModePosition.y;
      car.position.z = 0; // Locked to 2D plane
    }

    // Find the closest ring and the next ring ahead of the car (negative Z)
    // Prioritize by spawn order (oldest unpassed ring first), then by Z-distance
    let targetRing = null;
    let nextRing = null;

    // Filter to only active rings (behind camera, not passed/missed)
    const activeRings = rings.filter(r => r.mesh.position.z < 0 && !r.passed && !r.missed);

    if (activeRings.length > 0) {
      // Sort by spawn index (oldest first), then by Z-distance (closest first)
      activeRings.sort((a, b) => {
        // First priority: spawn order (lower index = spawned earlier)
        if (a.spawnIndex !== b.spawnIndex) {
          return a.spawnIndex - b.spawnIndex;
        }
        // Second priority: Z-distance (higher Z = closer to camera)
        return b.mesh.position.z - a.mesh.position.z;
      });

      // Oldest unpassed ring is the target
      targetRing = activeRings[0];

      // Next oldest unpassed ring (if exists)
      if (activeRings.length > 1) {
        nextRing = activeRings[1];
      }
    }

    // Smooth camera path following system - interpolate between multiple rings
    let cameraOffsetX = 0;
    let cameraOffsetY = CAM_BASE.y;

    if (targetRing) {
      // Calculate weighted average position of next 2-3 upcoming rings
      // This creates a smooth curve through ring centers
      let weightedX = 0;
      let weightedY = 0;
      let totalWeight = 0;

      // Get up to 3 upcoming rings for smooth path
      const upcomingRings = activeRings.slice(0, Math.min(3, activeRings.length));

      for (let i = 0; i < upcomingRings.length; i++) {
        const ring = upcomingRings[i];
        const ringDepth = Math.abs(ring.mesh.position.z);

        // Weight based on depth - closer rings have more influence
        // But far rings still contribute to keep them in frame
        let weight = 1.0;
        if (i === 0) {
          weight = 3.0; // Current target ring has strongest influence
        } else if (i === 1) {
          weight = 1.5; // Next ring has moderate influence
        } else {
          weight = 0.5; // Future rings have minimal influence
        }

        // Reduce weight for very far rings to prevent camera from overshooting
        const depthFactor = Math.min(ringDepth / 1000, 1.0);
        weight *= (1.0 - depthFactor * 0.5);

        weightedX += ring.mesh.position.x * weight;
        weightedY += ring.mesh.position.y * weight;
        totalWeight += weight;
      }

      // Calculate average target position (smooth path through rings)
      if (totalWeight > 0) {
        const pathTargetX = weightedX / totalWeight;
        const pathTargetY = weightedY / totalWeight;

        // Smoothly interpolate camera target toward path
        const smoothing = 0.05; // Very smooth interpolation
        cameraTargetX += (pathTargetX - cameraTargetX) * smoothing;
        cameraTargetY += (pathTargetY - cameraTargetY) * smoothing;

        // Calculate direction from car to smooth path target
        const deltaX = cameraTargetX - ringModePosition.x;
        const deltaY = cameraTargetY - ringModePosition.y;
        const distXY = Math.hypot(deltaX, deltaY);

        if (distXY > 0.1) {
          // Normalize direction
          const dirX = deltaX / distXY;
          const dirY = deltaY / distXY;

          // Minimal camera orbit - keep it simple and smooth
          const orbitRadius = 150; // Fixed moderate orbit

          // Camera aims to keep path visible
          cameraOffsetX = -dirX * orbitRadius;
          cameraOffsetY = CAM_BASE.y - dirY * 100;
        }
      }
    }

    // Smoothly move camera to target offset position
    const targetCamX = ringModePosition.x + cameraOffsetX;
    const targetCamY = ringModePosition.y + cameraOffsetY;
    const targetCamZ = CAM_BASE.z;

    // Lerp camera position for smooth movement
    camera.position.x += (targetCamX - camera.position.x) * ringCameraSpeed;
    camera.position.y += (targetCamY - camera.position.y) * ringCameraSpeed;
    camera.position.z = targetCamZ;

    // Look at point between car and next ring to keep distant rings visible
    let lookAtX = ringModePosition.x;
    let lookAtY = ringModePosition.y;
    let lookAtZ = 0;

    if (targetRing) {
      // Calculate full 3D distance from car to ring
      const dx = targetRing.mesh.position.x - ringModePosition.x;
      const dy = targetRing.mesh.position.y - ringModePosition.y;
      const dz = targetRing.mesh.position.z - 0; // Car is at Z=0
      const ringDistance3D = Math.sqrt(dx*dx + dy*dy + dz*dz);

      // Much gentler blend - max 20% toward ring to keep car on screen
      // Only blend if ring is very far (>2000 units)
      const blendFactor = ringDistance3D > 2000 ? Math.min((ringDistance3D - 2000) / 4000, 0.2) : 0;

      lookAtX = ringModePosition.x * (1 - blendFactor) + targetRing.mesh.position.x * blendFactor;
      lookAtY = ringModePosition.y * (1 - blendFactor) + targetRing.mesh.position.y * blendFactor;
      lookAtZ = 0 * (1 - blendFactor) + targetRing.mesh.position.z * blendFactor * 0.2; // Minimal Z shift
    }

    camera.lookAt(lookAtX, lookAtY, lookAtZ);

    // Move rings toward camera (only if not paused, game has started, and not game over)
    if (!ringModePaused && ringModeStarted && ringModeLives > 0) {
      for(let i = rings.length - 1; i >= 0; i--) {
        const ring = rings[i];
        const prevZ = ring.mesh.position.z;
        ring.mesh.position.z += ring.speed * dt; // Use individual ring speed for progression
        const newZ = ring.mesh.position.z;

        // Update visual effects based on distance for depth perception
        const distanceZ = Math.abs(ring.mesh.position.z);

        // Opacity fade: full opacity when close, fade out when far
        // Starts fading at 3000 units, fully visible at 1000 units
        const opacityFactor = THREE.MathUtils.clamp(1 - (distanceZ - 1000) / 2000, 0.3, 1);
        ring.mesh.material.opacity = opacityFactor;
        ring.mesh.material.transparent = true;

        // Emissive intensity: brighter when close, dimmer when far
        // This creates a fog-like effect
        const emissiveFactor = THREE.MathUtils.clamp(1 - distanceZ / 4000, 0.3, 0.8);
        ring.mesh.material.emissiveIntensity = emissiveFactor;

        // Point light intensity also fades with distance
        if (ring.mesh.children[0] && ring.mesh.children[0].isLight) {
          const lightIntensity = THREE.MathUtils.clamp(2 - distanceZ / 2000, 0.5, 2);
          ring.mesh.children[0].intensity = lightIntensity;
        }

        // Check if car passed through the ring's plane (Z=0, where car is locked)
        if (prevZ < 0 && newZ >= 0 && !ring.passed && !ring.missed) {
          // Ring crossed the car's Z plane - check for collision
          const carX = ringModePosition.x;
          const carY = ringModePosition.y;
          const ringX = ring.mesh.position.x;
          const ringY = ring.mesh.position.y;

          // Distance from car center to ring center in XY plane
          const dx = carX - ringX;
          const dy = carY - ringY;
          const distanceToCenter = Math.sqrt(dx * dx + dy * dy);

          // Ring outer and inner radii
          const ringOuterRadius = ring.size / 2 + RING_TUBE_RADIUS;
          const ringInnerRadius = ring.size / 2 - RING_TUBE_RADIUS;

          if (distanceToCenter <= ringInnerRadius) {
            // Clean pass - car went through the center
            ring.passed = true;
            ringModeScore++;
            ringModeRingCount++;
            console.log('Passed through ring! Score:', ringModeScore);

            // Audio feedback - play success sound
            playRingPassSound();
          } else if (distanceToCenter < ringOuterRadius) {
            // Hit the edge of the ring
            ring.missed = true;
            console.log('Hit ring edge! Heart damage');
            // Audio feedback - play miss sound
            playRingMissSound();
            // TODO: Apply heart damage
          } else {
            // Completely missed the ring
            ring.missed = true;
            ringModeLives--;
            console.log('Missed ring! Lives:', ringModeLives);
            // Audio feedback - play miss sound
            playRingMissSound();
            // TODO: Check if game over
          }
        }

        // Remove rings that have passed the camera
        if(ring.mesh.position.z > RING_DESPAWN_DISTANCE) {
          // Check if we missed an unpassed ring
          if (!ring.passed && !ring.missed) {
            ringModeLives--;
            console.log('Ring passed without going through! Lives:', ringModeLives);
            // Audio feedback - play miss sound
            playRingMissSound();
          }
          scene.remove(ring.mesh);
          ring.mesh.geometry.dispose();
          ring.mesh.material.dispose();
          rings.splice(i, 1);
        }
      }

      // Spawn new rings periodically (affected by difficulty)
      ringSpawnTimer += dt;
      const spawnInterval = RING_BASE_SPAWN_INTERVAL * DIFFICULTY_SETTINGS[currentDifficulty].spawnIntervalMultiplier;
      if(ringSpawnTimer >= spawnInterval) {
        spawnRing();
        ringSpawnTimer = 0;
      }
    }
  }
}
/* Camera zoom/orbit *//* Camera zoom/orbit */
let orbitPhase=0;

function applyZoom(){
  const f = Math.max(0.7, Math.min(1.6, zoom||1));
  const dist = CAM_BASE.z / f;
  const h = CAM_BASE.y / f;
  if(!orbitOn){
    camera.position.set(0, h, dist);
    camera.lookAt(0, car ? car.position.y : 0, 0);
  }
}

function orbitStep(t){
  const f = Math.max(0.7, Math.min(1.6, zoom||1));
  const R = (CAM_BASE.z / f);
  const h = (CAM_BASE.y / f);
  const sp = 0.35 * orbitDir;
  const x = Math.sin(t*sp)*R;
  const z = Math.cos(t*sp)*R;
  camera.position.set(x, h, z);
  camera.lookAt(0, car ? car.position.y : 0, 0);
}

/* XYZ Gizmo */
/* XYZ Gizmo */
const gizmoRect = document.getElementById('gizmoFrame').getBoundingClientRect();
const gizmoScene = new THREE.Scene();
const gizmoCam = new THREE.PerspectiveCamera(40, gizmoRect.width/gizmoRect.height, 0.1, 100);
gizmoCam.position.set(0,0,6);
const gizmoAxes = new THREE.AxesHelper(3.2);
gizmoScene.add(gizmoAxes);
const gizmoTarget = new THREE.Object3D();
gizmoScene.add(gizmoTarget);
gizmoAxes.position.copy(gizmoTarget.position);

/* Render HUD & loop */
function renderHUD(){
  Hclear();
  drawJoystick();
  drawDAR();
  if(ringModeActive) {
    if(showBoostButton) drawBoost();
    drawRingModeHUD();
  }
}

// Draw Ring Mode HUD (score, lives, ring count)
function drawRingModeHUD() {
  const ctx = hctx;

  // Scale text down on mobile/tablet for less distraction
  const textScale = isMobile ? 0.65 : 1.0;

  // High Score - top center
  ctx.fillStyle = '#ffffff';
  ctx.font = `bold ${Math.floor(32 * textScale)}px system-ui`;
  ctx.textAlign = 'center';
  ctx.textBaseline = 'top';
  ctx.fillText(`High Score: ${ringModeHighScore}`, innerWidth / 2, 20);

  // Ring count - below high score
  ctx.font = `bold ${Math.floor(24 * textScale)}px system-ui`;
  ctx.fillText(`Rings: ${ringModeRingCount}`, innerWidth / 2, 20 + (40 * textScale));

  // Lives - top left with heart symbols
  ctx.textAlign = 'left';
  ctx.font = `bold ${Math.floor(28 * textScale)}px system-ui`;
  const heartSpacing = 35 * textScale;
  for (let i = 0; i < Math.min(ringModeLives, 10); i++) {
    ctx.fillStyle = '#ff5c5c';
    ctx.fillText('â™¥', 20, 20 + i * heartSpacing);
  }

  // Ring landing indicator - blinking hollow circle on grid
  if (ringModeStarted && !ringModePaused && ringModeLives > 0 && rings.length > 0) {
    // Find the target ring (oldest unpassed ring)
    const targetRing = rings.find(r => !r.passed && !r.missed);

    if (targetRing) {
      // Convert ring position to screen coordinates
      const playerScreenX = innerWidth / 2;
      const playerScreenY = innerHeight / 2;
      const ringScreenX = playerScreenX + (targetRing.mesh.position.x - ringModePosition.x);
      const ringScreenY = playerScreenY - (targetRing.mesh.position.y - ringModePosition.y);

      // Calculate time until ring reaches grid (Z = 0)
      const timeToGrid = Math.abs(targetRing.mesh.position.z) / targetRing.speed;

      // Blink frequency increases as ring gets closer
      // At 3+ seconds away: blink every 1 second
      // At 0 seconds: blink very fast (10 times per second)
      const maxTime = 3; // Time in seconds when blinking starts
      const minBlinkInterval = 0.1; // Fastest blink (10 Hz)
      const maxBlinkInterval = 1.0; // Slowest blink (1 Hz)

      const blinkInterval = maxBlinkInterval - (Math.min(timeToGrid, maxTime) / maxTime) * (maxBlinkInterval - minBlinkInterval);
      const blinkPhase = (performance.now() / 1000) % blinkInterval;
      const isVisible = blinkPhase < (blinkInterval * 0.5); // On for half the interval

      if (isVisible) {
        // Get ring color from material
        const ringColor = targetRing.mesh.material.color;
        const ringRadius = targetRing.size / 2;

        ctx.save();

        // Draw hollow circle with ring's color
        ctx.strokeStyle = `rgb(${ringColor.r * 255}, ${ringColor.g * 255}, ${ringColor.b * 255})`;
        ctx.lineWidth = 5;
        ctx.beginPath();
        ctx.arc(ringScreenX, ringScreenY, ringRadius, 0, Math.PI * 2);
        ctx.stroke();

        // Add subtle glow
        ctx.strokeStyle = `rgba(${ringColor.r * 255}, ${ringColor.g * 255}, ${ringColor.b * 255}, 0.3)`;
        ctx.lineWidth = 10;
        ctx.beginPath();
        ctx.arc(ringScreenX, ringScreenY, ringRadius, 0, Math.PI * 2);
        ctx.stroke();

        ctx.restore();
      }
    }
  }

  // Directional arrow compass for distant rings
  if (ringModeStarted && !ringModePaused && ringModeLives > 0 && rings.length > 0) {
    // Find the target ring (oldest unpassed ring)
    const targetRing = rings.find(r => !r.passed && !r.missed);

    if (targetRing) {
      // Calculate 2D distance from car to ring (on grid plane)
      const dx = targetRing.mesh.position.x - ringModePosition.x;
      const dy = targetRing.mesh.position.y - ringModePosition.y;
      const distance2D = Math.sqrt(dx*dx + dy*dy);

      // Draw dashed trail from player to ring position on grid
      // This shows the path you need to travel
      if (distance2D > 200) { // Only show trail for distant rings
        // Convert grid positions to screen positions
        // Player is always at screen center
        const playerScreenX = innerWidth / 2;
        const playerScreenY = innerHeight / 2;

        // Ring position relative to player (offset from center)
        // Screen Y is inverted (positive = down), so negate dy
        const ringScreenX = playerScreenX + dx;
        const ringScreenY = playerScreenY - dy;

        // Calculate start point offset from player (to avoid drawing over car)
        const carRadius = 50; // Visual radius to skip around car
        const angle = Math.atan2(ringScreenY - playerScreenY, ringScreenX - playerScreenX);
        const startX = playerScreenX + Math.cos(angle) * carRadius;
        const startY = playerScreenY + Math.sin(angle) * carRadius;

        // Draw dashed line (starting from edge of car visual)
        ctx.save();
        ctx.strokeStyle = 'rgba(255, 92, 92, 0.6)'; // Semi-transparent red
        ctx.lineWidth = 3;
        ctx.setLineDash([15, 10]); // Dashed pattern: 15px dash, 10px gap
        ctx.beginPath();
        ctx.moveTo(startX, startY);
        ctx.lineTo(ringScreenX, ringScreenY);
        ctx.stroke();
        ctx.setLineDash([]); // Reset dash pattern
        ctx.restore();

        // Draw target orb at ring position
        ctx.save();
        // Outer glow
        const gradient = ctx.createRadialGradient(ringScreenX, ringScreenY, 0, ringScreenX, ringScreenY, 25);
        gradient.addColorStop(0, 'rgba(255, 92, 92, 0.8)');
        gradient.addColorStop(0.5, 'rgba(255, 92, 92, 0.4)');
        gradient.addColorStop(1, 'rgba(255, 92, 92, 0)');
        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(ringScreenX, ringScreenY, 25, 0, Math.PI * 2);
        ctx.fill();

        // Inner solid orb
        ctx.fillStyle = '#ff5c5c';
        ctx.beginPath();
        ctx.arc(ringScreenX, ringScreenY, 12, 0, Math.PI * 2);
        ctx.fill();

        // White center highlight
        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
        ctx.beginPath();
        ctx.arc(ringScreenX - 4, ringScreenY - 4, 5, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }

      // Show arrow if ring is far away - keep on screen longer (5 seconds worth of distance)
      // At max speed ~1400 units/s, 5 seconds = ~7000 units, use 3000 to be visible earlier
      if (distance2D > 800) {
        // Calculate direction angle (in 2D, looking down from above)
        // Negate dy because screen Y is inverted (increases downward, grid Y increases upward)
        const angle = Math.atan2(-dy, dx);

        // Convert player grid position to screen position (centered on screen)
        // The car is always at screen center, so the compass is also at screen center
        const compassCenterX = innerWidth / 2;
        const compassCenterY = innerHeight / 2;

        // Draw compass circle - size of medium ring (~150 units radius on screen)
        const compassRadius = 120;

        ctx.save();

        // Draw semi-transparent dark circle background
        ctx.fillStyle = 'rgba(0, 0, 0, 0.3)';
        ctx.beginPath();
        ctx.arc(compassCenterX, compassCenterY, compassRadius, 0, Math.PI * 2);
        ctx.fill();

        // Draw circle outline
        ctx.strokeStyle = 'rgba(255, 255, 255, 0.5)';
        ctx.lineWidth = 3;
        ctx.stroke();

        // Calculate arrow position on circle perimeter
        const arrowX = compassCenterX + Math.cos(angle) * compassRadius;
        const arrowY = compassCenterY + Math.sin(angle) * compassRadius;

        // Draw arrow at edge of circle pointing toward ring
        ctx.translate(arrowX, arrowY);
        ctx.rotate(angle);

        // Draw prominent arrow shape
        const arrowSize = 30;
        ctx.fillStyle = '#ff5c5c';
        ctx.strokeStyle = '#ffffff';
        ctx.lineWidth = 3;
        ctx.beginPath();
        ctx.moveTo(arrowSize, 0); // Arrow tip (pointing right = direction of rotation)
        ctx.lineTo(-arrowSize/2, -arrowSize/2); // Top back
        ctx.lineTo(-arrowSize/2, arrowSize/2); // Bottom back
        ctx.closePath();
        ctx.fill();
        ctx.stroke();

        ctx.restore();

        // Distance text in center of compass
        const distText = `${Math.round(distance2D)}u`;
        ctx.font = 'bold 24px system-ui';
        ctx.textAlign = 'center';
        ctx.textBaseline = 'middle';
        ctx.fillStyle = '#ffffff';
        ctx.strokeStyle = '#000000';
        ctx.lineWidth = 4;
        ctx.strokeText(distText, compassCenterX, compassCenterY);
        ctx.fillText(distText, compassCenterX, compassCenterY);
      }
    }
  }

  // Game over or paused text
  if (ringModeLives <= 0) {
    // Update high score if current score beats it
    if (ringModeScore > ringModeHighScore) {
      ringModeHighScore = ringModeScore;
      saveSettings(); // Save new high score to localStorage
    }

    // Stop audio on game over
    stopBoostRumble();

    // Activate orbit for cool bouncing effect on game over
    if (!orbitOn) {
      orbitOn = true;
    }

    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, innerHeight / 2 - 100, innerWidth, 200);
    ctx.fillStyle = '#ff5c5c';
    ctx.font = 'bold 48px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('GAME OVER', innerWidth / 2, innerHeight / 2 - 50);
    ctx.font = 'bold 24px system-ui';
    ctx.fillText(`Final Score: ${ringModeScore}`, innerWidth / 2, innerHeight / 2 - 5);

    // Draw retry button
    const retryButtonWidth = 200;
    const retryButtonHeight = 50;
    const retryButtonX = innerWidth / 2 - retryButtonWidth / 2;
    const retryButtonY = innerHeight / 2 + 30;

    ctx.fillStyle = '#4c8dff';
    ctx.fillRect(retryButtonX, retryButtonY, retryButtonWidth, retryButtonHeight);
    ctx.strokeStyle = '#ffffff';
    ctx.lineWidth = 3;
    ctx.strokeRect(retryButtonX, retryButtonY, retryButtonWidth, retryButtonHeight);

    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 24px system-ui';
    ctx.fillText('RETRY', innerWidth / 2, retryButtonY + retryButtonHeight / 2);
  } else if (ringModePaused) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
    ctx.fillRect(0, innerHeight / 2 - 40, innerWidth, 80);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 48px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('PAUSED', innerWidth / 2, innerHeight / 2);
  } else if (!ringModeStarted) {
    ctx.fillStyle = 'rgba(0, 0, 0, 0.5)';
    ctx.fillRect(0, innerHeight / 2 - 40, innerWidth, 80);
    ctx.fillStyle = '#ffffff';
    ctx.font = 'bold 32px system-ui';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    ctx.fillText('Press Boost to Start!', innerWidth / 2, innerHeight / 2);
  }
}

let lastT = performance.now()/1000;
function tick(){
  const t = performance.now()/1000;
  const dt = Math.min(0.033, Math.max(0.001, t - lastT));
  lastT = t;

  if(orbitOn){ orbitPhase += dt; orbitStep(orbitPhase); }

  updateKeyboardInput();
  updateGamepadInput();
  integrate(dt);

  renderer.setScissorTest(false);
  renderer.setViewport(0,0,innerWidth,innerHeight);
  renderer.render(scene, camera);

  if(car){
    gizmoTarget.quaternion.copy(car.quaternion);
    gizmoAxes.quaternion.copy(gizmoTarget.quaternion);
  }
  const gf = document.getElementById('gizmoFrame').getBoundingClientRect();
  const sx = Math.floor(gf.left), sy = Math.floor(innerHeight - gf.bottom);
  const sw = Math.floor(gf.width), sh = Math.floor(gf.height);
  renderer.setScissorTest(true);
  renderer.setScissor(sx,sy,sw,sh);
  renderer.setViewport(sx,sy,sw,sh);
  renderer.render(gizmoScene, gizmoCam);
  renderer.setScissorTest(false);

  renderHUD();
  requestAnimationFrame(tick);
}

/* Resize & boot */
function resize(){
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  sizeHud(); clampJoyCenter(); clampDARCenter(); clampBoostCenter(); positionHints(); applyZoom();
}
addEventListener('resize', resize);

// Restore saved car body or default to octane
const savedCarBody = savedSettings.selectedCarBody || 'octane';
if (presets[savedCarBody]) {
  buildCar(presets[savedCarBody], savedCarBody);
  presetSel.value = savedCarBody;
} else {
  buildCar(presets.octane, "octane");
}

// Set initial menu button styling based on saved selection
updateMenuButtonStyling();

// Set initial rotation: roof facing camera, nose pointing up
// X: +270Â°, Y: 0Â°, Z: +180Â°
if (car) {
  car.rotation.set(Math.PI * 1.5, 0, Math.PI); // X: +270Â°, Y: 0Â°, Z: +180Â°
}

// Preload Ring Mode resources after car is ready (prevents lag on first ring spawn)
preloadRingResources();

// Restore saved air roll (skipSave = true to avoid overwriting localStorage on load)
setRoll(airRoll, true);

positionHints();
applyZoom();
applyTheme(isDarkMode); // Initialize theme

// Restore theme button state (main screen)
const themeBtn = document.getElementById('themeBtn');
themeBtn.textContent = isDarkMode ? 'ðŸŒ™' : 'â˜€ï¸';

// Restore arrow and circle toggle button states
const arrowToggleBtn = document.getElementById('arrowToggle');
arrowToggleBtn.classList.toggle('active', showArrow);
arrowToggleBtn.textContent = showArrow ? 'Show Arrow' : 'Hide Arrow';

const circleToggleBtn = document.getElementById('circleToggle');
circleToggleBtn.classList.toggle('active', showCircle);
circleToggleBtn.textContent = showCircle ? 'Show Circle' : 'Hide Circle';

// Restore toggle/hold mode button state
const toggleModeBtn = document.getElementById('toggleMode');
toggleModeBtn.classList.toggle('active', airRollIsToggle);
toggleModeBtn.textContent = airRollIsToggle ? 'Toggle' : 'Hold';

// Restore gamepad enabled button state
gpEnableBtn.classList.toggle('active', gpEnabled);
gpStatusTag.textContent = gpEnabled ? 'Enabled (waiting for gamepad)' : 'Disabled';

// Restore Ring Mode difficulty selector
if (ringDifficultySelector) {
  ringDifficultySelector.value = currentDifficulty;
}

requestAnimationFrame(tick);
</script>
</body>
</html>
