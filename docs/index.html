<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>L4 — Blender-Style + XYZ Gizmo + DAR Toggle/Relocate</title>
<style>
  /* === CSS BASE START === */
  html,body{margin:0;padding:0;height:100%;background:#ffffff;color:#0e0f12;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overscroll-behavior:none}
  body{background:linear-gradient(180deg,#f6f7fb 0%,#eef1f6 45%,#e9edf3 100%);}
  *, *::before, *::after{box-sizing:border-box}
  *{user-select:none;-webkit-user-select:none;-ms-user-select:none;-webkit-touch-callout:none}
  #gl{position:fixed;inset:0;z-index:0;display:block}
  #hud{position:fixed;inset:0;z-index:1;display:block;touch-action:none}
  /* === CSS BASE END === */

  /* === HAMBURGER === */
  #menuBtn{
    position:fixed;top:.6rem;right:.6rem;z-index:3;width:44px;height:44px;
    border-radius:12px;border:1px solid #3a3d45;background:#181a20;display:grid;place-items:center;
    box-shadow:0 2px 10px rgba(0,0,0,.25)
  }
  #menuBtn .bar{display:block;width:20px;height:2px;background:#e8e8ea;margin:3px 0}
  #menuBtn.active{background:#0066ff;border-color:#4c8dff}

  /* === OVERLAY MENU PANEL === */
  #menuOverlay{
    position:fixed; inset:0; z-index:4; display:none;
    background:rgba(10,12,16,0.45); backdrop-filter: blur(3px);
    overflow-x:hidden; /* prevent sideways scroll */
  }
  #menuPanel{
    position:absolute; left:50%; top:12vh; transform:translateX(-50%);
    width:min(960px, calc(100vw - 2rem)); max-height:76vh; overflow:auto;
    background:rgba(24,26,32,.96); color:#e8e8ea; border:1px solid #3a3d45; border-radius:14px;
    box-shadow:0 20px 60px rgba(0,0,0,.35);
    overflow-x:hidden; /* extra guard */
  }
  .mp-header{
    position:sticky; top:0; background:rgba(24,26,32,.98); z-index:1;
    padding:.9rem clamp(.8rem, 2vw, 1rem); border-bottom:1px solid #33373f; display:flex; align-items:center; justify-content:space-between;
  }
  .mp-title{font-weight:700;letter-spacing:.2px}
  .mp-close{border:1px solid #3a3d45;background:#181a20;color:#e8e8ea;border-radius:10px;padding:.35rem .6rem;font-weight:600}
  .mp-body{
    padding:clamp(.6rem,2vw,1rem);
    display:grid; grid-template-columns: 1fr 1fr; gap:14px;
  }
  @media (max-width: 860px){ .mp-body{grid-template-columns: 1fr;} }

  .card{
    background:#15171d; border:1px solid #33373f; border-radius:12px; padding:.9rem;
  }
  .card h3{margin:.1rem 0 .7rem; font-size:1rem; opacity:.95}
  .row{display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; margin:.45rem 0; width:100%;}
  .btn{border:1px solid #3a3d45;padding:.45rem .7rem;border-radius:999px;background:#181a20;color:#e8e8ea;font-weight:600;letter-spacing:.2px;cursor:pointer}
  .btn.active{background:#0066ff;border-color:#4c8dff}
  .tag{background:#181a20;border:1px solid #3a3d45;padding:.25rem .5rem;border-radius:999px;font-size:.82rem;white-space:nowrap}

  /* Slider rows: keep content within side edges & responsive */
  .sl{
    display:flex; align-items:center; gap:.6rem; flex-wrap:nowrap;
    width:100%; min-width:0;
  }
  .sl label{
    font-size:.88rem; opacity:.92; flex:0 0 150px; min-width:120px; max-width:220px;
  }
  .sl input[type=range]{
    accent-color:#4c8dff;
    flex:1 1 auto; min-width:0; max-width:100%; width:100%;
  }
  .sl .tag{flex:0 0 auto}

  /* On very narrow screens, stack label on its own line to avoid overflow */
  @media (max-width:520px){
    .sl{flex-wrap:wrap}
    .sl label{flex:1 0 100%}
    .sl input[type=range]{flex:1 0 100%}
    .sl .tag{margin-left:auto}
  }

  select{background:#181a20;color:#e8e8ea;border:1px solid #3a3d45;border-radius:10px;padding:.35rem .5rem;max-width:100%}

  /* Hints (stick/DAR) */
  #joyHint,#darHint{position:fixed; z-index:2; pointer-events:none;background:rgba(24,26,32,.92); border:1px solid #3a3d45; color:#cfd3dc;
    padding:.35rem .55rem; border-radius:10px; font-size:.85rem; white-space:nowrap; transform:translate(-50%,-50%); opacity:0; transition:opacity .25s ease;}
  #joyHint.show,#darHint.show{opacity:1;}

  /* XYZ gizmo frame */
  #gizmoFrame{
    position:fixed; right:.6rem; top:64px; width:84px; height:84px; z-index:2;
    border-radius:10px; border:1px solid #3a3d45; background:rgba(24,26,32,.5);
    box-shadow:0 8px 24px rgba(0,0,0,.2); pointer-events:none;
  }
</style>
</head>
<body>
  <!-- CANVASES -->
  <canvas id="gl"></canvas>
  <canvas id="hud"></canvas>
  <div id="gizmoFrame"></div>

  <!-- HAMBURGER -->
  <button id="menuBtn" type="button" title="Open Menu"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button>

  <!-- OVERLAY MENU (ALL UI LIVES HERE) -->
  <div id="menuOverlay">
    <div id="menuPanel">
      <div class="mp-header">
        <div class="mp-title">L4 Controls & Settings</div>
        <button class="mp-close" id="menuCloseBtn" type="button">Close</button>
      </div>
      <div class="mp-body">

        <!-- Rotation -->
        <div class="card">
          <h3>Rotation</h3>
          <div class="row">
            <button id="rollL" class="btn active" type="button">Air Roll Right</button>
            <button id="rollR" class="btn" type="button">Air Roll Left</button>
            <button id="restart" class="btn" type="button">Restart</button>
            <button id="orbit" class="btn" type="button">Orbit</button>
          </div>

          <div class="row sl">
            <label for="spinSlider">DAR Roll</label>
            <input id="spinSlider" type="range" min="0" max="3.0" step="0.01" value="1.20"/>
            <span class="tag" id="rollVal">1.20 s/rot</span>
          </div>

          <div class="row" style="font-size:.86rem;opacity:.85;line-height:1.35;">
            Tip: With <b>Air Roll Right</b>, rotate the stick clockwise. With <b>Air Roll Left</b>, rotate the stick counter-clockwise.
          </div>
        </div>

        <!-- Dynamics -->
        <div class="card">
          <h3>Dynamics</h3>

          <div class="row sl">
            <label for="accelRange">Max Accel (°/s²)</label>
            <input id="accelRange" type="range" min="120" max="1200" step="5" value="120"/>
            <span class="tag" id="accelTag">120</span>
          </div>

          <div class="row sl">
            <label for="curveRange">Input Curve</label>
            <input id="curveRange" type="range" min="1.0" max="2.2" step="0.05" value="1.0"/>
            <span class="tag" id="curveTag">1.00</span>
          </div>

          <div class="row sl">
            <label for="dampRange">Damp</label>
            <input id="dampRange" type="range" min="0.0" max="1.2" step="0.05" value="1.2"/>
            <span class="tag" id="dampTag">1.20</span>
          </div>

          <div class="row sl">
            <label for="brakeRange">Release Brake</label>
            <input id="brakeRange" type="range" min="0.0" max="6.0" step="0.1" value="6.0"/>
            <span class="tag" id="brakeTag">6.0</span>
          </div>

          <div class="row sl">
            <label for="wmaxRange">Max ω (global)</label>
            <input id="wmaxRange" type="range" min="6.0" max="24.0" step="0.5" value="6.0"/>
            <span class="tag" id="wmaxTag">6.0</span>
          </div>

          <div class="row sl">
            <label for="wmaxPitch">Max Pitch ω</label>
            <input id="wmaxPitch" type="range" min="4.0" max="24.0" step="0.5" value="4.0"/>
            <span class="tag" id="wmaxPitchTag">4.0</span>
          </div>

          <div class="row sl">
            <label for="wmaxYaw">Max Yaw ω</label>
            <input id="wmaxYaw" type="range" min="4.0" max="24.0" step="0.5" value="4.0"/>
            <span class="tag" id="wmaxYawTag">4.0</span>
          </div>
        </div>

        <!-- Car -->
        <div class="card">
          <h3>Car</h3>
          <div class="row sl">
            <label for="presetSel">Body</label>
            <select id="presetSel">
              <option value="placeholder" selected>Placeholder (140×56×240)</option>
              <option value="octane">Octane proportions</option>
              <option value="dominus">Dominus proportions</option>
              <!-- Optional: enable GLB as a preset by uncommenting -->
              <!-- <option value="octaneGLB">Octane (GLB)</option> -->
            </select>
          </div>
        </div>

        <!-- View / HUD -->
        <div class="card">
          <h3>View & HUD</h3>

          <div class="row sl">
            <label for="zoomSlider">Zoom</label>
            <input id="zoomSlider" type="range" min="0.70" max="1.60" step="0.01" value="1.00" />
            <span class="tag" id="zoomVal">1.00×</span>
          </div>

          <div class="row sl">
            <label for="stickSizeSlider">Stick Size</label>
            <input id="stickSizeSlider" type="range" min="60" max="180" step="1" value="100" />
            <span class="tag" id="stickVal">100</span>
          </div>

          <div class="row sl">
            <label for="arrowSlider">Arrow Size</label>
            <input id="arrowSlider" type="range" min="0.60" max="4.00" step="0.01" value="1.80" />
            <span class="tag" id="arrowVal">1.80×</span>
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- Hints -->
  <div id="joyHint">Hold outside the stick to reposition (UI hidden)</div>
  <div id="darHint">Tap to toggle roll • Hold to move</div>

<script type="module">
/* ====== IMPORTS (changed) ====== */
import * as THREE from "https://esm.sh/three@0.155.0";
import { GLTFLoader } from "https://esm.sh/three@0.155.0/examples/jsm/loaders/GLTFLoader.js";

/* ====== Renderer / Scene / Camera ====== */
const gl = document.getElementById('gl');
const hud = document.getElementById('hud');
const renderer = new THREE.WebGLRenderer({canvas: gl, antialias: true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0xeef1f6, 900, 2200);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
const CAM_BASE = { y: 280, z: 760 };
camera.position.set(0, CAM_BASE.y, CAM_BASE.z);
scene.add(camera);

/* Lights */
scene.add(new THREE.AmbientLight(0xffffff, 0.8));
const dir = new THREE.DirectionalLight(0xffffff, 1.15);
dir.position.set(-350, 700, 900);
dir.castShadow = false;
scene.add(dir);

/* Grid */
const grid = new THREE.Group();
const gridMain = new THREE.GridHelper(2600, 26, 0xd7dde6, 0xE5E9F1);
gridMain.material.opacity = 0.65;
gridMain.material.transparent = true;
grid.add(gridMain);
grid.rotation.x = -Math.PI/2;
grid.position.y = -160;
scene.add(grid);

/* Colors */
const COL_UP   = 0xff5c5c; // red
const COL_RIGHT= 0x4c8dff; // blue
const COL_DOWN = 0x53d769; // green
const COL_LEFT = 0xffd166; // yellow

/* Materials */
const MAT_BODY  = new THREE.MeshPhongMaterial({color: 0xdfe5ef, shininess: 50, specular: 0x666666});
const MAT_GLASS = new THREE.MeshPhongMaterial({color: 0x9aa6b7, shininess: 40, specular: 0x222222, transparent:true, opacity:0.65});
const MAT_ACCENT= new THREE.MeshPhongMaterial({color: 0xcbd3df, shininess: 35, specular: 0x222222});
const MAT_DARK  = new THREE.MeshPhongMaterial({color: 0xaeb7c4, shininess: 28, specular: 0x222222});
const MAT_EDGE  = (hex)=> new THREE.LineBasicMaterial({color: hex});
const MAT_TIRE_F= new THREE.MeshLambertMaterial({color: 0x8a93a0});
const MAT_TIRE_B= new THREE.MeshLambertMaterial({color: 0x808896});
const MAT_HUB   = new THREE.MeshBasicMaterial({color: 0x5a6270});

/* Presets */
const presets = {
  placeholder: { hx:70, hy:28, hz:120 },
  octane:      { hx:85.65, hy:36.8, hz:120 },
  dominus:     { hx:77.9,  hy:29.3, hz:120 }
};

/* Car builder */
let car=null, BOX=null;
let faceArrow=null, faceTip=null;

function clearCar(){
  if(!car) return;
  scene.remove(car);
  car.traverse(o=>{ if(o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose?.(); });
  car = null;
}

function buildCar(boxDims, presetName="placeholder"){
  clearCar();
  BOX = boxDims;
  car = new THREE.Group();
  car.position.y = 110;
  scene.add(car);

  const body = new THREE.Mesh(new THREE.BoxGeometry(BOX.hx*2, BOX.hy*2, BOX.hz*2), MAT_BODY);
  car.add(body);

  if(presetName==="octane") buildOctane();
  else if(presetName==="dominus") buildDominus();
  else buildPlaceholderFancy();

  // Front-face colored edges
  const vFL = new THREE.Vector3(-BOX.hx, +BOX.hy, +BOX.hz);
  const vFR = new THREE.Vector3(+BOX.hx, +BOX.hy, +BOX.hz);
  const vBR = new THREE.Vector3(+BOX.hx, -BOX.hy, +BOX.hz);
  const vBL = new THREE.Vector3(-BOX.hx, -BOX.hy, +BOX.hz);
  addEdge(vFR, vFL, COL_UP);
  addEdge(vBR, vFR, COL_LEFT);
  addEdge(vBL, vBR, COL_DOWN);
  addEdge(vFL, vBL, COL_RIGHT);

  // Nose arrow
  const noseGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,BOX.hz*0.55)]);
  const nose = new THREE.Line(noseGeom, new THREE.LineBasicMaterial({color: COL_DOWN}));
  car.add(nose);
  const noseTip = new THREE.Mesh(new THREE.ConeGeometry(8,16,12), new THREE.MeshBasicMaterial({color: COL_DOWN}));
  noseTip.rotation.x = Math.PI/2; noseTip.position.z = BOX.hz*0.55 + 10; car.add(noseTip);

  // Wheels
  const xOff = BOX.hx-10, zOff = BOX.hz*0.68;
  addWheel(+xOff, -zOff); addWheel(-xOff, -zOff);
  addWheel(+xOff, +zOff); addWheel(-xOff, +zOff);

  // Face input arrow (front plane)
  const zFace = BOX.hz + 0.6;
  const faceGeom = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0,0,zFace),
    new THREE.Vector3(0,0,zFace)
  ]);
  faceArrow = new THREE.Line(faceGeom, new THREE.LineBasicMaterial({color: 0x333333}));
  car.add(faceArrow);

  faceTip = new THREE.Mesh(new THREE.ConeGeometry(6,12,12), new THREE.MeshBasicMaterial({color: 0x333333}));
  faceTip.position.set(0,0,zFace);
  car.add(faceTip);
  faceArrow.visible = false; faceTip.visible = false;
}

function addEdge(a,b,color){
  const geo = new THREE.BufferGeometry().setFromPoints([a,b]);
  const line = new THREE.Line(geo, MAT_EDGE(color));
  car.add(line);
}
function addWheel(x, z, r=18, w=12){
  const g = new THREE.CylinderGeometry(r, r, w, 16);
  const front = new THREE.Mesh(g, MAT_TIRE_F);
  const back  = new THREE.Mesh(g, MAT_TIRE_B);
  front.rotation.z = Math.PI/2; back.rotation.z  = Math.PI/2;
  const y = -BOX.hy- r*0.55;
  front.position.set(x, y, z + w/2);
  back .position.set(x, y, z - w/2);
  const hub = new THREE.Mesh(new THREE.CylinderGeometry(r*0.35, r*0.35, w*0.6, 10), MAT_HUB);
  hub.rotation.z = Math.PI/2; hub.position.set(x, y, z);
  const grp = new THREE.Group(); grp.add(back, front, hub); car.add(grp);
}
function addCabin(width, height, length, yOffset, zOffset){
  const cabin = new THREE.Mesh(new THREE.BoxGeometry(width, height, length), MAT_GLASS);
  cabin.position.set(0, yOffset, zOffset);
  car.add(cabin);
}
function addSpoiler(width, thickness, depth, yOffset, zOffset){
  const spoiler = new THREE.Mesh(new THREE.BoxGeometry(width, thickness, depth), MAT_ACCENT);
  spoiler.position.set(0, yOffset, zOffset);
  const st1 = new THREE.Mesh(new THREE.BoxGeometry(thickness, yOffset*0.5, thickness), MAT_ACCENT);
  const st2 = st1.clone();
  st1.position.set(-width*0.35, yOffset*0.25, zOffset - depth*0.2);
  st2.position.set(+width*0.35, yOffset*0.25, zOffset - depth*0.2);
  car.add(spoiler, st1, st2);
}
function addBumper(width, height, depth, yOffset, zOffset){
  const bumper = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), MAT_DARK);
  bumper.position.set(0, yOffset, zOffset);
  car.add(bumper);
}
function addFlares(xw, zw, r=10, w=6){
  const hemi = new THREE.CylinderGeometry(r, r, w, 10, 1, false, 0, Math.PI);
  const mat = MAT_ACCENT;
  const y = -BOX.hy + r*0.2;
  function flare(px, pz, flip){
    const f = new THREE.Mesh(hemi, mat);
    f.rotation.z = Math.PI/2;
    f.rotation.y = flip? Math.PI : 0;
    f.position.set(px, y, pz);
    car.add(f);
  }
  flare(+xw+6, +zw, false);
  flare(-xw-6, +zw, true);
  flare(+xw+6, -zw, true);
  flare(-xw-6, -zw, false);
}
function buildPlaceholderFancy(){
  const xOff = BOX.hx-10, zOff = BOX.hz*0.68;
  addFlares(xOff, zOff, 10, 6);
  addCabin(BOX.hx*1.0, BOX.hy*0.9, BOX.hz*0.55, BOX.hy*0.65, -BOX.hz*0.1);
  addSpoiler(BOX.hx*1.0, 6, 24, BOX.hy*0.8, -BOX.hz*0.95);
  addBumper(BOX.hx*0.9, 10, 18, -BOX.hy*0.7, +BOX.hz*0.98);
}
function buildOctane(){
  const xOff = BOX.hx-6, zOff = BOX.hz*0.64;
  addWheel(+xOff, -zOff, 19, 12); addWheel(-xOff, -zOff, 19, 12);
  addWheel(+xOff, +zOff, 18, 12); addWheel(-xOff, +zOff, 18, 12);
  addFlares(xOff, zOff, 12, 7);
  addCabin(BOX.hx*0.95, BOX.hy*1.1, BOX.hz*0.60, BOX.hy*0.85, -BOX.hz*0.05);
  addSpoiler(BOX.hx*1.2, 6, 30, BOX.hy*0.9, -BOX.hz*1.02);
  addBumper(BOX.hx*0.85, 12, 20, -BOX.hy*0.6, +BOX.hz*1.02);
}
function buildDominus(){
  const xOff = BOX.hx-8, zOff = BOX.hz*0.70;
  addWheel(+xOff, -zOff, 18, 12); addWheel(-xOff, -zOff, 18, 12);
  addWheel(+xOff, +zOff, 18, 12); addWheel(-xOff, +zOff, 18, 12);
  addFlares(xOff, zOff, 11, 6);
  addCabin(BOX.hx*1.05, BOX.hy*0.75, BOX.hz*0.75, BOX.hy*0.6, -BOX.hz*0.05);
  addSpoiler(BOX.hx*0.9, 5, 18, BOX.hy*0.72, -BOX.hz*1.0);
  addBumper(BOX.hx*1.05, 10, 30, -BOX.hy*0.55, +BOX.hz*1.05);
}

/* ====== GLB helper (added) ====== */
async function buildCarFromGLB(url, { targetLongest = 240, rotateY = Math.PI } = {}) {
  return new Promise((resolve, reject) => {
    const loader = new GLTFLoader();
    loader.load(
      url,
      (gltf) => {
        if (car) clearCar();
        const glb = gltf.scene || gltf.scenes?.[0];
        if (!glb) { reject(new Error("GLB has no scene")); return; }

        car = glb;

        // Center model
        const box = new THREE.Box3().setFromObject(car);
        const size = new THREE.Vector3(); const center = new THREE.Vector3();
        box.getSize(size); box.getCenter(center);
        car.position.sub(center);

        // Scale to match placeholder length footprint (~240)
        const longest = Math.max(size.x, size.y, size.z) || 1;
        const scale = targetLongest / longest;
        car.scale.setScalar(scale);

        // Placement/orientation to match your scene
        car.position.y = 110;
        car.rotation.y = rotateY;

        scene.add(car);
        resolve(car);
      },
      undefined,
      (err) => reject(err)
    );
  });
}

/* HUD utils */
const hctx = hud.getContext('2d');
function sizeHud(){ hud.width = innerWidth; hud.height = innerHeight; }
sizeHud();
function Hclear(){hctx.setTransform(1,0,0,1,0,0); hctx.clearRect(0,0,hud.width,hud.height);}
function Hcircle(x,y,r,strokeStyle,width){hctx.beginPath();hctx.lineWidth=width;hctx.strokeStyle=strokeStyle;hctx.arc(x,y,r,0,Math.PI*2);hctx.stroke();}
function HfillCircle(x,y,r,fillStyle){hctx.beginPath();hctx.fillStyle=fillStyle;hctx.arc(x,y,r,0,Math.PI*2);hctx.fill();}
function Harc(x,y,r,a1,a2,strokeStyle,width){hctx.beginPath();hctx.lineWidth=width;hctx.strokeStyle=strokeStyle;hctx.arc(x,y,r,a1,a2);hctx.stroke();}
function Hline(x1,y1,x2,y2,strokeStyle,width){hctx.beginPath();hctx.lineWidth=width;hctx.strokeStyle=strokeStyle;hctx.moveTo(x1,y1);hctx.lineTo(x2,y2);hctx.stroke();}
function Htri(x,y,a,r,fillStyle){hctx.save();hctx.translate(x,y);hctx.rotate(a);hctx.beginPath();hctx.moveTo(0,-r);hctx.lineTo(r*0.9,r*0.9);hctx.lineTo(-r*0.9,r*0.9);hctx.closePath();hctx.fillStyle=fillStyle;hctx.fill();hctx.restore();}

/* Joystick */
let JOY_BASE_R = 100, JOY_KNOB_R = Math.round(JOY_BASE_R*0.32);
let JOY_CENTER = new THREE.Vector2(126, innerHeight-170);
let joyActive=false, joyVec = new THREE.Vector2(0,0), smJoy = new THREE.Vector2(0,0);
const STICK_TAU_MS=8, RELOCATE_HOLD_MS=250, STICK_MIN=0.02;
let activeId=null, relocating=false, holdTimer=null;
const COLS = {UP:'#ff5c5c', RIGHT:'#4c8dff', DOWN:'#53d769', LEFT:'#ffd166'};

function drawJoystick(){
  const cx=JOY_CENTER.x, cy=JOY_CENTER.y, r=JOY_BASE_R;
  const t=performance.now(); const pulse=1+0.06*Math.sin(t*0.008), halo=r*pulse+10;
  Hcircle(cx,cy,halo, 'rgba(76,141,255,0.28)', 8);
  Harc(cx,cy,r, -Math.PI/4,  Math.PI/4,   COLS.RIGHT, 12);
  Harc(cx,cy,r,  Math.PI/4,  3*Math.PI/4, COLS.UP,    12);
  Harc(cx,cy,r,  3*Math.PI/4,5*Math.PI/4, COLS.LEFT,  12);
  Harc(cx,cy,r,  5*Math.PI/4,7*Math.PI/4, COLS.DOWN,  12);
  Hcircle(cx,cy,r-18, '#b9c1cd', 2);
  Hline(cx-r+12,cy,cx+r-12,cy,'#cfd6e2',1.5);
  Hline(cx,cy-r+12,cx,cy+r-12,'#cfd6e2',1.5);
  const kx=cx+joyVec.x, ky=cy+joyVec.y;
  Hcircle(kx,ky,JOY_KNOB_R,'#4c8dff',4); HfillCircle(kx,ky,JOY_KNOB_R,'#0f1116');
  hctx.fillStyle='#222'; hctx.beginPath(); hctx.arc(cx,cy,3,0,Math.PI*2); hctx.fill();
}
function inJoyLoose(x,y){
  const dx=x-JOY_CENTER.x, dy=y-JOY_CENTER.y;
  const loose=JOY_BASE_R+28;
  const inC = (dx*dx+dy*dy) <= loose*loose;
  const inB = (Math.abs(dx)<=JOY_BASE_R) && (Math.abs(dy)<=JOY_BASE_R+40);
  return inC || inB;
}
function vecFromJoyPx(x,y){
  let dx=x-JOY_CENTER.x, dy=y-JOY_CENTER.y;
  const m=Math.hypot(dx,dy);
  if(m>JOY_BASE_R){const k=JOY_BASE_R/(m||1); dx*=k; dy*=k;}
  return new THREE.Vector2(dx,dy);
}
function clampJoyCenter(){
  JOY_CENTER.x = Math.max(JOY_BASE_R+20, Math.min(innerWidth -(JOY_BASE_R+20), JOY_CENTER.x));
  JOY_CENTER.y = Math.max(JOY_BASE_R+20, Math.min(innerHeight-(JOY_BASE_R+20), JOY_CENTER.y));
}

/* DAR button (toggle + relocate) */
let DAR_R = 44;
let DAR_CENTER = new THREE.Vector2(innerWidth-120, innerHeight-150);
let darOn = false, darRelocating = false, darHoldTimer = null, darPressT=0;

function drawDAR(){
  const cx=DAR_CENTER.x, cy=DAR_CENTER.y, r=DAR_R;
  HfillCircle(cx,cy,r, darOn ? 'rgba(0,102,255,0.18)' : 'rgba(24,26,32,0.75)');
  Hcircle(cx,cy,r, darOn ? '#4c8dff' : '#3a3d45', darOn ? 5 : 3);
  const a = (airRoll>0) ? Math.PI/2 : -Math.PI/2; // icon shows roll direction
  Htri(cx,cy,a, r*0.55, darOn ? '#0e0f12' : '#e8e8ea');
  Hcircle(cx,cy,r-12, '#bdbdbd', 1.5);
}
function inDAR(x,y){
  const dx=x-DAR_CENTER.x, dy=y-DAR_CENTER.y;
  return (dx*dx+dy*dy) <= (DAR_R*DAR_R);
}
function clampDARCenter(){
  const m=DAR_R+20;
  DAR_CENTER.x = Math.max(m, Math.min(innerWidth - m, DAR_CENTER.x));
  DAR_CENTER.y = Math.max(m, Math.min(innerHeight - m, DAR_CENTER.y));
}

/* Hints */
const joyHint = document.getElementById('joyHint');
const darHint = document.getElementById('darHint');
function showHint(el,ms){ el.classList.add('show'); setTimeout(()=>el.classList.remove('show'), ms); }
function positionHints(){
  joyHint.style.left = (JOY_CENTER.x + JOY_BASE_R + 18)+'px';
  joyHint.style.top  = (JOY_CENTER.y - JOY_BASE_R - 18)+'px';
  darHint.style.left = (DAR_CENTER.x + DAR_R + 18)+'px';
  darHint.style.top  = (DAR_CENTER.y - DAR_R - 18)+'px';
}

/* MENU open/close */
const menuBtn=document.getElementById('menuBtn');
const menuOverlay=document.getElementById('menuOverlay');
const menuCloseBtn=document.getElementById('menuCloseBtn');
let chromeShown=false; // false means menu closed (clean screen)

function openMenu(){
  chromeShown=true;
  menuBtn.classList.add('active');
  menuOverlay.style.display='block';
}
function closeMenu(){
  chromeShown=false;
  menuBtn.classList.remove('active');
  menuOverlay.style.display='none';
}
menuBtn.addEventListener('click',()=> chromeShown ? closeMenu() : openMenu());
menuCloseBtn.addEventListener('click', closeMenu);
menuOverlay.addEventListener('click',(e)=>{ if(e.target===menuOverlay) closeMenu(); });

/* Buttons / presets */
let airRoll = +1;
function setRoll(dir){
  airRoll=dir;
  document.getElementById('rollL').classList.toggle('active',dir>0);
  document.getElementById('rollR').classList.toggle('active',dir<0);
}
document.getElementById('rollL').addEventListener('click',()=>setRoll(+1));
document.getElementById('rollR').addEventListener('click',()=>setRoll(-1));

document.getElementById('restart').addEventListener('click',()=>{
  if (car) car.quaternion.identity();
  w.set(0,0,0);
  orbitOn = false;
  const orbitBtn = document.getElementById('orbit');
  if (orbitBtn) orbitBtn.classList.remove('active');
  orbitPhase = 0;
  camera.position.set(0, 220, 650);
  camera.lookAt(0,0,0);
  if (faceArrow) faceArrow.visible = false;
  if (faceTip)   faceTip.visible   = false;
});
let orbitOn=false;
document.getElementById('orbit').addEventListener('click',()=>{
  orbitOn=!orbitOn; document.getElementById('orbit').classList.toggle('active',orbitOn);
});

/* Sliders / select */
const accelRange=document.getElementById('accelRange'), accelTag=document.getElementById('accelTag');
const curveRange=document.getElementById('curveRange'), curveTag=document.getElementById('curveTag');
const dampRange=document.getElementById('dampRange'),   dampTag=document.getElementById('dampTag');
const brakeRange=document.getElementById('brakeRange'), brakeTag=document.getElementById('brakeTag');
const wmaxRange=document.getElementById('wmaxRange'),   wmaxTag=document.getElementById('wmaxTag');
const wmaxPitchRange=document.getElementById('wmaxPitch'), wmaxPitchTag=document.getElementById('wmaxPitchTag');
const wmaxYawRange=document.getElementById('wmaxYaw'), wmaxYawTag=document.getElementById('wmaxYawTag');
const spinSlider=document.getElementById('spinSlider'), rollVal=document.getElementById('rollVal');
const sizeSlider=document.getElementById('stickSizeSlider'), stickVal=document.getElementById('stickVal');
const zoomSlider=document.getElementById('zoomSlider'), zoomVal=document.getElementById('zoomVal');
const arrowSlider=document.getElementById('arrowSlider'), arrowVal=document.getElementById('arrowVal');
const presetSel=document.getElementById('presetSel');

let maxAccelDeg=parseFloat(accelRange.value),
    inputPow=parseFloat(curveRange.value),
    damp=parseFloat(dampRange.value),
    brakeOnRelease=parseFloat(brakeRange.value),
    wMax=parseFloat(wmaxRange.value),
    wMaxPitch=parseFloat(wmaxPitchRange.value),
    wMaxYaw=parseFloat(wmaxYawRange.value),
    freeRollPeriod=parseFloat(spinSlider.value),
    zoom=parseFloat(zoomSlider.value),
    arrowScale=parseFloat(arrowSlider.value);

function syncTags(){
  accelTag.textContent=maxAccelDeg.toFixed(0);
  curveTag.textContent=inputPow.toFixed(2);
  dampTag.textContent=damp.toFixed(2);
  brakeTag.textContent=brakeOnRelease.toFixed(1);
  wmaxTag.textContent=wMax.toFixed(1);
  wmaxPitchTag.textContent=wMaxPitch.toFixed(1);
  wmaxYawTag.textContent=wMaxYaw.toFixed(1);
  rollVal.textContent = (freeRollPeriod > 0) ? `${freeRollPeriod.toFixed(2)} s/rot` : 'off';
  stickVal.textContent = String(Math.round(JOY_BASE_R));
  zoomVal.textContent = `${(zoom||1).toFixed(2)}×`;
  arrowVal.textContent = `${(arrowScale||1).toFixed(2)}×`;
}
syncTags();

accelRange.addEventListener('input',()=>{maxAccelDeg=parseFloat(accelRange.value)||120; syncTags();});
curveRange.addEventListener('input',()=>{inputPow=parseFloat(curveRange.value)||1.0; syncTags();});
dampRange .addEventListener('input',()=>{damp=parseFloat(dampRange.value)||1.20; syncTags();});
brakeRange.addEventListener('input',()=>{brakeOnRelease=parseFloat(brakeRange.value)||6.0; syncTags();});
wmaxRange .addEventListener('input',()=>{wMax=parseFloat(wmaxRange.value)||6.0; syncTags();});
wmaxPitchRange.addEventListener('input',()=>{wMaxPitch=parseFloat(wmaxPitchRange.value)||4.0; syncTags();});
wmaxYawRange.addEventListener('input',()=>{wMaxYaw=parseFloat(wmaxYawRange.value)||4.0; syncTags();});
spinSlider.addEventListener('input',()=>{freeRollPeriod=parseFloat(spinSlider.value)||0; syncTags();});
sizeSlider.addEventListener('input',()=>{JOY_BASE_R=parseInt(stickSizeSlider.value,10)||100; JOY_KNOB_R=Math.round(JOY_BASE_R*0.32); clampJoyCenter(); positionHints(); syncTags();});
zoomSlider.addEventListener('input',()=>{zoom=parseFloat(zoomSlider.value)||1.0; applyZoom(); syncTags();});
arrowSlider.addEventListener('input',()=>{arrowScale=parseFloat(arrowSlider.value)||1.0; syncTags();});
presetSel .addEventListener('change',()=>{
  const name = presetSel.value;
  (async()=>{
    try{
      if (name === 'octaneGLB') {
        await buildCarFromGLB("https://kronosdevoured.github.io/L4-dar-prototype/models/octane.glb?v=1", { targetLongest: 240, rotateY: Math.PI });
      } else {
        buildCar(presets[name], name);
      }
      car.quaternion.identity(); w.set(0,0,0);
    }catch(e){
      console.error("Preset load failed:", e);
      buildCar(presets.placeholder, "placeholder");
    }
  })();
});

/* Pointer handlers */
hud.addEventListener('pointerdown',(e)=>{
  try{hud.setPointerCapture(e.pointerId);}catch(_){}
  activeId=e.pointerId;

  // DAR: tap toggle, hold relocate
  if(inDAR(e.clientX,e.clientY)){
    darPressT = performance.now();
    clearTimeout(darHoldTimer);
    darHoldTimer = setTimeout(()=>{
      if(activeId===e.pointerId){
        darRelocating = true; showHint(darHint, 2000);
      }
    }, RELOCATE_HOLD_MS);
    e.preventDefault(); return;
  }

  // Joystick (relocate only when menu closed)
  if(inJoyLoose(e.clientX,e.clientY)){
    joyActive=true; joyVec = vecFromJoyPx(e.clientX,e.clientY);
  }else if(!chromeShown){
    clearTimeout(holdTimer);
    holdTimer = setTimeout(()=>{
      if(activeId===e.pointerId && !chromeShown){
        relocating = true; showHint(joyHint, 1800);
      }
    }, RELOCATE_HOLD_MS);
  }
  e.preventDefault();
},{passive:false});
hud.addEventListener('pointermove',(e)=>{
  if(activeId!==e.pointerId)return;
  if(darRelocating){ DAR_CENTER.set(e.clientX,e.clientY); clampDARCenter(); positionHints(); }
  else if(relocating){ JOY_CENTER.set(e.clientX,e.clientY); clampJoyCenter(); positionHints(); }
  else if(joyActive){ joyVec = vecFromJoyPx(e.clientX,e.clientY); }
  e.preventDefault();
},{passive:false});
function endPtr(e){
  if(activeId!==e.pointerId) return;
  try{hud.releasePointerCapture(e.pointerId);}catch(_){}
  clearTimeout(holdTimer); relocating=false;

  // DAR toggle if quick tap
  if(!darRelocating && inDAR(e.clientX,e.clientY)){
    const heldMs = performance.now() - darPressT;
    if(heldMs < RELOCATE_HOLD_MS){ darOn = !darOn; }
  }
  clearTimeout(darHoldTimer); darRelocating=false;

  if(joyActive){ joyActive = false; joyVec.set(0,0); }
  activeId=null; e.preventDefault();
}
hud.addEventListener('pointerup',endPtr,{passive:false});
hud.addEventListener('pointercancel',endPtr,{passive:false});

/* Physics (independent caps for Pitch/Yaw) */
let w = new THREE.Vector3(0,0,0);
const STICK_DEADZONE = STICK_MIN;
const KP_ROLL = 3.2, KD_ROLL = 0.25;

function integrate(dt){
  // stick smoothing
  const a = 1 - Math.exp(-(dt*1000)/Math.max(1,STICK_TAU_MS));
  smJoy.lerp(joyVec, a);

  // screen → body; flip X so left on stick = left on face; flip Y sign for screen coords
  const jx =  smJoy.x/JOY_BASE_R;
  const jy = -smJoy.y/JOY_BASE_R;
  const mag = Math.hypot(jx,jy);

  // deadzone & curve
  let eff = Math.max(0, mag - STICK_DEADZONE) / (1 - STICK_DEADZONE);
  eff = Math.pow(eff, inputPow);
  const ux = (mag>0) ? (-jx/mag) : 0; // yaw unit (flipped X)
  const uy = (mag>0) ? ( jy/mag) : 0; // pitch unit

  // Face arrow (working mapping)
  if (faceArrow && faceTip){
    const show = eff > 0.02;
    faceArrow.visible = show; faceTip.visible = show;
    if (show){
      const lenMax = Math.min(BOX?.hx ?? 70, BOX?.hy ?? 28) * 0.95;
      const len = Math.max(10, lenMax * eff * (arrowScale||1));
      const zFace = (BOX?.hz ?? 120) + 0.6;

      const x2 =  ux * len;
      const y2 = -uy * len;   // draw flip

      const pos = faceArrow.geometry.attributes.position.array;
      pos[0]=0; pos[1]=0; pos[2]=zFace;
      pos[3]=x2; pos[4]=y2; pos[5]=zFace;
      faceArrow.geometry.attributes.position.needsUpdate = true;

      // color mapping: right=yellow, left=blue, up=red, down=green
      const col = (Math.abs(x2) > Math.abs(y2))
        ? (x2 >= 0 ? COL_LEFT : COL_RIGHT)
        : (uy >= 0 ? COL_DOWN : COL_UP);
      faceArrow.material.color.setHex(col);
      faceTip.material.color.setHex(col);

      faceTip.position.set(x2, y2, zFace);
      const ang = Math.atan2(x2, -y2) + Math.PI; // point outward
      faceTip.rotation.set(0, 0, ang);
      const s = 0.95 * (arrowScale||1);
      faceTip.scale.set(s, s, 1);
    }
  }

  // max accel (deg/s² → rad/s²)
  const maxAccelRad = (maxAccelDeg * Math.PI) / 180;

  // commanded angular accel in body axes
  const alpha = new THREE.Vector3(
    maxAccelRad * eff * uy,   // pitch (X)
    maxAccelRad * eff * ux,   // yaw (Y)
    0
  );

  // DAR roll controller (period 0 = off)
  let targetWz = 0;
  if (darOn && freeRollPeriod > 0){
    targetWz = airRoll * (2*Math.PI)/freeRollPeriod;
  }
  alpha.z = KP_ROLL*(targetWz - w.z) - KD_ROLL*w.z;

  // integrate ω
  w.addScaledVector(alpha, dt);

  // damping + extra brake when no stick & DAR off
  const noStick = eff < 0.02;
  const dampEff = (damp||0) + ((noStick && !darOn) ? (brakeOnRelease||0) : 0);
  const scale = Math.exp(-dampEff * dt);
  w.multiplyScalar(scale);

  // independent caps for pitch & yaw
  if (Math.abs(w.x) > wMaxPitch) w.x = Math.sign(w.x) * wMaxPitch;
  if (Math.abs(w.y) > wMaxYaw)   w.y = Math.sign(w.y)   * wMaxYaw;

  // global cap
  const wm = w.length();
  if (wm > wMax) w.multiplyScalar(wMax/(wm||1));

  // integrate quaternion
  const wx=w.x, wy=w.y, wz=w.z, halfdt=0.5*dt;
  const q=car.quaternion;
  const rw = - q.x*wx - q.y*wy - q.z*wz;
  const rx =   q.w*wx + q.y*wz - q.z*wy;
  const ry =   q.w*wy + q.z*wx - q.x*wz;
  const rz =   q.w*wz + q.x*wy - q.y*wx;
  q.w += rw*halfdt; q.x += rx*halfdt; q.y += ry*halfdt; q.z += rz*halfdt;
  q.normalize();
}

/* Camera zoom/orbit */
let orbitPhase=0;
function applyZoom(){
  const f = Math.max(0.7, Math.min(1.6, zoom||1));
  const dist = CAM_BASE.z / f;
  const h = CAM_BASE.y / f;
  if(!orbitOn){
    camera.position.set(0, h, dist);
    camera.lookAt(0, car ? car.position.y : 0, 0);
  }
}
function orbitStep(t){
  const f = Math.max(0.7, Math.min(1.6, zoom||1));
  const R = (CAM_BASE.z / f);
  const h = (CAM_BASE.y / f);
  const sp=0.35;
  const x = Math.sin(t*sp)*R;
  const z = Math.cos(t*sp)*R;
  camera.position.set(x, h, z);
  camera.lookAt(0, car ? car.position.y : 0, 0);
}

/* XYZ Gizmo */
const gizmoRect = document.getElementById('gizmoFrame').getBoundingClientRect();
const gizmoScene = new THREE.Scene();
const gizmoCam = new THREE.PerspectiveCamera(40, gizmoRect.width/gizmoRect.height, 0.1, 100);
gizmoCam.position.set(0,0,6);
const gizmoAxes = new THREE.AxesHelper(3.2);
gizmoScene.add(gizmoAxes);
const gizmoTarget = new THREE.Object3D();
gizmoScene.add(gizmoTarget);
gizmoAxes.position.copy(gizmoTarget.position);

/* Render HUD & loop */
function renderHUD(){ Hclear(); drawJoystick(); drawDAR(); }

let lastT = performance.now()/1000;
function tick(){
  const t = performance.now()/1000;
  const dt = Math.min(0.033, Math.max(0.001, t - lastT));
  lastT = t;

  if(orbitOn){ orbitPhase += dt; orbitStep(orbitPhase); }

  integrate(dt);

  renderer.setScissorTest(false);
  renderer.setViewport(0,0,innerWidth,innerHeight);
  renderer.render(scene, camera);

  if(car){
    gizmoTarget.quaternion.copy(car.quaternion);
    gizmoAxes.quaternion.copy(gizmoTarget.quaternion);
  }
  const gf = document.getElementById('gizmoFrame').getBoundingClientRect();
  const sx = Math.floor(gf.left), sy = Math.floor(innerHeight - gf.bottom);
  const sw = Math.floor(gf.width), sh = Math.floor(gf.height);
  renderer.setScissorTest(true);
  renderer.setScissor(sx,sy,sw,sh);
  renderer.setViewport(sx,sy,sw,sh);
  renderer.render(gizmoScene, gizmoCam);
  renderer.setScissorTest(false);

  renderHUD();
  requestAnimationFrame(tick);
}

/* Resize & boot */
function resize(){
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  sizeHud(); clampJoyCenter(); clampDARCenter(); positionHints(); applyZoom();
}
addEventListener('resize', resize);

/* ====== BOOT: try GLB then fallback (changed) ====== */
(async () => {
  try {
    await buildCarFromGLB("https://kronosdevoured.github.io/L4-dar-prototype/models/octane.glb?v=1", { targetLongest: 240, rotateY: Math.PI });
  } catch (e) {
    console.error("GLB failed; using placeholder:", e);
    buildCar(presets.placeholder, "placeholder");
  }
  setRoll(+1);
  positionHints();
  applyZoom();
  requestAnimationFrame(tick);
})();

</script>
</body>
</html>
