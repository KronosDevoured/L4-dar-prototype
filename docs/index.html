<!DOCTYPE html><html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>L4 â€” Blender-Style + XYZ Gizmo + DAR Toggle/Relocate (Optimized + brighter env + per-axis accel/Ï‰ caps)</title>
<style>
  html,body{margin:0;padding:0;height:100%;background:#fff;color:#0e0f12;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overscroll-behavior:none}
  :root{--bg-grad:linear-gradient(180deg,#f9fbff 0%,#f2f6fc 45%,#edf2f8 100%)}
  .theme-dark{--bg-grad:linear-gradient(180deg,#111318 0%,#0f1217 40%,#0d0f14 100%)}
  body{background:var(--bg-grad)}
  *,*:before,*:after{box-sizing:border-box} *{-webkit-user-select:none;user-select:none;-webkit-touch-callout:none}
  #gl,#hud{position:fixed;inset:0;display:block}
  #gl{z-index:0} #hud{z-index:1;touch-action:none}
  #menuBtn,#themeToggle{position:fixed;top:.6rem;z-index:3;width:44px;height:44px;border-radius:12px;border:1px solid #3a3d45;background:#181a20;box-shadow:0 2px 10px rgba(0,0,0,.25)}
  #menuBtn{right:.6rem;display:grid;place-items:center}
  #menuBtn .bar{display:block;width:20px;height:2px;background:#e8e8ea;margin:3px 0}
  #menuBtn.active{background:#06f;border-color:#4c8dff}
  #themeToggle{right:3.9rem;color:#e8e8ea;font-weight:700;cursor:pointer}
  #menuOverlay{position:fixed;inset:0;z-index:4;display:none;background:rgba(10,12,16,.45);backdrop-filter:blur(3px);overflow-x:hidden}
  #menuPanel{position:absolute;left:50%;top:12vh;transform:translateX(-50%);width:min(960px,calc(100vw - 2rem));max-height:76vh;overflow:auto;background:rgba(24,26,32,.96);color:#e8e8ea;border:1px solid #3a3d45;border-radius:14px;box-shadow:0 20px 60px rgba(0,0,0,.35)}
  .mp-header{position:sticky;top:0;background:rgba(24,26,32,.98);z-index:1;padding:.9rem clamp(.8rem,2vw,1rem);border-bottom:1px solid #33373f;display:flex;align-items:center;justify-content:space-between}
  .mp-title{font-weight:700;letter-spacing:.2px}
  .mp-close{border:1px solid #3a3d45;background:#181a20;color:#e8e8ea;border-radius:10px;padding:.35rem .6rem;font-weight:600}
  .mp-body{padding:clamp(.6rem,2vw,1rem);display:grid;grid-template-columns:1fr 1fr;gap:14px}
  @media (max-width:860px){.mp-body{grid-template-columns:1fr}}
  .card{background:#15171d;border:1px solid #33373f;border-radius:12px;padding:.9rem}
  .card h3{margin:.1rem 0 .7rem;font-size:1rem;opacity:.95}
  .row{display:flex;align-items:center;gap:.5rem;flex-wrap:wrap;margin:.45rem 0;width:100%}
  .btn{border:1px solid #3a3d45;padding:.45rem .7rem;border-radius:999px;background:#181a20;color:#e8e8ea;font-weight:600;letter-spacing:.2px;cursor:pointer}
  .btn.active{background:#06f;border-color:#4c8dff}
  .tag{background:#181a20;border:1px solid #3a3d45;padding:.25rem .5rem;border-radius:999px;font-size:.82rem;white-space:nowrap}
  .sl{display:flex;align-items:center;gap:.6rem;flex-wrap:nowrap;width:100%;min-width:0}
  .sl label{font-size:.88rem;opacity:.92;flex:0 0 150px;min-width:120px;max-width:220px}
  .sl input[type=range]{accent-color:#4c8dff;flex:1 1 auto;min-width:0}
  @media (max-width:520px){.sl{flex-wrap:wrap}.sl label,.sl input[type=range]{flex:1 0 100%}.sl .tag{margin-left:auto}}
  select{background:#181a20;color:#e8e8ea;border:1px solid #3a3d45;border-radius:10px;padding:.35rem .5rem;max-width:100%}
  #joyHint,#darHint{position:fixed;z-index:2;pointer-events:none;background:rgba(24,26,32,.92);border:1px solid #3a3d45;color:#cfd3dc;padding:.35rem .55rem;border-radius:10px;font-size:.85rem;white-space:nowrap;transform:translate(-50%,-50%);opacity:0;transition:opacity .25s}
  #joyHint.show,#darHint.show{opacity:1}
  #gizmoFrame{position:fixed;right:.6rem;top:64px;width:84px;height:84px;z-index:2;border-radius:10px;border:1px solid #3a3d45;background:rgba(24,26,32,.5);box-shadow:0 8px 24px rgba(0,0,0,.2);pointer-events:none}
</style>
</head>
<body>
  <canvas id="gl"></canvas>
  <canvas id="hud"></canvas>
  <div id="gizmoFrame"></div>
  <button id="themeToggle" type="button" title="Toggle light/dark">ðŸŒ™</button>
  <button id="menuBtn" type="button" title="Open Menu"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button>  <div id="menuOverlay">
    <div id="menuPanel">
      <div class="mp-header">
        <div class="mp-title">L4 Controls & Settings</div>
        <button class="mp-close" id="menuCloseBtn" type="button">Close</button>
      </div>
      <div class="mp-body">
        <div class="card">
          <h3>Rotation</h3>
          <div class="row">
            <button id="rollL" class="btn" type="button">Air Roll Right</button>
            <button id="rollR" class="btn active" type="button">Air Roll Left</button>
            <button id="restart" class="btn" type="button">Restart</button>
            <button id="orbit" class="btn" type="button">Orbit</button>
            <button id="lockPY" class="btn" type="button">Lock Pitch/Yaw</button>
            <span class="tag" id="lockPYTag">Off</span>
          </div>
          <div class="row sl">
            <label for="spinSlider">DAR Roll</label>
            <input id="spinSlider" type="range" min="0" max="3.0" step="0.01" value="1.20"/>
            <span class="tag" id="rollVal">1.20 s/rot</span>
          </div>
        </div><div class="card">
      <h3>Dynamics</h3>
      <div class="row sl"><label for="accelPitchRange">Pitch Accel (Â°/sÂ²)</label><input id="accelPitchRange" type="range" min="120" max="4000" step="10" value="255"/><span class="tag" id="accelPitchTag">255</span></div>
      <div class="row sl"><label for="accelYawRange">Yaw Accel (Â°/sÂ²)</label><input id="accelYawRange" type="range" min="120" max="4000" step="10" value="255"/><span class="tag" id="accelYawTag">255</span></div>
      <div class="row sl"><label for="curveRange">Input Curve</label><input id="curveRange" type="range" min="1.0" max="12.2" step="0.05" value="1.0"/><span class="tag" id="curveTag">1.00</span></div>
      <div class="row sl"><label for="dampRange">Damp</label><input id="dampRange" type="range" min="0.0" max="24.0" step="0.05" value="1.2"/><span class="tag" id="dampTag">1.20</span></div>
      <div class="row sl"><label for="brakeRange">Release Brake</label><input id="brakeRange" type="range" min="0.0" max="32.0" step="0.1" value="6.0"/><span class="tag" id="brakeTag">6.0</span></div>
      <div class="row sl"><label for="wmaxPitch">Max Pitch Ï‰</label><input id="wmaxPitch" type="range" min="4.0" max="34.0" step="0.5" value="8.5"/><span class="tag" id="wmaxPitchTag">8.5</span></div>
      <div class="row sl"><label for="wmaxYaw">Max Yaw Ï‰</label><input id="wmaxYaw" type="range" min="4.0" max="34.0" step="0.5" value="9.0"/><span class="tag" id="wmaxYawTag">9.0</span></div>
      <div class="row sl"><label for="wmaxRoll">Max Roll Ï‰</label><input id="wmaxRoll" type="range" min="4.0" max="34.0" step="0.5" value="12.0"/><span class="tag" id="wmaxRollTag">12.0</span></div>
    </div>

    <div class="card">
      <h3>Car</h3>
      <div class="row sl">
        <label for="presetSel">Body</label>
        <select id="presetSel">
          <option value="placeholder">Placeholder (140Ã—56Ã—240)</option>
          <option value="octane" selected>Octane proportions</option>
          <option value="dominus">Dominus proportions</option>
        </select>
      </div>
    </div>

    <div class="card">
      <h3>View & HUD</h3>
      <div class="row sl"><label for="zoomSlider">Zoom</label><input id="zoomSlider" type="range" min="0.70" max="1.60" step="0.01" value="1.00"/><span class="tag" id="zoomVal">1.00Ã—</span></div>
      <div class="row sl"><label for="stickSizeSlider">Stick Size</label><input id="stickSizeSlider" type="range" min="60" max="180" step="1" value="100"/><span class="tag" id="stickVal">100</span></div>
      <div class="row sl"><label for="arrowSlider">Arrow Size</label><input id="arrowSlider" type="range" min="0.60" max="4.00" step="0.01" value="4.00"/><span class="tag" id="arrowVal">4.00Ã—</span></div>
      <div class="row"><button id="spinStickBtn" class="btn" type="button">Spin Stick (follow roll)</button><span class="tag" id="spinStickTag">Off</span></div>
    </div>

    <div class="card">
      <h3>Gamepad</h3>
      <div class="row"><button id="gpEnable" class="btn active" type="button">Enable</button><span class="tag" id="gpStatus">Enabled (waiting for gamepad)</span></div>
      <div class="row sl"><label for="gpPreset">Preset</label><select id="gpPreset"><option value="ps5" selected>PS5 / DualSense</option><option value="xinput">Generic XInput</option></select></div>
      <div class="row"><button id="gpRemap" class="btn" type="button">Remap Actionâ€¦</button>
        <select id="gpAction"><option value="toggleDAR">Toggle DAR</option><option value="rollLeft">Air Roll Left</option><option value="rollRight">Air Roll Right</option><option value="restart">Restart</option><option value="orbitToggle">Toggle Orbit</option></select>
        <span class="tag" id="gpBindLabel">â€”</span></div>
      <div class="row" style="font-size:.86rem;opacity:.85;line-height:1.35;">Tip: Left stick moves the on-screen stick. Remap any action, then press a button or push an axis to bind.</div>
    </div>

  </div>
</div>

  </div>  <div id="joyHint">Hold outside the stick to reposition (UI hidden)</div>
  <div id="darHint">Tap to toggle roll â€¢ Hold to move</div><script type="module">
import * as THREE from "https://esm.sh/three@0.155.0";
import { GLTFLoader } from "https://esm.sh/three@0.155.0/examples/jsm/loaders/GLTFLoader.js";

const $ = id => document.getElementById(id);
const E = { gl:$("gl"), hud:$("hud"), giz:$("gizmoFrame"), theme:$("themeToggle"), menuBtn:$("menuBtn"), menuOL:$("menuOverlay"), menuClose:$("menuCloseBtn"), rollL:$("rollL"), rollR:$("rollR"), restart:$("restart"), orbit:$("orbit"), lockPY:$("lockPY"), lockPYTag:$("lockPYTag"), spinSlider:$("spinSlider"), rollVal:$("rollVal"), accelPitchRange:$("accelPitchRange"), accelPitchTag:$("accelPitchTag"), accelYawRange:$("accelYawRange"), accelYawTag:$("accelYawTag"), curveRange:$("curveRange"), curveTag:$("curveTag"), dampRange:$("dampRange"), dampTag:$("dampTag"), brakeRange:$("brakeRange"), brakeTag:$("brakeTag"), wmaxPitch:$("wmaxPitch"), wmaxPitchTag:$("wmaxPitchTag"), wmaxYaw:$("wmaxYaw"), wmaxYawTag:$("wmaxYawTag"), wmaxRoll:$("wmaxRoll"), wmaxRollTag:$("wmaxRollTag"), presetSel:$("presetSel"), zoomSlider:$("zoomSlider"), zoomVal:$("zoomVal"), stickSizeSlider:$("stickSizeSlider"), stickVal:$("stickVal"), arrowSlider:$("arrowSlider"), arrowVal:$("arrowVal"), spinStickBtn:$("spinStickBtn"), spinStickTag:$("spinStickTag"), gpEnable:$("gpEnable"), gpStatus:$("gpStatus"), gpPreset:$("gpPreset"), gpRemap:$("gpRemap"), gpAction:$("gpAction"), gpBindLabel:$("gpBindLabel"), joyHint:$("joyHint"), darHint:$("darHint") };

/* ====== Renderer / Scene / Camera ====== */
const renderer = new THREE.WebGLRenderer({canvas:E.gl, antialias:true});
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setPixelRatio(Math.min(devicePixelRatio,2));
renderer.setSize(innerWidth,innerHeight);
const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0xf3f6fb,900,2400);
const camera = new THREE.PerspectiveCamera(55,innerWidth/innerHeight,0.1,5000);
const CAM_BASE = {y:280,z:760};
camera.position.set(0,CAM_BASE.y,CAM_BASE.z); scene.add(camera);

/* Lights: brighter + sky fill */
renderer.toneMappingExposure = 1.6;
scene.add(new THREE.AmbientLight(0xffffff,1.6));
const hemi=new THREE.HemisphereLight(0xffffff,0xbcc3cf,0.65); scene.add(hemi);
const dir=new THREE.DirectionalLight(0xffffff,1.6); dir.position.set(-350,700,900); scene.add(dir);
const fill=new THREE.DirectionalLight(0xffffff,1.15); fill.position.set(600,300,-400); scene.add(fill);
const rim =new THREE.DirectionalLight(0xffffff,0.9); rim.position.set(-900,450,-700); scene.add(rim);

/* Grid */
const grid = new THREE.Group();
const gridMain = new THREE.GridHelper(2600,26,0xdfe5ee,0xE9EDF5);
Object.assign(gridMain.material,{opacity:.78,transparent:true});
grid.add(gridMain); grid.rotation.x = -Math.PI/2; grid.position.y = -160; scene.add(grid);

/* Theme */
const THEMES={light:{fog:0xf3f6fb,line:0xE9EDF5,center:0xdfe5ee,dark:false},dark:{fog:0x0e1014,line:0x1f232b,center:0x2a2e36,dark:true}};
const setGrid=(l,c)=>{const m=gridMain.material; (m.color?m:m[1]).color.setHex(l); if(m[0]) m[0].color.setHex(c)};
function applyTheme(name){const t=THEMES[name]||THEMES.light; document.body.classList.toggle('theme-dark',t.dark); (scene.fog?scene.fog:scene.fog=new THREE.Fog(t.fog,900,2400)).color.setHex(t.fog); setGrid(t.line,t.center); E.theme.textContent=(name==='dark')?'â˜€ï¸':'ðŸŒ™'; try{localStorage.setItem('l4_theme',name)}catch{}}
(function initTheme(){let v='light'; try{v=localStorage.getItem('l4_theme')||'light'}catch{} applyTheme(v)})();
E.theme?.addEventListener('click',()=>{applyTheme((localStorage.getItem('l4_theme')==='dark')?'light':'dark')});

/* Colors & Materials */
const COL={UP:0xff5c5c, RIGHT:0x4c8dff, DOWN:0x53d769, LEFT:0xffd166};
const MAT={ BODY:new THREE.MeshPhongMaterial({color:0xe6ebf3,shininess:50,specular:0x666}), GLASS:new THREE.MeshPhongMaterial({color:0xa3afbf,shininess:40,specular:0x222,transparent:true,opacity:.68}), ACC:new THREE.MeshPhongMaterial({color:0xd3dbe7,shininess:35,specular:0x222}), DARK:new THREE.MeshPhongMaterial({color:0xb3bcc9,shininess:28,specular:0x222}), EDGE:h=>new THREE.LineBasicMaterial({color:h}), TIREF:new THREE.MeshLambertMaterial({color:0x96a0ad}), TIREB:new THREE.MeshLambertMaterial({color:0x8a93a0}), HUB:new THREE.MeshBasicMaterial({color:0x5a6270}) };

/* Presets */
const PRESETS={ placeholder:{hx:70,hy:28,hz:120}, octane:{hx:85.65,hy:36.8,hz:120}, dominus:{hx:77.9,hy:29.3,hz:120} };

/* Car builder */
let car=null, BOX=null, faceArrow=null, faceTip=null; const FACE_OFFSET=0.0, FACE_EPS=0.05;
const disposeAll=o=>o.traverse?.(x=>{x.geometry&&x.geometry.dispose(); x.material&&x.material.dispose?.()});
function clearCar(){ if(!car) return; scene.remove(car); disposeAll(car); car=null; }
function addEdge(a,b,color){const geo=new THREE.BufferGeometry().setFromPoints([a,b]); car.add(new THREE.Line(geo,MAT.EDGE(color)));}
function addWheel(x,z,r=18,w=12){const g=new THREE.CylinderGeometry(r,r,w,16); const y=-BOX.hy-r*.55; const front=new THREE.Mesh(g,MAT.TIREF), back=new THREE.Mesh(g,MAT.TIREB); front.rotation.z=back.rotation.z=Math.PI/2; front.position.set(x,y,z+w/2); back.position.set(x,y,z-w/2); const hub=new THREE.Mesh(new THREE.CylinderGeometry(r*.35,r*.35,w*.6,10),MAT.HUB); hub.rotation.z=Math.PI/2; hub.position.set(x,y,z); const grp=new THREE.Group(); grp.add(back,front,hub); car.add(grp);}
const addBox=(w,h,d,y,z,mat)=>{const m=new THREE.Mesh(new THREE.BoxGeometry(w,h,d),mat); m.position.set(0,y,z); car.add(m)};
function addFlares(xw,zw,r=10,w=6){const hemi=new THREE.CylinderGeometry(r,r,w,10,1,false,0,Math.PI), y=-BOX.hy+r*.2; const flare=(px,pz,flip)=>{const f=new THREE.Mesh(hemi,MAT.ACC); f.rotation.z=Math.PI/2; f.rotation.y=flip?Math.PI:0; f.position.set(px,y,pz); car.add(f)}; flare(+xw+6,+zw,false); flare(-xw-6,+zw,true); flare(+xw+6,-zw,true); flare(-xw-6,-zw,false)}
function buildPlaceholderFancy(){const x=BOX.hx-10,z=BOX.hz*.68; addFlares(x,z,10,6); addBox(BOX.hx*1.0,BOX.hy*.9,BOX.hz*.55,BOX.hy*.65,-BOX.hz*.1,MAT.GLASS); addBox(BOX.hx*1.0,6,24,BOX.hy*.8,-BOX.hz*.95,MAT.ACC); addBox(BOX.hx*.9,10,18,-BOX.hy*.7,+BOX.hz*.98,MAT.DARK)}
function buildOctane(){const x=BOX.hx-6,z=BOX.hz*.64; [[+x,-z,19],[ -x,-z,19],[+x,+z,18],[-x,+z,18]].forEach(([px,pz,r])=>addWheel(px,pz,r,12)); addFlares(x,z,12,7); addBox(BOX.hx*.95,BOX.hy*1.1,BOX.hz*.60,BOX.hy*.85,-BOX.hz*.05,MAT.GLASS); addBox(BOX.hx*1.2,6,30,BOX.hy*.9,-BOX.hz*1.02,MAT.ACC); addBox(BOX.hx*.85,12,20,-BOX.hy*.6,+BOX.hz*1.02,MAT.DARK)}
function buildDominus(){const x=BOX.hx-8,z=BOX.hz*.70; [[+x,-z],[ -x,-z],[+x,+z],[-x,+z]].forEach(([px,pz])=>addWheel(px,pz,18,12)); addFlares(x,z,11,6); addBox(BOX.hx*1.05,BOX.hy*.75,BOX.hz*.75,BOX.hy*.6,-BOX.hz*.05,MAT.GLASS); addBox(BOX.hx*.9,5,18,BOX.hy*.72,-BOX.hz*1.0,MAT.ACC); addBox(BOX.hx*1.05,10,30,-BOX.hy*.55,+BOX.hz*1.05,MAT.DARK)}
function buildCar(boxDims,preset="placeholder"){ clearCar(); BOX=boxDims; car=new THREE.Group(); car.position.y=110; scene.add(car);
  car.add(new THREE.Mesh(new THREE.BoxGeometry(BOX.hx*2,BOX.hy*2,BOX.hz*2),MAT.BODY));
  ({octane:buildOctane,dominus:buildDominus,placeholder:buildPlaceholderFancy}[preset]||buildPlaceholderFancy)();
  const vFL=new THREE.Vector3(-BOX.hx,+BOX.hy,+BOX.hz), vFR=new THREE.Vector3(+BOX.hx,+BOX.hy,+BOX.hz), vBR=new THREE.Vector3(+BOX.hx,-BOX.hy,+BOX.hz), vBL=new THREE.Vector3(-BOX.hx,-BOX.hy,+BOX.hz);
  addEdge(vFR,vFL,COL.UP); addEdge(vBR,vFR,COL.LEFT); addEdge(vBL,vBR,COL.DOWN); addEdge(vFL,vBL,COL.RIGHT);
  const noseLen=BOX.hz*.55; const nose=new THREE.Line(new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0),new THREE.Vector3(0,0,noseLen)]), new THREE.LineBasicMaterial({color:COL.DOWN})); car.add(nose); const noseTip=new THREE.Mesh(new THREE.ConeGeometry(8,16,12), new THREE.MeshBasicMaterial({color:COL.DOWN})); noseTip.rotation.x=Math.PI/2; noseTip.position.z=noseLen+10; car.add(noseTip);
  const zFace=BOX.hz+FACE_OFFSET; const faceGeom=new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,zFace+FACE_EPS),new THREE.Vector3(0,0,zFace+FACE_EPS)]); faceArrow=new THREE.Line(faceGeom,new THREE.LineBasicMaterial({color:0x333333})); car.add(faceArrow); faceTip=new THREE.Mesh(new THREE.ConeGeometry(6,12,12), new THREE.MeshBasicMaterial({color:0x333333})); faceTip.position.set(0,0,zFace+FACE_EPS); car.add(faceTip); faceArrow.visible=faceTip.visible=false;
}
function applySpawnOrientation(){ if(!car) return; car.rotation.set(-Math.PI/2,0,Math.PI) }

/* HUD */
const H=(()=>{const c=E.hud.getContext('2d'); const api={clear(){c.setTransform(1,0,0,1,0,0); c.clearRect(0,0,E.hud.width,E.hud.height)}, circle(x,y,r,s,w){c.beginPath();c.lineWidth=w;c.strokeStyle=s;c.arc(x,y,r,0,Math.PI*2);c.stroke()}, fill(x,y,r,f){c.beginPath();c.fillStyle=f;c.arc(x,y,r,0,Math.PI*2);c.fill()}, arc(x,y,r,a1,a2,s,w){c.beginPath();c.lineWidth=w;c.strokeStyle=s;c.arc(x,y,r,a1,a2);c.stroke()}, line(x1,y1,x2,y2,s,w){c.beginPath();c.lineWidth=w;c.strokeStyle=s;c.moveTo(x1,y1);c.lineTo(x2,y2);c.stroke()}, tri(x,y,a,r,f){c.save();c.translate(x,y);c.rotate(a);c.beginPath();c.moveTo(0,-r);c.lineTo(r*.9,r*.9);c.lineTo(-r*.9,r*.9);c.closePath();c.fillStyle=f;c.fill();c.restore()}, ctx:c}; return api})();
function sizeHud(){E.hud.width=innerWidth; E.hud.height=innerHeight}
sizeHud();

/* Joystick + DAR */
let spinStick=false, stickAngle=0; let JOY_BASE_R=100, JOY_KNOB_R=Math.round(JOY_BASE_R*.32); let JOY_CENTER=new THREE.Vector2(126,innerHeight-170); let joyActive=false, joyVec=new THREE.Vector2(0,0), smJoy=new THREE.Vector2(0,0);
const STICK_TAU_MS=8, RELOCATE_HOLD_MS=250, STICK_MIN=0.02; let activeId=null, relocating=false, holdTimer=null; const COLS={UP:'#ff5c5c',RIGHT:'#4c8dff',DOWN:'#53d769',LEFT:'#ffd166'};
function drawJoystick(){const cx=JOY_CENTER.x, cy=JOY_CENTER.y, r=JOY_BASE_R; if(spinStick){H.ctx.save();H.ctx.translate(cx,cy);H.ctx.rotate(-stickAngle);H.ctx.translate(-cx,-cy)} const t=performance.now(), pulse=1+0.06*Math.sin(t*.008), halo=r*pulse+10; H.circle(cx,cy,halo,'rgba(76,141,255,0.28)',8); H.arc(cx,cy,r,-Math.PI/4, Math.PI/4,   COLS.RIGHT,12); H.arc(cx,cy,r, Math.PI/4, 3*Math.PI/4, COLS.UP,   12); H.arc(cx,cy,r, 3*Math.PI/4,5*Math.PI/4, COLS.LEFT, 12); H.arc(cx,cy,r, 5*Math.PI/4,7*Math.PI/4, COLS.DOWN, 12); H.circle(cx,cy,r-18,'#b9c1cd',2); H.line(cx-r+12,cy,cx+r-12,cy,'#cfd6e2',1.5); H.line(cx,cy-r+12,cx,cy+r-12,'#cfd6e2',1.5); const kx=cx+joyVec.x, ky=cy+joyVec.y; H.circle(kx,ky,JOY_KNOB_R,'#4c8dff',4); H.fill(kx,ky,JOY_KNOB_R,'#0f1116'); H.ctx.fillStyle='#222'; H.ctx.beginPath(); H.ctx.arc(cx,cy,3,0,Math.PI*2); H.ctx.fill(); if(spinStick){H.ctx.restore()}}
const inJoyLoose=(x,y)=>{const dx=x-JOY_CENTER.x, dy=y-JOY_CENTER.y, loose=JOY_BASE_R+28; return (dx*dx+dy*dy)<=loose*loose || (Math.abs(dx)<=JOY_BASE_R && Math.abs(dy)<=JOY_BASE_R+40)};
const vecFromJoyPx=(x,y)=>{let dx=x-JOY_CENTER.x, dy=y-JOY_CENTER.y, m=Math.hypot(dx,dy); if(m>JOY_BASE_R){const k=JOY_BASE_R/(m||1); dx*=k; dy*=k} return new THREE.Vector2(dx,dy)};
const clamp=(v,min,max)=>Math.max(min,Math.min(max,v));
function clampJoyCenter(){JOY_CENTER.x=clamp(JOY_CENTER.x,JOY_BASE_R+20,innerWidth -(JOY_BASE_R+20)); JOY_CENTER.y=clamp(JOY_CENTER.y,JOY_BASE_R+20,innerHeight-(JOY_BASE_R+20))}
let DAR_R=44, DAR_CENTER=new THREE.Vector2(innerWidth-120,innerHeight-150), darOn=false, darRelocating=false, darHoldTimer=null, darPressT=0;
function drawDAR(){const cx=DAR_CENTER.x, cy=DAR_CENTER.y, r=DAR_R; H.fill(cx,cy,r, darOn?'rgba(0,102,255,0.18)':'rgba(24,26,32,0.75)'); H.circle(cx,cy,r, darOn?'#4c8dff':'#3a3d45', darOn?5:3); const a=(airRoll>0)?Math.PI/2:-Math.PI/2; H.tri(cx,cy,a,r*.55, darOn?'#0e0f12':'#e8e8ea'); H.circle(cx,cy,r-12,'#bdbdbd',1.5)}
const inDAR=(x,y)=>{const dx=x-DAR_CENTER.x, dy=y-DAR_CENTER.y; return (dx*dx+dy*dy)<=DAR_R*DAR_R};
function clampDARCenter(){const m=DAR_R+20; DAR_CENTER.x=clamp(DAR_CENTER.x,m,innerWidth-m); DAR_CENTER.y=clamp(DAR_CENTER.y,m,innerHeight-m)}
function showHint(el,ms){el.classList.add('show'); setTimeout(()=>el.classList.remove('show'),ms)}
function positionHints(){E.joyHint.style.left=(JOY_CENTER.x+JOY_BASE_R+18)+'px';E.joyHint.style.top=(JOY_CENTER.y-JOY_BASE_R-18)+'px';E.darHint.style.left=(DAR_CENTER.x+DAR_R+18)+'px';E.darHint.style.top=(DAR_CENTER.y-DAR_R-18)+'px'}

/* Menu */
let chromeShown=false; const openMenu=()=>{chromeShown=true;E.menuBtn.classList.add('active');E.menuOL.style.display='block'}; const closeMenu=()=>{chromeShown=false;E.menuBtn.classList.remove('active');E.menuOL.style.display='none'};
E.menuBtn.addEventListener('click',()=>chromeShown?closeMenu():openMenu()); E.menuClose.addEventListener('click',closeMenu); E.menuOL.addEventListener('click',e=>{if(e.target===E.menuOL) closeMenu()});

/* Buttons/toggles */
let airRoll=-1, lockPitchYaw=false; const setRoll=d=>{airRoll=d; E.rollL.classList.toggle('active',d>0); E.rollR.classList.toggle('active',d<0)};
E.rollL.addEventListener('click',()=>setRoll(+1)); E.rollR.addEventListener('click',()=>setRoll(-1));
E.lockPY.addEventListener('click',()=>{lockPitchYaw=!lockPitchYaw; E.lockPY.classList.toggle('active',lockPitchYaw); E.lockPYTag.textContent=lockPitchYaw?'On':'Off'});
function resetSim(){ if(car) car.quaternion.identity(); applySpawnOrientation(); w.set(0,0,0); stickAngle=0; orbitOn=false; E.orbit.classList.remove('active'); orbitPhase=0; camera.position.set(0,220,650); camera.lookAt(0,0,0); if(faceArrow) faceArrow.visible=false; if(faceTip) faceTip.visible=false }
E.restart.addEventListener('click',resetSim);
let orbitOn=false; E.orbit.addEventListener('click',()=>{orbitOn=!orbitOn; E.orbit.classList.toggle('active',orbitOn)})

/* Sliders/selects */
let maxAccelPitchDeg=+E.accelPitchRange.value, maxAccelYawDeg=+E.accelYawRange.value,
    inputPow=+E.curveRange.value, damp=+E.dampRange.value, brakeOnRelease=+E.brakeRange.value,
    wMaxPitch=+E.wmaxPitch.value, wMaxYaw=+E.wmaxYaw.value, wMaxRoll=+E.wmaxRoll.value,
    freeRollPeriod=+E.spinSlider.value, zoom=+E.zoomSlider.value, arrowScale=+E.arrowSlider.value;
function syncTags(){
  E.accelPitchTag.textContent=maxAccelPitchDeg.toFixed(0);
  E.accelYawTag.textContent=maxAccelYawDeg.toFixed(0);
  E.curveTag.textContent=inputPow.toFixed(2);
  E.dampTag.textContent=damp.toFixed(2);
  E.brakeTag.textContent=brakeOnRelease.toFixed(1);
  E.wmaxPitchTag.textContent=wMaxPitch.toFixed(1);
  E.wmaxYawTag.textContent=wMaxYaw.toFixed(1);
  E.wmaxRollTag.textContent=wMaxRoll.toFixed(1);
  E.rollVal.textContent=(freeRollPeriod>0)?`${freeRollPeriod.toFixed(2)} s/rot`:'off';
  E.stickVal.textContent=String(Math.round(JOY_BASE_R));
  E.zoomVal.textContent=`${(zoom||1).toFixed(2)}Ã—`;
  E.arrowVal.textContent=`${(arrowScale||1).toFixed(2)}Ã—`;
  E.spinStickTag.textContent=spinStick?'On':'Off'
}
const sliderHooks={
  accelPitchRange:v=>maxAccelPitchDeg=v,
  accelYawRange:v=>maxAccelYawDeg=v,
  curveRange:v=>inputPow=v,
  dampRange:v=>damp=v,
  brakeRange:v=>brakeOnRelease=v,
  wmaxPitch:v=>wMaxPitch=v,
  wmaxYaw:v=>wMaxYaw=v,
  wmaxRoll:v=>wMaxRoll=v,
  spinSlider:v=>freeRollPeriod=v,
  stickSizeSlider:v=>{JOY_BASE_R=parseInt(v,10)||100; JOY_KNOB_R=Math.round(JOY_BASE_R*.32); clampJoyCenter(); positionHints()},
  zoomSlider:v=>{zoom=v; applyZoom()},
  arrowSlider:v=>{arrowScale=v}
};
Object.entries(sliderHooks).forEach(([id,fn])=>$(id).addEventListener('input',e=>{fn(parseFloat(e.target.value)||0); syncTags()}));
E.presetSel.addEventListener('change',()=>{const name=E.presetSel.value; buildCar(PRESETS[name],name); car.quaternion.identity(); w.set(0,0,0); stickAngle=0; applySpawnOrientation()});
E.spinStickBtn.addEventListener('click',()=>{spinStick=!spinStick; E.spinStickBtn.classList.toggle('active',spinStick); syncTags()});

/* Pointer handlers */
E.hud.addEventListener('pointerdown',e=>{try{E.hud.setPointerCapture(e.pointerId)}catch{} activeId=e.pointerId; if(inDAR(e.clientX,e.clientY)){darPressT=performance.now(); clearTimeout(darHoldTimer); darHoldTimer=setTimeout(()=>{if(activeId===e.pointerId){darRelocating=true; showHint(E.darHint,2000)}},RELOCATE_HOLD_MS); e.preventDefault(); return} if(inJoyLoose(e.clientX,e.clientY)){joyActive=true; joyVec=vecFromJoyPx(e.clientX,e.clientY)} else if(!chromeShown){clearTimeout(holdTimer); holdTimer=setTimeout(()=>{if(activeId===e.pointerId && !chromeShown){relocating=true; showHint(E.joyHint,1800)}},RELOCATE_HOLD_MS)} e.preventDefault()},{passive:false});
E.hud.addEventListener('pointermove',e=>{if(activeId!==e.pointerId) return; if(darRelocating){DAR_CENTER.set(e.clientX,e.clientY); clampDARCenter(); positionHints()} else if(relocating){JOY_CENTER.set(e.clientX,e.clientY); clampJoyCenter(); positionHints()} else if(joyActive){joyVec=vecFromJoyPx(e.clientX,e.clientY)} e.preventDefault()},{passive:false});
function endPtr(e){ if(activeId!==e.pointerId) return; try{E.hud.releasePointerCapture(e.pointerId)}catch{} clearTimeout(holdTimer); relocating=false; if(!darRelocating && inDAR(e.clientX,e.clientY)){ if(performance.now()-darPressT<RELOCATE_HOLD_MS) darOn=!darOn } clearTimeout(darHoldTimer); darRelocating=false; if(joyActive){joyActive=false; joyVec.set(0,0)} activeId=null; e.preventDefault() }
E.hud.addEventListener('pointerup',endPtr,{passive:false}); E.hud.addEventListener('pointercancel',endPtr,{passive:false});

/* Gamepad */
let gpEnabled=true, gpIndex=-1, gpRemapping=false, gpPrevActionPressed={}; const GP_DEADZONE=.15;
let gpBindings={ toggleDAR:{kind:'button',index:1}, rollLeft:{kind:'button',index:4}, rollRight:{kind:'button',index:5}, restart:{kind:'button',index:9}, orbitToggle:{kind:'button',index:2} };
const GP_PRESETS={ ps5:gpBindings, xinput:{...gpBindings} };
const bindLabel=b=>!b?'â€”':(b.kind==='button'?`Button ${b.index}`:`Axis ${b.axis}${b.dir>0?'+':'âˆ’'}`);
function setBindingPreset(name){gpBindings=JSON.parse(JSON.stringify(GP_PRESETS[name]||GP_PRESETS.ps5)); E.gpBindLabel.textContent=bindLabel(gpBindings[E.gpAction.value])}
E.gpEnable.addEventListener('click',()=>{gpEnabled=!gpEnabled; E.gpEnable.classList.toggle('active',gpEnabled); E.gpStatus.textContent=gpEnabled?'Enabled':'Disabled'});
E.gpPreset.addEventListener('change',()=>setBindingPreset(E.gpPreset.value));
E.gpAction.addEventListener('change',()=>{E.gpBindLabel.textContent=bindLabel(gpBindings[E.gpAction.value])});
E.gpRemap.addEventListener('click',()=>{gpRemapping=true; E.gpBindLabel.textContent='Press button / move axisâ€¦'});
addEventListener('gamepadconnected',e=>{if(gpIndex<0) gpIndex=e.gamepad.index; E.gpStatus.textContent=`Connected: ${e.gamepad.id}`});
addEventListener('gamepaddisconnected',e=>{if(e.gamepad.index===gpIndex) gpIndex=-1; E.gpStatus.textContent=gpEnabled?'Enabled (waiting for gamepad)':'No gamepad'});
function pads(){const arr=navigator.getGamepads?.()||[]; if(gpIndex<0){for(let i=0;i<arr.length;i++){const p=arr[i]; if(p && p.mapping==='standard'){gpIndex=i; break}}} return arr[gpIndex]||null}
const pressed=(pad,b)=>b && pad && (b.kind==='button' ? ((pad.buttons[b.index]?.value||0)>0.5) : ((pad.axes[b.axis]||0)*(b.dir>0?1:-1)>0.6));
function exec(action){switch(action){case 'toggleDAR': darOn=!darOn; break; case 'rollLeft': setRoll(-1); break; case 'rollRight': setRoll(+1); break; case 'restart': resetSim(); break; case 'orbitToggle': orbitOn=!orbitOn; E.orbit.classList.toggle('active',orbitOn); break}}
function handleRemap(pad){if(!gpRemapping||!pad) return; for(let i=0;i<pad.buttons.length;i++){if((pad.buttons[i]?.value||0)>0.5){gpBindings[E.gpAction.value]={kind:'button',index:i}; gpRemapping=false; E.gpBindLabel.textContent=bindLabel(gpBindings[E.gpAction.value]); return}} for(let a=0;a<pad.axes.length;a++){const v=pad.axes[a]||0; if(Math.abs(v)>0.6){gpBindings[E.gpAction.value]={kind:'axis',axis:a,dir:(v>0?+1:-1)}; gpRemapping=false; E.gpBindLabel.textContent=bindLabel(gpBindings[E.gpAction.value]); return}}}
function updatePad(){ if(!gpEnabled) return; const pad=pads(); if(!pad){E.gpStatus.textContent='Enabled (waiting for gamepad)'; return} E.gpStatus.textContent=`Connected: ${pad.id}`; if(gpRemapping) handleRemap(pad); if(!joyActive && !relocating && !darRelocating){ const lx=pad.axes[0]||0, ly=pad.axes[1]||0, m=Math.hypot(lx,ly); let nx=0, ny=0; if(m>GP_DEADZONE){const k=(m-GP_DEADZONE)/(1-GP_DEADZONE); nx=(lx/(m||1))*k; ny=(ly/(m||1))*k} joyVec.set(nx*JOY_BASE_R,ny*JOY_BASE_R)} for(const a of Object.keys(gpBindings)){const now=pressed(pad,gpBindings[a]), was=!!gpPrevActionPressed[a]; if(now && !was) exec(a); gpPrevActionPressed[a]=now} }
setBindingPreset('ps5');

/* Physics: per-axis accel + per-axis Ï‰ caps. No global |Ï‰| cap. */
let w=new THREE.Vector3(0,0,0); const STICK_DEADZONE=STICK_MIN, KP_ROLL=3.2, KD_ROLL=0.25;
function integrate(dt){
  const a=1-Math.exp(-(dt*1000)/Math.max(1,STICK_TAU_MS));
  smJoy.lerp(joyVec,a);
  const jx= smJoy.x/JOY_BASE_R, jy=-smJoy.y/JOY_BASE_R, mag=Math.hypot(jx,jy);
  let eff=Math.max(0,mag-STICK_DEADZONE)/(1-STICK_DEADZONE); eff=Math.pow(eff,inputPow);
  const ux=(mag>0)?(-jx/mag):0, uy=(mag>0)?(jy/mag):0;
  if(faceArrow&&faceTip){const show=eff>0.02; faceArrow.visible=faceTip.visible=show; if(show){const lenMax=Math.min(BOX.hx,BOX.hy)*.95, len=Math.max(10,lenMax*eff*(arrowScale||1)), zFace=BOX.hz+FACE_OFFSET, x2=ux*len, y2=-uy*len, pos=faceArrow.geometry.attributes.position.array; pos[0]=0;pos[1]=0;pos[2]=zFace+FACE_EPS; pos[3]=x2;pos[4]=y2;pos[5]=zFace+FACE_EPS; faceArrow.geometry.attributes.position.needsUpdate=true; const col=(Math.abs(x2)>Math.abs(y2))?(x2>=0?COL.LEFT:COL.RIGHT):(uy>=0?COL.DOWN:COL.UP); faceArrow.material.color.setHex(col); faceTip.material.color.setHex(col); faceTip.position.set(x2,y2,zFace+FACE_EPS); const ang=Math.atan2(x2,-y2)+Math.PI; faceTip.rotation.set(0,0,ang); const s=.95*(arrowScale||1); faceTip.scale.set(s,s,1)}}
  const maxAccelPitchRad=(maxAccelPitchDeg*Math.PI)/180;
  const maxAccelYawRad  =(maxAccelYawDeg*Math.PI)/180;
  const alpha=new THREE.Vector3(
    lockPitchYaw ? 0 : (maxAccelPitchRad*eff*uy),
    lockPitchYaw ? 0 : (maxAccelYawRad  *eff*ux),
    0
  );
  let targetWz=0; if(darOn && freeRollPeriod>0) targetWz=airRoll*(2*Math.PI)/freeRollPeriod;
  alpha.z=KP_ROLL*(targetWz-w.z)-KD_ROLL*w.z;
  w.addScaledVector(alpha,dt);
  const noStick=eff<0.02, dampEff=(damp||0)+((noStick && !darOn)?(brakeOnRelease||0):0), scale=Math.exp(-dampEff*dt);
  w.multiplyScalar(scale);
  if(Math.abs(w.x)>wMaxPitch) w.x=Math.sign(w.x)*wMaxPitch;
  if(Math.abs(w.y)>wMaxYaw)   w.y=Math.sign(w.y)*wMaxYaw;
  if(Math.abs(w.z)>wMaxRoll)  w.z=Math.sign(w.z)*wMaxRoll;
  const {x:wx,y:wy,z:wz}=w, halfdt=.5*dt, q=car.quaternion;
  const rw=-q.x*wx-q.y*wy-q.z*wz, rx=q.w*wx+q.y*wz-q.z*wy, ry=q.w*wy+q.z*wx-q.x*wz, rz=q.w*wz+q.x*wy-q.y*wx;
  q.w+=rw*halfdt; q.x+=rx*halfdt; q.y+=ry*halfdt; q.z+=rz*halfdt; q.normalize();
  if(spinStick) stickAngle+=w.z*dt
}

/* Camera */
let orbitPhase=0; function applyZoom(){const f=Math.max(.7,Math.min(1.6,zoom||1)), dist=CAM_BASE.z/f, h=CAM_BASE.y/f; if(!orbitOn){camera.position.set(0,h,dist); camera.lookAt(0,car?car.position.y:0,0)}}
function orbitStep(t){const f=Math.max(.7,Math.min(1.6,zoom||1)), R=(CAM_BASE.z/f), h=(CAM_BASE.y/f), sp=.35; const x=Math.sin(t*sp)*R, z=Math.cos(t*sp)*R; camera.position.set(x,h,z); camera.lookAt(0,car?car.position.y:0,0)}

/* Gizmo */
const gizmoScene=new THREE.Scene(); const gizmoCam=new THREE.PerspectiveCamera(40,E.giz.clientWidth/E.giz.clientHeight,0.1,100); gizmoCam.position.set(0,0,6); const gizmoAxes=new THREE.AxesHelper(3.2); gizmoScene.add(gizmoAxes); const gizmoTarget=new THREE.Object3D(); gizmoScene.add(gizmoTarget); gizmoAxes.position.copy(gizmoTarget.position);

/* Loop */
function renderHUD(){H.clear(); drawJoystick(); drawDAR()}
let lastT=performance.now()/1000;
function tick(){ const t=performance.now()/1000, dt=Math.min(.033,Math.max(.001,t-lastT)); lastT=t; if(orbitOn){orbitPhase+=dt; orbitStep(orbitPhase)} updatePad(); integrate(dt); renderer.setScissorTest(false); renderer.setViewport(0,0,innerWidth,innerHeight); renderer.render(scene,camera); if(car){gizmoTarget.quaternion.copy(car.quaternion); gizmoAxes.quaternion.copy(gizmoTarget.quaternion)} const gf=E.giz.getBoundingClientRect(), sx=Math.floor(gf.left), sy=Math.floor(innerHeight-gf.bottom), sw=Math.floor(gf.width), sh=Math.floor(gf.height); renderer.setScissorTest(true); renderer.setScissor(sx,sy,sw,sh); renderer.setViewport(sx,sy,sw,sh); renderer.render(gizmoScene,gizmoCam); renderer.setScissorTest(false); renderHUD(); requestAnimationFrame(tick) }

/* Resize */
function resize(){renderer.setSize(innerWidth,innerHeight); camera.aspect=innerWidth/innerHeight; camera.updateProjectionMatrix(); sizeHud(); clampJoyCenter(); clampDARCenter(); positionHints(); applyZoom()}
addEventListener('resize',resize);

/* GLB swap */
const gltfLoader=new GLTFLoader();
function clearCarMeshesKeepGadgets(){ if(!car) return; const keep=new Set([faceArrow,faceTip]); const rm=[]; car.children.forEach(ch=>{if(!keep.has(ch)) rm.push(ch)}); rm.forEach(ch=>{car.remove(ch); disposeAll(ch)}) }
function swapInGLB(path="./models/octane.glb"){ gltfLoader.load(path,(gltf)=>{ const model=gltf.scene||gltf.scenes?.[0]; if(!model) return; const preBox=new THREE.Box3().setFromObject(model), preSize=preBox.getSize(new THREE.Vector3()), preCtr=preBox.getCenter(new THREE.Vector3()); model.position.sub(preCtr); if(preSize.x>preSize.z*1.2) model.rotation.y=-Math.PI/2; const targetLongest=BOX?Math.max(BOX.hx*2,BOX.hy*2,BOX.hz*2):240, glbLongest=Math.max(preSize.x,preSize.y,preSize.z)||1, s=targetLongest/glbLongest; model.scale.setScalar(s); clearCarMeshesKeepGadgets(); car.add(model); const box=new THREE.Box3().setFromObject(model), sz=box.getSize(new THREE.Vector3()); BOX={hx:sz.x/2,hy:sz.y/2,hz:sz.z/2}; if(faceArrow&&faceTip){const zFace=BOX.hz+FACE_OFFSET, pos=faceArrow.geometry.attributes.position.array; pos[0]=0;pos[1]=0;pos[2]=zFace+FACE_EPS; pos[3]=0;pos[4]=0;pos[5]=zFace+FACE_EPS; faceArrow.geometry.attributes.position.needsUpdate=true; faceTip.position.set(0,0,zFace+FACE_EPS)} applySpawnOrientation() }, undefined,(err)=>console.error("[GLB] load failed:",err)) }

/* Boot */
buildCar(PRESETS.octane,'octane'); applySpawnOrientation(); setRoll(-1); positionHints(); applyZoom(); swapInGLB(); requestAnimationFrame(tick);
</script></body>
</html>
