<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>L4 — Blender-Style + XYZ Gizmo + DAR Toggle/Relocate</title>
<style>
  /* === CSS BASE START === */
  html,body{
    margin:0;padding:0;height:100%;
    background:#ffffff; /* fallback; actual bg via var below */
    color:#0e0f12;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;
    overscroll-behavior:none;
  }

  /* Theme vars */
  :root{
    --bg-grad: linear-gradient(180deg,#f6f7fb 0%,#eef1f6 45%,#e9edf3 100%); /* light */
  }
  .theme-dark{
    --bg-grad: linear-gradient(180deg,#111318 0%, #0f1217 40%, #0d0f14 100%); /* dark */
  }
  body{ background: var(--bg-grad); }

  *, *::before, *::after{ box-sizing:border-box }
  *{ user-select:none; -webkit-user-select:none; -ms-user-select:none; -webkit-touch-callout:none }
  #gl{ position:fixed; inset:0; z-index:0; display:block }
  #hud{ position:fixed; inset:0; z-index:1; display:block; touch-action:none }
  /* === CSS BASE END === */

  /* === HAMBURGER === */
  #menuBtn{
    position:fixed;top:.6rem;right:.6rem;z-index:3;width:44px;height:44px;
    border-radius:12px;border:1px solid #3a3d45;background:#181a20;display:grid;place-items:center;
    box-shadow:0 2px 10px rgba(0,0,0,.25)
  }
  #menuBtn .bar{display:block;width:20px;height:2px;background:#e8e8ea;margin:3px 0}
  #menuBtn.active{background:#0066ff;border-color:#4c8dff}

  /* Theme toggle */
  #themeToggle{
    position:fixed;top:.6rem;right:3.9rem;z-index:3;width:44px;height:44px;
    border-radius:12px;border:1px solid #3a3d45;background:#181a20;
    color:#e8e8ea;font-weight:700;box-shadow:0 2px 10px rgba(0,0,0,.25);
    cursor:pointer;
  }

  /* === OVERLAY MENU PANEL === */
  #menuOverlay{
    position:fixed; inset:0; z-index:4; display:none;
    background:rgba(10,12,16,0.45); backdrop-filter: blur(3px);
    overflow-x:hidden;
  }
  #menuPanel{
    position:absolute; left:50%; top:12vh; transform:translateX(-50%);
    width:min(960px, calc(100vw - 2rem)); max-height:76vh; overflow:auto;
    background:rgba(24,26,32,.96); color:#e8e8ea; border:1px solid #3a3d45; border-radius:14px;
    box-shadow:0 20px 60px rgba(0,0,0,.35);
    overflow-x:hidden;
  }
  .mp-header{
    position:sticky; top:0; background:rgba(24,26,32,.98); z-index:1;
    padding:.9rem clamp(.8rem, 2vw, 1rem); border-bottom:1px solid #33373f; display:flex; align-items:center; justify-content:space-between;
  }
  .mp-title{font-weight:700;letter-spacing:.2px}
  .mp-close{border:1px solid #3a3d45;background:#181a20;color:#e8e8ea;border-radius:10px;padding:.35rem .6rem;font-weight:600}
  .mp-body{
    padding:clamp(.6rem,2vw,1rem);
    display:grid; grid-template-columns: 1fr 1fr; gap:14px;
  }
  @media (max-width: 860px){ .mp-body{grid-template-columns: 1fr;} }

  .card{
    background:#15171d; border:1px solid #33373f; border-radius:12px; padding:.9rem;
  }
  .card h3{margin:.1rem 0 .7rem; font-size:1rem; opacity:.95}
  .row{display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; margin:.45rem 0; width:100%;}
  .btn{border:1px solid #3a3d45;padding:.45rem .7rem;border-radius:999px;background:#181a20;color:#e8e8ea;font-weight:600;letter-spacing:.2px;cursor:pointer}
  .btn.active{background:#0066ff;border-color:#4c8dff}
  .tag{background:#181a20;border:1px solid #3a3d45;padding:.25rem .5rem;border-radius:999px;font-size:.82rem;white-space:nowrap}

  .sl{
    display:flex; align-items:center; gap:.6rem; flex-wrap:nowrap;
    width:100%; min-width:0;
  }
  .sl label{
    font-size:.88rem; opacity:.92; flex:0 0 150px; min-width:120px; max-width:220px;
  }
  .sl input[type=range]{
    accent-color:#4c8dff;
    flex:1 1 auto; min-width:0; max-width:100%; width:100%;
  }
  .sl .tag{flex:0 0 auto}

  @media (max-width:520px){
    .sl{flex-wrap:wrap}
    .sl label{flex:1 0 100%}
    .sl input[type=range]{flex:1 0 100%}
    .sl .tag{margin-left:auto}
  }

  select{background:#181a20;color:#e8e8ea;border:1px solid #3a3d45;border-radius:10px;padding:.35rem .5rem;max-width:100%}

  /* Hints (stick/DAR) */
  #joyHint,#darHint{position:fixed; z-index:2; pointer-events:none;background:rgba(24,26,32,.92); border:1px solid #3a3d45; color:#cfd3dc;
    padding:.35rem .55rem; border-radius:10px; font-size:.85rem; white-space:nowrap; transform:translate(-50%,-50%); opacity:0; transition:opacity .25s ease;}
  #joyHint.show,#darHint.show{opacity:1;}

  /* XYZ gizmo frame */
  #gizmoFrame{
    position:fixed; right:.6rem; top:64px; width:84px; height:84px; z-index:2;
    border-radius:10px; border:1px solid #3a3d45; background:rgba(24,26,32,.5);
    box-shadow:0 8px 24px rgba(0,0,0,.2); pointer-events:none;
  }
</style>
</head>
<body>
  <!-- CANVASES -->
  <canvas id="gl"></canvas>
  <canvas id="hud"></canvas>
  <div id="gizmoFrame"></div>

  <!-- THEME TOGGLE -->
  <button id="themeToggle" type="button" title="Toggle light/dark">🌙</button>

  <!-- HAMBURGER -->
  <button id="menuBtn" type="button" title="Open Menu"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button>

  <!-- OVERLAY MENU -->
  <div id="menuOverlay">
    <div id="menuPanel">
      <div class="mp-header">
        <div class="mp-title">L4 Controls & Settings</div>
        <button class="mp-close" id="menuCloseBtn" type="button">Close</button>
      </div>
      <div class="mp-body">

        <!-- Rotation -->
        <div class="card">
          <h3>Rotation</h3>
          <div class="row">
            <button id="rollL" class="btn" type="button">Air Roll Right</button>
            <button id="rollR" class="btn active" type="button">Air Roll Left</button>
            <button id="restart" class="btn" type="button">Restart</button>
            <button id="orbit" class="btn" type="button">Orbit</button>
          </div>

          <div class="row sl">
            <label for="spinSlider">DAR Roll</label>
            <input id="spinSlider" type="range" min="0" max="3.0" step="0.01" value="1.20"/>
            <span class="tag" id="rollVal">1.20 s/rot</span>
          </div>

          <div class="row" style="font-size:.86rem;opacity:.85;line-height:1.35;">
            Tip: With <b>Air Roll Right</b>, rotate the stick clockwise. With <b>Air Roll Left</b>, rotate the stick counter-clockwise.
          </div>
        </div>

        <!-- Dynamics -->
        <div class="card">
          <h3>Dynamics</h3>

          <div class="row sl">
            <label for="accelRange">Max Accel (°/s²)</label>
            <input id="accelRange" type="range" min="120" max="1200" step="5" value="255"/>
            <span class="tag" id="accelTag">255</span>
          </div>

          <div class="row sl">
            <label for="curveRange">Input Curve</label>
            <input id="curveRange" type="range" min="1.0" max="2.2" step="0.05" value="1.0"/>
            <span class="tag" id="curveTag">1.00</span>
          </div>

          <div class="row sl">
            <label for="dampRange">Damp</label>
            <input id="dampRange" type="range" min="0.0" max="1.2" step="0.05" value="1.2"/>
            <span class="tag" id="dampTag">1.20</span>
          </div>

          <div class="row sl">
            <label for="brakeRange">Release Brake</label>
            <input id="brakeRange" type="range" min="0.0" max="6.0" step="0.1" value="6.0"/>
            <span class="tag" id="brakeTag">6.0</span>
          </div>

          <div class="row sl">
            <label for="wmaxRange">Max ω (global)</label>
            <input id="wmaxRange" type="range" min="6.0" max="24.0" step="0.5" value="6.0"/>
            <span class="tag" id="wmaxTag">6.0</span>
          </div>

          <div class="row sl">
            <label for="wmaxPitch">Max Pitch ω</label>
            <input id="wmaxPitch" type="range" min="4.0" max="24.0" step="0.5" value="8.5"/>
            <span class="tag" id="wmaxPitchTag">8.5</span>
          </div>

          <div class="row sl">
            <label for="wmaxYaw">Max Yaw ω</label>
            <input id="wmaxYaw" type="range" min="4.0" max="24.0" step="0.5" value="9.0"/>
            <span class="tag" id="wmaxYawTag">9.0</span>
          </div>
        </div>

        <!-- Car -->
        <div class="card">
          <h3>Car</h3>
          <div class="row sl">
            <label for="presetSel">Body</label>
            <select id="presetSel">
              <option value="placeholder">Placeholder (140×56×240)</option>
              <option value="octane" selected>Octane proportions</option>
              <option value="dominus">Dominus proportions</option>
            </select>
          </div>
        </div>

        <!-- View & HUD -->
        <div class="card">
          <h3>View & HUD</h3>

          <div class="row sl">
            <label for="zoomSlider">Zoom</label>
            <input id="zoomSlider" type="range" min="0.70" max="1.60" step="0.01" value="1.00" />
            <span class="tag" id="zoomVal">1.00×</span>
          </div>

          <div class="row sl">
            <label for="stickSizeSlider">Stick Size</label>
            <input id="stickSizeSlider" type="range" min="60" max="180" step="1" value="100" />
            <span class="tag" id="stickVal">100</span>
          </div>

          <div class="row sl">
            <label for="arrowSlider">Arrow Size</label>
            <input id="arrowSlider" type="range" min="0.60" max="4.00" step="0.01" value="4.00" />
            <span class="tag" id="arrowVal">4.00×</span>
          </div>
        </div>

        <!-- Gamepad -->
        <div class="card">
          <h3>Gamepad</h3>
          <div class="row">
            <button id="gpEnable" class="btn active" type="button">Enable</button>
            <span class="tag" id="gpStatus">Enabled (waiting for gamepad)</span>
          </div>
          <div class="row sl">
            <label for="gpPreset">Preset</label>
            <select id="gpPreset">
              <option value="ps5" selected>PS5 / DualSense</option>
              <option value="xinput">Generic XInput</option>
            </select>
          </div>
          <div class="row">
            <button id="gpRemap" class="btn" type="button">Remap Action…</button>
            <select id="gpAction">
              <option value="toggleDAR">Toggle DAR</option>
              <option value="rollLeft">Air Roll Left</option>
              <option value="rollRight">Air Roll Right</option>
              <option value="restart">Restart</option>
              <option value="orbitToggle">Toggle Orbit</option>
            </select>
            <span class="tag" id="gpBindLabel">—</span>
          </div>
          <div class="row" style="font-size:.86rem;opacity:.85;line-height:1.35;">
            Tip: Left stick moves the on-screen stick. Remap any action, then press a button or push an axis to bind.
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- Hints -->
  <div id="joyHint">Hold outside the stick to reposition (UI hidden)</div>
  <div id="darHint">Tap to toggle roll • Hold to move</div>

<script type="module">
import * as THREE from "https://esm.sh/three@0.155.0";
import { GLTFLoader } from "https://esm.sh/three@0.155.0/examples/jsm/loaders/GLTFLoader.js";

/* ====== Renderer / Scene / Camera ====== */
const gl = document.getElementById('gl');
const hud = document.getElementById('hud');
const renderer = new THREE.WebGLRenderer({canvas: gl, antialias: true});
renderer.outputColorSpace = THREE.SRGBColorSpace;
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);

const scene = new THREE.Scene();
/* fog color is themed later via applyTheme */
scene.fog = new THREE.Fog(0xeef1f6, 900, 2200);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
const CAM_BASE = { y: 280, z: 760 };
camera.position.set(0, CAM_BASE.y, CAM_BASE.z);
scene.add(camera);

/* Lights (brighter setup + tone mapping exposure) */
renderer.toneMappingExposure = 1.15;

const ambient = new THREE.AmbientLight(0xffffff, 1.05);
scene.add(ambient);

const dir = new THREE.DirectionalLight(0xffffff, 1.25);
dir.position.set(-350, 700, 900);
dir.castShadow = false;
scene.add(dir);

const fill = new THREE.DirectionalLight(0xffffff, 0.75);
fill.position.set(600, 300, -400);
scene.add(fill);

const rim = new THREE.DirectionalLight(0xffffff, 0.55);
rim.position.set(-900, 450, -700);
scene.add(rim);

/* Grid */
const grid = new THREE.Group();
const gridMain = new THREE.GridHelper(2600, 26, 0xd7dde6, 0xE5E9F1);
gridMain.material.opacity = 0.65;
gridMain.material.transparent = true;
grid.add(gridMain);
grid.rotation.x = -Math.PI/2;
grid.position.y = -160;
scene.add(grid);

/* === Theme (runs AFTER grid exists) === */
const THEMES = {
  light: {
    fog: 0xeef1f6,
    gridLine: 0xE5E9F1,
    gridCenter: 0xd7dde6,
    bodyClass: ''     // no class → light
  },
  dark: {
    fog: 0x101318,
    gridLine: 0x1f232b,
    gridCenter: 0x2a2e36,
    bodyClass: 'theme-dark'
  }
};

// Version-safe GridHelper color update
function setGridColors(lineHex, centerHex){
  const m = gridMain.material;
  if (Array.isArray(m)) {
    // Try to set both materials (order can vary)
    m[0]?.color?.setHex(centerHex);
    m[1]?.color?.setHex(lineHex);
  } else {
    m?.color?.setHex(lineHex);
  }
}

function applyTheme(name){
  const t = THEMES[name] || THEMES.light;

  document.body.classList.toggle('theme-dark', t.bodyClass === 'theme-dark');

  if (scene.fog) scene.fog.color.setHex(t.fog);
  else scene.fog = new THREE.Fog(t.fog, 900, 2200);

  setGridColors(t.gridLine, t.gridCenter);

  const btn = document.getElementById('themeToggle');
  if (btn) btn.textContent = (name === 'dark') ? '☀️' : '🌙';

  try { localStorage.setItem('l4_theme', name); } catch {}
}

function initTheme(){
  let saved = 'light';
  try { saved = localStorage.getItem('l4_theme') || 'light'; } catch {}
  applyTheme(saved);
}

document.getElementById('themeToggle')?.addEventListener('click', ()=>{
  const next = (localStorage.getItem('l4_theme') === 'dark') ? 'light' : 'dark';
  applyTheme(next);
});

// Initialize theme now that grid exists
initTheme();

/* Colors */
const COL_UP   = 0xff5c5c;
const COL_RIGHT= 0x4c8dff;
const COL_DOWN = 0x53d769;
const COL_LEFT = 0xffd166;

/* Materials */
const MAT_BODY  = new THREE.MeshPhongMaterial({color: 0xdfe5ef, shininess: 50, specular: 0x666666});
const MAT_GLASS = new THREE.MeshPhongMaterial({color: 0x9aa6b7, shininess: 40, specular: 0x222222, transparent:true, opacity:0.65});
const MAT_ACCENT= new THREE.MeshPhongMaterial({color: 0xcbd3df, shininess: 35, specular: 0x222222});
const MAT_DARK  = new THREE.MeshPhongMaterial({color: 0xaeb7c4, shininess: 28, specular: 0x222222});
const MAT_EDGE  = (hex)=> new THREE.LineBasicMaterial({color: hex});
const MAT_TIRE_F= new THREE.MeshLambertMaterial({color: 0x8a93a0});
const MAT_TIRE_B= new THREE.MeshLambertMaterial({color: 0x808896});
const MAT_HUB   = new THREE.MeshBasicMaterial({color: 0x5a6270});

/* Presets */
const presets = {
  placeholder: { hx:70, hy:28, hz:120 },
  octane:      { hx:85.65, hy:36.8, hz:120 },
  dominus:     { hx:77.9,  hy:29.3, hz:120 }
};

/* Car builder */
let car=null, BOX=null;
let faceArrow=null, faceTip=null;

/* === Arrow plane exactly on the nose === */
const FACE_OFFSET = 0.0;  // <<< was 0.20 — keep arrow base on the front face
const FACE_EPS    = 0.05; // <<< tiny nudge to avoid z-fighting

function clearCar(){
  if(!car) return;
  scene.remove(car);
  car.traverse(o=>{ if(o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose?.(); });
  car = null;
}

function buildCar(boxDims, presetName="placeholder"){
  clearCar();
  BOX = boxDims;
  car = new THREE.Group();
  car.position.y = 110;
  scene.add(car);

  const body = new THREE.Mesh(new THREE.BoxGeometry(BOX.hx*2, BOX.hy*2, BOX.hz*2), MAT_BODY);
  car.add(body);

  if(presetName==="octane") buildOctane();
  else if(presetName==="dominus") buildDominus();
  else buildPlaceholderFancy();

  // Front-face colored edges
  const vFL = new THREE.Vector3(-BOX.hx, +BOX.hy, +BOX.hz);
  const vFR = new THREE.Vector3(+BOX.hx, +BOX.hy, +BOX.hz);
  const vBR = new THREE.Vector3(+BOX.hx, -BOX.hy, +BOX.hz);
  const vBL = new THREE.Vector3(-BOX.hx, -BOX.hy, +BOX.hz);
  addEdge(vFR, vFL, COL_UP);
  addEdge(vBR, vFR, COL_LEFT);
  addEdge(vBL, vBR, COL_DOWN);
  addEdge(vFL, vBL, COL_RIGHT);

  // Nose arrow (body axis indicator, not the face arrow)
  const noseGeom = new THREE.BufferGeometry().setFromPoints([new THREE.Vector3(0,0,0), new THREE.Vector3(0,0,BOX.hz*0.55)]);
  const nose = new THREE.Line(noseGeom, new THREE.LineBasicMaterial({color: COL_DOWN}));
  car.add(nose);
  const noseTip = new THREE.Mesh(new THREE.ConeGeometry(8,16,12), new THREE.MeshBasicMaterial({color: COL_DOWN}));
  noseTip.rotation.x = Math.PI/2; noseTip.position.z = BOX.hz*0.55 + 10; car.add(noseTip);

  // Wheels
  const xOff = BOX.hx-10, zOff = BOX.hz*0.68;
  addWheel(+xOff, -zOff); addWheel(-xOff, -zOff);
  addWheel(+xOff, +zOff); addWheel(-xOff, +zOff);

  // Face input arrow (front plane, moves with car)
  const zFace = BOX.hz + FACE_OFFSET; // <<<
  const faceGeom = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0,0,zFace + FACE_EPS), // <<<
    new THREE.Vector3(0,0,zFace + FACE_EPS)  // <<<
  ]);
  faceArrow = new THREE.Line(faceGeom, new THREE.LineBasicMaterial({color: 0x333333}));
  car.add(faceArrow);

  faceTip = new THREE.Mesh(new THREE.ConeGeometry(6,12,12), new THREE.MeshBasicMaterial({color: 0x333333}));
  faceTip.position.set(0,0,zFace + FACE_EPS); // <<<
  car.add(faceTip);
  faceArrow.visible = false; faceTip.visible = false;
}

function addEdge(a,b,color){
  const geo = new THREE.BufferGeometry().setFromPoints([a,b]);
  const line = new THREE.Line(geo, MAT_EDGE(color));
  car.add(line);
}
function addWheel(x, z, r=18, w=12){
  const g = new THREE.CylinderGeometry(r, r, w, 16);
  const front = new THREE.Mesh(g, MAT_TIRE_F);
  const back  = new THREE.Mesh(g, MAT_TIRE_B);
  front.rotation.z = Math.PI/2; back.rotation.z  = Math.PI/2;
  const y = -BOX.hy- r*0.55;
  front.position.set(x, y, z + w/2);
  back .position.set(x, y, z - w/2);
  const hub = new THREE.Mesh(new THREE.CylinderGeometry(r*0.35, r*0.35, w*0.6, 10), MAT_HUB);
  hub.rotation.z = Math.PI/2; hub.position.set(x, y, z);
  const grp = new THREE.Group(); grp.add(back, front, hub); car.add(grp);
}
function addCabin(width, height, length, yOffset, zOffset){
  const cabin = new THREE.Mesh(new THREE.BoxGeometry(width, height, length), MAT_GLASS);
  cabin.position.set(0, yOffset, zOffset);
  car.add(cabin);
}
function addSpoiler(width, thickness, depth, yOffset, zOffset){
  const spoiler = new THREE.Mesh(new THREE.BoxGeometry(width, thickness, depth), MAT_ACCENT);
  spoiler.position.set(0, yOffset, zOffset);
  const st1 = new THREE.Mesh(new THREE.BoxGeometry(thickness, yOffset*0.5, thickness), MAT_ACCENT);
  const st2 = st1.clone();
  st1.position.set(-width*0.35, yOffset*0.25, zOffset - depth*0.2);
  st2.position.set(+width*0.35, yOffset*0.25, zOffset - depth*0.2);
  car.add(spoiler, st1, st2);
}
function addBumper(width, height, depth, yOffset, zOffset){
  const bumper = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), MAT_DARK);
  bumper.position.set(0, yOffset, zOffset);
  car.add(bumper);
}
function addFlares(xw, zw, r=10, w=6){
  const hemi = new THREE.CylinderGeometry(r, r, w, 10, 1, false, 0, Math.PI);
  const mat = MAT_ACCENT;
  const y = -BOX.hy + r*0.2;
  function flare(px, pz, flip){
    const f = new THREE.Mesh(hemi, mat);
    f.rotation.z = Math.PI/2;
    f.rotation.y = flip? Math.PI : 0;
    f.position.set(px, y, pz);
    car.add(f);
  }
  flare(+xw+6, +zw, false);
  flare(-xw-6, +zw, true);
  flare(+xw+6, -zw, true);
  flare(-xw-6, -zw, false);
}
function buildPlaceholderFancy(){
  const xOff = BOX.hx-10, zOff = BOX.hz*0.68;
  addFlares(xOff, zOff, 10, 6);
  addCabin(BOX.hx*1.0, BOX.hy*0.9, BOX.hz*0.55, BOX.hy*0.65, -BOX.hz*0.1);
  addSpoiler(BOX.hx*1.0, 6, 24, BOX.hy*0.8, -BOX.hz*0.95);
  addBumper(BOX.hx*0.9, 10, 18, -BOX.hy*0.7, +BOX.hz*0.98);
}
function buildOctane(){
  const xOff = BOX.hx-6, zOff = BOX.hz*0.64;
  addWheel(+xOff, -zOff, 19, 12); addWheel(-xOff, -zOff, 19, 12);
  addWheel(+xOff, +zOff, 18, 12); addWheel(-xOff, +zOff, 18, 12);
  addFlares(xOff, zOff, 12, 7);
  addCabin(BOX.hx*0.95, BOX.hy*1.1, BOX.hz*0.60, BOX.hy*0.85, -BOX.hz*0.05);
  addSpoiler(BOX.hx*1.2, 6, 30, BOX.hy*0.9, -BOX.hz*1.02);
  addBumper(BOX.hx*0.85, 12, 20, -BOX.hy*0.6, +BOX.hz*1.02);
}
function buildDominus(){
  const xOff = BOX.hx-8, zOff = BOX.hz*0.70;
  addWheel(+xOff, -zOff, 18, 12); addWheel(-xOff, -zOff, 18, 12);
  addWheel(+xOff, +zOff, 18, 12); addWheel(-xOff, +zOff, 18, 12);
  addFlares(xOff, zOff, 11, 6);
  addCabin(BOX.hx*1.05, BOX.hy*0.75, BOX.hz*0.75, BOX.hy*0.6, -BOX.hz*0.05);
  addSpoiler(BOX.hx*0.9, 5, 18, BOX.hy*0.72, -BOX.hz*1.0);
  addBumper(BOX.hx*1.05, 10, 30, -BOX.hy*0.55, +BOX.hz*1.05);
}

/* === Spawn Orientation Helper === */
function applySpawnOrientation() {
  if (!car) return;
  // Nose up, roof toward camera (roll 90° nose-up, yaw 180°)
  car.rotation.set(-Math.PI / 2, 0, Math.PI);
}

/* HUD utils */
const hctx = hud.getContext('2d');
function sizeHud(){ hud.width = innerWidth; hud.height = innerHeight; }
sizeHud();
function Hclear(){hctx.setTransform(1,0,0,1,0,0); hctx.clearRect(0,0,hud.width,hud.height);}
function Hcircle(x,y,r,strokeStyle,width){hctx.beginPath();hctx.lineWidth=width;hctx.strokeStyle=strokeStyle;hctx.arc(x,y,r,0,Math.PI*2);hctx.stroke();}
function HfillCircle(x,y,r,fillStyle){hctx.beginPath();hctx.fillStyle=fillStyle;hctx.arc(x,y,r,0,Math.PI*2);hctx.fill();}
function Harc(x,y,r,a1,a2,strokeStyle,width){hctx.beginPath();hctx.lineWidth=width;hctx.strokeStyle=strokeStyle;hctx.arc(x,y,r,a1,a2);hctx.stroke();}
function Hline(x1,y1,x2,y2,strokeStyle,width){hctx.beginPath();hctx.lineWidth=width;hctx.strokeStyle=strokeStyle;hctx.moveTo(x1,y1);hctx.lineTo(x2,y2);hctx.stroke();}
function Htri(x,y,a,r,fillStyle){hctx.save();hctx.translate(x,y);hctx.rotate(a);hctx.beginPath();hctx.moveTo(0,-r);hctx.lineTo(r*0.9,r*0.9);hctx.lineTo(-r*0.9,r*0.9);hctx.closePath();hctx.fillStyle=fillStyle;hctx.fill();hctx.restore();}

/* Joystick */
let JOY_BASE_R = 100, JOY_KNOB_R = Math.round(JOY_BASE_R*0.32);
let JOY_CENTER = new THREE.Vector2(126, innerHeight-170);
let joyActive=false, joyVec = new THREE.Vector2(0,0), smJoy = new THREE.Vector2(0,0);
const STICK_TAU_MS=8, RELOCATE_HOLD_MS=250, STICK_MIN=0.02;
let activeId=null, relocating=false, holdTimer=null;
const COLS = {UP:'#ff5c5c', RIGHT:'#4c8dff', DOWN:'#53d769', LEFT:'#ffd166'};

function drawJoystick(){
  const cx=JOY_CENTER.x, cy=JOY_CENTER.y, r=JOY_BASE_R;
  const t=performance.now(); const pulse=1+0.06*Math.sin(t*0.008), halo=r*pulse+10;
  Hcircle(cx,cy,halo, 'rgba(76,141,255,0.28)', 8);
  Harc(cx,cy,r, -Math.PI/4,  Math.PI/4,   COLS.RIGHT, 12);
  Harc(cx,cy,r,  Math.PI/4,  3*Math.PI/4, COLS.UP,    12);
  Harc(cx,cy,r,  3*Math.PI/4,5*Math.PI/4, COLS.LEFT,  12);
  Harc(cx,cy,r,  5*Math.PI/4,7*Math.PI/4, COLS.DOWN,  12);
  Hcircle(cx,cy,r-18, '#b9c1cd', 2);
  Hline(cx-r+12,cy,cx+r-12,cy,'#cfd6e2',1.5);
  Hline(cx,cy-r+12,cx,cy+r-12,'#cfd6e2',1.5);
  const kx=cx+joyVec.x, ky=cy+joyVec.y;
  Hcircle(kx,ky,JOY_KNOB_R,'#4c8dff',4); HfillCircle(kx,ky,JOY_KNOB_R,'#0f1116');
  hctx.fillStyle='#222'; hctx.beginPath(); hctx.arc(cx,cy,3,0,Math.PI*2);hctx.fill();
}
function inJoyLoose(x,y){
  const dx=x-JOY_CENTER.x, dy=y-JOY_CENTER.y;
  const loose=JOY_BASE_R+28;
  const inC = (dx*dx+dy*dy) <= loose*loose;
  const inB = (Math.abs(dx)<=JOY_BASE_R) && (Math.abs(dy)<=JOY_BASE_R+40);
  return inC || inB;
}
function vecFromJoyPx(x,y){
  let dx=x-JOY_CENTER.x, dy=y-JOY_CENTER.y;
  const m=Math.hypot(dx,dy);
  if(m>JOY_BASE_R){const k=JOY_BASE_R/(m||1); dx*=k; dy*=k;}
  return new THREE.Vector2(dx,dy);
}
function clampJoyCenter(){
  JOY_CENTER.x = Math.max(JOY_BASE_R+20, Math.min(innerWidth -(JOY_BASE_R+20), JOY_CENTER.x));
  JOY_CENTER.y = Math.max(JOY_BASE_R+20, Math.min(innerHeight-(JOY_BASE_R+20), JOY_CENTER.y));
}

/* DAR button (toggle + relocate) */
let DAR_R = 44;
let DAR_CENTER = new THREE.Vector2(innerWidth-120, innerHeight-150);
let darOn = false, darRelocating = false, darHoldTimer = null, darPressT=0;

function drawDAR(){
  const cx=DAR_CENTER.x, cy=DAR_CENTER.y, r=DAR_R;
  HfillCircle(cx,cy,r, darOn ? 'rgba(0,102,255,0.18)' : 'rgba(24,26,32,0.75)');
  Hcircle(cx,cy,r, darOn ? '#4c8dff' : '#3a3d45', darOn ? 5 : 3);
  const a = (airRoll>0) ? Math.PI/2 : -Math.PI/2;
  Htri(cx,cy,a, r*0.55, darOn ? '#0e0f12' : '#e8e8ea');
  Hcircle(cx,cy,r-12, '#bdbdbd', 1.5);
}
function inDAR(x,y){
  const dx=x-DAR_CENTER.x, dy=y-DAR_CENTER.y;
  return (dx*dx+dy*dy) <= (DAR_R*DAR_R);
}
function clampDARCenter(){
  const m=DAR_R+20;
  DAR_CENTER.x = Math.max(m, Math.min(innerWidth - m, DAR_CENTER.x));
  DAR_CENTER.y = Math.max(m, Math.min(innerHeight - m, DAR_CENTER.y));
}

/* Hints */
const joyHint = document.getElementById('joyHint');
const darHint = document.getElementById('darHint');
function showHint(el,ms){ el.classList.add('show'); setTimeout(()=>el.classList.remove('show'), ms); }
function positionHints(){
  joyHint.style.left = (JOY_CENTER.x + JOY_BASE_R + 18)+'px';
  joyHint.style.top  = (JOY_CENTER.y - JOY_BASE_R - 18)+'px';
  darHint.style.left = (DAR_CENTER.x + DAR_R + 18)+'px';
  darHint.style.top  = (DAR_CENTER.y - DAR_R - 18)+'px';
}

/* MENU open/close */
const menuBtn=document.getElementById('menuBtn');
const menuOverlay=document.getElementById('menuOverlay');
const menuCloseBtn=document.getElementById('menuCloseBtn');
let chromeShown=false;

function openMenu(){
  chromeShown=true;
  menuBtn.classList.add('active');
  menuOverlay.style.display='block';
}
function closeMenu(){
  chromeShown=false;
  menuBtn.classList.remove('active');
  menuOverlay.style.display='none';
}
menuBtn.addEventListener('click',()=> chromeShown ? closeMenu() : openMenu());
menuCloseBtn.addEventListener('click', closeMenu);
menuOverlay.addEventListener('click',(e)=>{ if(e.target===menuOverlay) closeMenu(); });

/* Buttons / presets */
let airRoll = -1; // default to Air Roll Left
function setRoll(dir){
  airRoll=dir;
  document.getElementById('rollL').classList.toggle('active',dir>0);
  document.getElementById('rollR').classList.toggle('active',dir<0);
}
document.getElementById('rollL').addEventListener('click',()=>setRoll(+1));
document.getElementById('rollR').addEventListener('click',()=>setRoll(-1));

document.getElementById('restart').addEventListener('click',()=>{
  if (car) car.quaternion.identity();
  applySpawnOrientation();
  w.set(0,0,0);
  orbitOn = false;
  const orbitBtn = document.getElementById('orbit');
  if (orbitBtn) orbitBtn.classList.remove('active');
  orbitPhase = 0;
  camera.position.set(0, 220, 650);
  camera.lookAt(0,0,0);
  if (faceArrow) faceArrow.visible = false;
  if (faceTip)   faceTip.visible   = false;
});
let orbitOn=false;
document.getElementById('orbit').addEventListener('click',()=>{
  orbitOn=!orbitOn; document.getElementById('orbit').classList.toggle('active',orbitOn);
});

/* Sliders / select */
const accelRange=document.getElementById('accelRange'), accelTag=document.getElementById('accelTag');
const curveRange=document.getElementById('curveRange'), curveTag=document.getElementById('curveTag');
const dampRange=document.getElementById('dampRange'),   dampTag=document.getElementById('dampTag');
const brakeRange=document.getElementById('brakeRange'), brakeTag=document.getElementById('brakeTag');
const wmaxRange=document.getElementById('wmaxRange'),   wmaxTag=document.getElementById('wmaxTag');
const wmaxPitchRange=document.getElementById('wmaxPitch'), wmaxPitchTag=document.getElementById('wmaxPitchTag');
const wmaxYawRange=document.getElementById('wmaxYaw'), wmaxYawTag=document.getElementById('wmaxYawTag');
const spinSlider=document.getElementById('spinSlider'), rollVal=document.getElementById('rollVal');
const sizeSlider=document.getElementById('stickSizeSlider'), stickVal=document.getElementById('stickVal');
const zoomSlider=document.getElementById('zoomSlider'), zoomVal=document.getElementById('zoomVal');
const arrowSlider=document.getElementById('arrowSlider'), arrowVal=document.getElementById('arrowVal');
const presetSel=document.getElementById('presetSel');

let maxAccelDeg=parseFloat(accelRange.value),
    inputPow=parseFloat(curveRange.value),
    damp=parseFloat(dampRange.value),
    brakeOnRelease=parseFloat(brakeRange.value),
    wMax=parseFloat(wmaxRange.value),
    wMaxPitch=parseFloat(wmaxPitchRange.value),
    wMaxYaw=parseFloat(wmaxYawRange.value),
    freeRollPeriod=parseFloat(spinSlider.value),
    zoom=parseFloat(zoomSlider.value),
    arrowScale=parseFloat(arrowSlider.value);

function syncTags(){
  accelTag.textContent=maxAccelDeg.toFixed(0);
  curveTag.textContent=inputPow.toFixed(2);
  dampTag.textContent=damp.toFixed(2);
  brakeTag.textContent=brakeOnRelease.toFixed(1);
  wmaxTag.textContent=wMax.toFixed(1);
  wmaxPitchTag.textContent=wMaxPitch.toFixed(1);
  wmaxYawTag.textContent=wMaxYaw.toFixed(1);
  rollVal.textContent = (freeRollPeriod > 0) ? `${freeRollPeriod.toFixed(2)} s/rot` : 'off';
  stickVal.textContent = String(Math.round(JOY_BASE_R));
  zoomVal.textContent = `${(zoom||1).toFixed(2)}×`;
  arrowVal.textContent = `${(arrowScale||1).toFixed(2)}×`;
}
syncTags();

accelRange.addEventListener('input',()=>{maxAccelDeg=parseFloat(accelRange.value)||255; syncTags();});
curveRange.addEventListener('input',()=>{inputPow=parseFloat(curveRange.value)||1.0; syncTags();});
dampRange .addEventListener('input',()=>{damp=parseFloat(dampRange.value)||1.20; syncTags();});
brakeRange.addEventListener('input',()=>{brakeOnRelease=parseFloat(brakeRange.value)||6.0; syncTags();});
wmaxRange .addEventListener('input',()=>{wMax=parseFloat(wmaxRange.value)||6.0; syncTags();});
wmaxPitchRange.addEventListener('input',()=>{wMaxPitch=parseFloat(wmaxPitchRange.value)||8.5; syncTags();});
wmaxYawRange.addEventListener('input',()=>{wMaxYaw=parseFloat(wmaxYawRange.value)||9.0; syncTags();});
spinSlider.addEventListener('input',()=>{freeRollPeriod=parseFloat(spinSlider.value)||0; syncTags();});
sizeSlider.addEventListener('input',()=>{JOY_BASE_R=parseInt(stickSizeSlider.value,10)||100; JOY_KNOB_R=Math.round(JOY_BASE_R*0.32); clampJoyCenter(); positionHints(); syncTags();});
zoomSlider.addEventListener('input',()=>{zoom=parseFloat(zoomSlider.value)||1.0; applyZoom(); syncTags();});
arrowSlider.addEventListener('input',()=>{arrowScale=parseFloat(arrowSlider.value)||4.0; syncTags();});
presetSel .addEventListener('change',()=>{
  const name = presetSel.value;
  buildCar(presets[name], name);
  car.quaternion.identity(); w.set(0,0,0);
  applySpawnOrientation();
});

/* Pointer handlers */
hud.addEventListener('pointerdown',(e)=>{
  try{hud.setPointerCapture(e.pointerId);}catch(_){}
  activeId=e.pointerId;

  if(inDAR(e.clientX,e.clientY)){
    darPressT = performance.now();
    clearTimeout(darHoldTimer);
    darHoldTimer = setTimeout(()=>{
      if(activeId===e.pointerId){
        darRelocating = true; showHint(darHint, 2000);
      }
    }, RELOCATE_HOLD_MS);
    e.preventDefault(); return;
  }

  if(inJoyLoose(e.clientX,e.clientY)){
    joyActive=true; joyVec = vecFromJoyPx(e.clientX,e.clientY);
  }else if(!chromeShown){
    clearTimeout(holdTimer);
    holdTimer = setTimeout(()=>{
      if(activeId===e.pointerId && !chromeShown){
        relocating = true; showHint(joyHint, 1800);
      }
    }, RELOCATE_HOLD_MS);
  }
  e.preventDefault();
},{passive:false});
hud.addEventListener('pointermove',(e)=>{
  if(activeId!==e.pointerId)return;
  if(darRelocating){ DAR_CENTER.set(e.clientX,e.clientY); clampDARCenter(); positionHints(); }
  else if(relocating){ JOY_CENTER.set(e.clientX,e.clientY); clampJoyCenter(); positionHints(); }
  else if(joyActive){ joyVec = vecFromJoyPx(e.clientX,e.clientY); }
  e.preventDefault();
},{passive:false});
function endPtr(e){
  if(activeId!==e.pointerId) return;
  try{hud.releasePointerCapture(e.pointerId);}catch(_){}
  clearTimeout(holdTimer); relocating=false;

  if(!darRelocating && inDAR(e.clientX,e.clientY)){
    const heldMs = performance.now() - darPressT;
    if(heldMs < RELOCATE_HOLD_MS){ darOn = !darOn; }
  }
  clearTimeout(darHoldTimer); darRelocating=false;

  if(joyActive){ joyActive = false; joyVec.set(0,0); }
  activeId=null; e.preventDefault();
}
hud.addEventListener('pointerup',endPtr,{passive:false});
hud.addEventListener('pointercancel',endPtr,{passive:false});

/* ====== GAMEPAD SUPPORT (PS5 / Generic, remappable) ====== */
const gpEnableBtn = document.getElementById('gpEnable');
const gpStatusTag = document.getElementById('gpStatus');
const gpPresetSel = document.getElementById('gpPreset');
const gpActionSel = document.getElementById('gpAction');
const gpRemapBtn  = document.getElementById('gpRemap');
const gpBindLabel = document.getElementById('gpBindLabel');

let gpEnabled = true;      // enabled by default
let gpIndex   = -1;
let gpRemapping = false;
let gpPrevActionPressed = {};
const GP_DEADZONE = 0.15;

let gpBindings = {
  toggleDAR:  { kind:'button', index: 1 },
  rollLeft:   { kind:'button', index: 4 },
  rollRight:  { kind:'button', index: 5 },
  restart:    { kind:'button', index: 9 },
  orbitToggle:{ kind:'button', index: 2 }
};

const GP_PRESETS = {
  ps5: { toggleDAR:{kind:'button',index:1}, rollLeft:{kind:'button',index:4}, rollRight:{kind:'button',index:5}, restart:{kind:'button',index:9}, orbitToggle:{kind:'button',index:2} },
  xinput: { toggleDAR:{kind:'button',index:1}, rollLeft:{kind:'button',index:4}, rollRight:{kind:'button',index:5}, restart:{kind:'button',index:9}, orbitToggle:{kind:'button',index:2} }
};

function bindingToLabel(b){
  if(!b) return '—';
  if(b.kind==='button') return `Button ${b.index}`;
  const d = b.dir>0 ? '+' : '−';
  return `Axis ${b.axis}${d}`;
}
function setBindingPreset(name){
  const p = GP_PRESETS[name] || GP_PRESETS.ps5;
  gpBindings = JSON.parse(JSON.stringify(p));
  updateBindLabel();
}
function updateBindLabel(){
  const act = gpActionSel.value;
  gpBindLabel.textContent = bindingToLabel(gpBindings[act]);
}

gpEnableBtn.addEventListener('click',()=>{
  gpEnabled = !gpEnabled;
  gpEnableBtn.classList.toggle('active', gpEnabled);
  gpStatusTag.textContent = gpEnabled ? 'Enabled' : 'Disabled';
});
gpPresetSel.addEventListener('change', ()=> setBindingPreset(gpPresetSel.value));
gpActionSel.addEventListener('change', updateBindLabel);
gpRemapBtn.addEventListener('click',()=>{
  gpRemapping = true;
  gpBindLabel.textContent = 'Press button / move axis…';
});

setBindingPreset('ps5');
updateBindLabel();

addEventListener('gamepadconnected', (e)=>{
  if(gpIndex<0){ gpIndex = e.gamepad.index; }
  gpStatusTag.textContent = `Connected: ${e.gamepad.id}`;
});
addEventListener('gamepaddisconnected', (e)=>{
  if(e.gamepad.index===gpIndex){ gpIndex=-1; }
  gpStatusTag.textContent = gpEnabled ? 'Enabled (waiting for gamepad)' : 'No gamepad';
});

function readPads(){
  const arr = (navigator.getGamepads?.() || []);
  if(gpIndex<0){
    for(let i=0;i<arr.length;i++){
      const p = arr[i];
      if(p && p.mapping==='standard'){ gpIndex=i; break; }
    }
  }
  return { pad: (gpIndex>=0 ? arr[gpIndex] : null), all: arr };
}

function isPressedForBinding(pad, binding){
  if(!binding || !pad) return false;
  if(binding.kind==='button'){
    const b = pad.buttons[binding.index];
    return !!(b && (b.value||0) > 0.5);
  }
  if(binding.kind==='axis'){
    const v = pad.axes[b.axis] || 0;
    return binding.dir>0 ? (v>0.6) : (v<-0.6);
  }
  return false;
}

function execBinding(action){
  switch(action){
    case 'toggleDAR':
      darOn = !darOn;
      break;
    case 'rollLeft':
      setRoll(-1);
      break;
    case 'rollRight':
      setRoll(+1);
      break;
    case 'restart': {
      if (car) car.quaternion.identity();
      applySpawnOrientation();
      w.set(0,0,0);
      orbitOn = false;
      const orbitBtn = document.getElementById('orbit');
      if (orbitBtn) orbitBtn.classList.remove('active');
      orbitPhase = 0;
      camera.position.set(0, 220, 650);
      camera.lookAt(0,0,0);
      if (faceArrow) faceArrow.visible = false;
      if (faceTip)   faceTip.visible   = false;
      break;
    }
    case 'orbitToggle':
      orbitOn = !orbitOn;
      document.getElementById('orbit').classList.toggle('active', orbitOn);
      break;
    default: break;
  }
}

function handleRemap(pad){
  if(!gpRemapping || !pad) return;
  for(let i=0;i<pad.buttons.length;i++){
    if(pad.buttons[i] && (pad.buttons[i].value||0) > 0.5){
      gpBindings[gpActionSel.value] = { kind:'button', index:i };
      gpRemapping = false;
      updateBindLabel();
      return;
    }
  }
  for(let a=0;a<pad.axes.length;a++){
    const v = pad.axes[a] || 0;
    if(Math.abs(v) > 0.6){
      gpBindings[gpActionSel.value] = { kind:'axis', axis:a, dir: (v>0? +1 : -1) };
      gpRemapping = false;
      updateBindLabel();
      return;
    }
  }
}

function updateGamepadInput(){
  if(!gpEnabled) return;
  const { pad } = readPads();
  if(!pad){ gpStatusTag.textContent = 'Enabled (waiting for gamepad)'; return; }
  gpStatusTag.textContent = `Connected: ${pad.id}`;

  if(gpRemapping){ handleRemap(pad); }

  // Left stick → on-screen stick (natural Y: up=up)
  if(!joyActive && !relocating && !darRelocating){
    const lx = pad.axes[0] || 0;
    const ly = pad.axes[1] || 0;
    const mag = Math.hypot(lx, ly);
    let nx = 0, ny = 0;
    if(mag > GP_DEADZONE){
      const k = (mag - GP_DEADZONE) / (1 - GP_DEADZONE);
      nx = (lx / (mag||1)) * k;
      ny = (ly / (mag||1)) * k;
    }
    joyVec.set(nx * JOY_BASE_R, ny * JOY_BASE_R);
  }

  // Fire actions on rising edge
  for(const action of Object.keys(gpBindings)){
    const nowPressed = isPressedForBinding(pad, gpBindings[action]);
    const wasPressed = !!gpPrevActionPressed[action];
    if(nowPressed && !wasPressed){ execBinding(action); }
    gpPrevActionPressed[action] = nowPressed;
  }
}

/* Physics (independent caps for Pitch/Yaw) */
let w = new THREE.Vector3(0,0,0);
const STICK_DEADZONE = STICK_MIN;
const KP_ROLL = 3.2, KD_ROLL = 0.25;

function integrate(dt){
  const a = 1 - Math.exp(-(dt*1000)/Math.max(1,STICK_TAU_MS));
  smJoy.lerp(joyVec, a);

  // screen → body; flip Y for screen coords
  const jx =  smJoy.x/JOY_BASE_R;
  const jy = -smJoy.y/JOY_BASE_R;
  const mag = Math.hypot(jx,jy);

  // deadzone & curve
  let eff = Math.max(0, mag - STICK_DEADZONE) / (1 - STICK_DEADZONE);
  eff = Math.pow(eff, inputPow);
  const ux = (mag>0) ? (-jx/mag) : 0; // yaw unit (flipped X)
  const uy = (mag>0) ? ( jy/mag) : 0; // pitch unit

  // Face arrow (draws on the car's front plane)
  if (faceArrow && faceTip){
    const show = eff > 0.02;
    faceArrow.visible = show; faceTip.visible = show;
    if (show){
      const lenMax = Math.min(BOX.hx, BOX.hy) * 0.95;
      const len = Math.max(10, lenMax * eff * (arrowScale||1));
      const zFace = BOX.hz + FACE_OFFSET; // <<<

      const x2 =  ux * len;
      const y2 = -uy * len;   // draw flip

      const pos = faceArrow.geometry.attributes.position.array;
      pos[0]=0; pos[1]=0; pos[2]=zFace + FACE_EPS; // <<<
      pos[3]=x2; pos[4]=y2; pos[5]=zFace + FACE_EPS; // <<<
      faceArrow.geometry.attributes.position.needsUpdate = true;

      const col = (Math.abs(x2) > Math.abs(y2))
        ? (x2 >= 0 ? COL_LEFT : COL_RIGHT)
        : (uy >= 0 ? COL_DOWN : COL_UP);
      faceArrow.material.color.setHex(col);
      faceTip.material.color.setHex(col);

      faceTip.position.set(x2, y2, zFace + FACE_EPS); // <<<
      const ang = Math.atan2(x2, -y2) + Math.PI; // point outward
      faceTip.rotation.set(0, 0, ang);
      const s = 0.95 * (arrowScale||1);
      faceTip.scale.set(s, s, 1);
    }
  }

  const maxAccelRad = (maxAccelDeg * Math.PI) / 180;

  // commanded angular accel in body axes
  const alpha = new THREE.Vector3(
    maxAccelRad * eff * uy,   // pitch (X)
    maxAccelRad * eff * ux,   // yaw (Y)
    0
  );

  // DAR roll controller (period 0 = off)
  let targetWz = 0;
  if (darOn && freeRollPeriod > 0){
    targetWz = airRoll * (2*Math.PI)/freeRollPeriod;
  }
  alpha.z = KP_ROLL*(targetWz - w.z) - KD_ROLL*w.z;

  // integrate ω
  w.addScaledVector(alpha, dt);

  // damping + extra brake when no stick & DAR off
  const noStick = eff < 0.02;
  const dampEff = (damp||0) + ((noStick && !darOn) ? (brakeOnRelease||0) : 0);
  const scale = Math.exp(-dampEff * dt);
  w.multiplyScalar(scale);

  // independent caps for pitch & yaw
  if (Math.abs(w.x) > wMaxPitch) w.x = Math.sign(w.x) * wMaxPitch;
  if (Math.abs(w.y) > wMaxYaw)   w.y = Math.sign(w.y)   * wMaxYaw;

  // global cap
  const wm = w.length();
  if (wm > wMax) w.multiplyScalar(wMax/(wm||1));

  // integrate quaternion
  const wx=w.x, wy=w.y, wz=w.z, halfdt=0.5*dt;
  const q=car.quaternion;
  const rw = - q.x*wx - q.y*wy - q.z*wz;
  const rx =   q.w*wx + q.y*wz - q.z*wy;
  const ry =   q.w*wy + q.z*wx - q.x*wz;
  const rz =   q.w*wz + q.x*wy - q.y*wx;
  q.w += rw*halfdt; q.x += rx*halfdt; q.y += ry*halfdt; q.z += rz*halfdt;
  q.normalize();
}

/* Camera zoom/orbit */
let orbitPhase=0;
function applyZoom(){
  const f = Math.max(0.7, Math.min(1.6, zoom||1));
  const dist = CAM_BASE.z / f;
  const h = CAM_BASE.y / f;
  if(!orbitOn){
    camera.position.set(0, h, dist);
    camera.lookAt(0, car ? car.position.y : 0, 0);
  }
}
function orbitStep(t){
  const f = Math.max(0.7, Math.min(1.6, zoom||1));
  const R = (CAM_BASE.z / f);
  const h = (CAM_BASE.y / f);
  const sp=0.35;
  const x = Math.sin(t*sp)*R;
  const z = Math.cos(t*sp)*R;
  camera.position.set(x, h, z);
  camera.lookAt(0, car ? car.position.y : 0, 0);
}

/* XYZ Gizmo */
const gizmoRect = document.getElementById('gizmoFrame').getBoundingClientRect();
const gizmoScene = new THREE.Scene();
const gizmoCam = new THREE.PerspectiveCamera(40, gizmoRect.width/gizmoRect.height, 0.1, 100);
gizmoCam.position.set(0,0,6);
const gizmoAxes = new THREE.AxesHelper(3.2);
gizmoScene.add(gizmoAxes);
const gizmoTarget = new THREE.Object3D();
gizmoScene.add(gizmoTarget);
gizmoAxes.position.copy(gizmoTarget.position);

/* Render HUD & loop */
function renderHUD(){ Hclear(); drawJoystick(); drawDAR(); }

let lastT = performance.now()/1000;
function tick(){
  const t = performance.now()/1000;
  const dt = Math.min(0.033, Math.max(0.001, t - lastT));
  lastT = t;

  if(orbitOn){ orbitPhase += dt; orbitStep(orbitPhase); }

  updateGamepadInput();
  integrate(dt);

  renderer.setScissorTest(false);
  renderer.setViewport(0,0,innerWidth,innerHeight);
  renderer.render(scene, camera);

  if(car){
    gizmoTarget.quaternion.copy(car.quaternion);
    gizmoAxes.quaternion.copy(gizmoTarget.quaternion);
  }
  const gf = document.getElementById('gizmoFrame').getBoundingClientRect();
  const sx = Math.floor(gf.left), sy = Math.floor(innerHeight - gf.bottom);
  const sw = Math.floor(gf.width), sh = Math.floor(gf.height);
  renderer.setScissorTest(true);
  renderer.setScissor(sx,sy,sw,sh);
  renderer.setViewport(sx,sy,sw,sh);
  renderer.render(gizmoScene, gizmoCam);
  renderer.setScissorTest(false);

  renderHUD();
  requestAnimationFrame(tick);
}

/* Resize & boot */
function resize(){
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  sizeHud(); clampJoyCenter(); clampDARCenter(); positionHints(); applyZoom();
}
addEventListener('resize', resize);

/* ==== GLB SWAP LOGIC ==== */
const gltfLoader = new GLTFLoader();

function clearCarMeshesKeepGadgets(){
  if(!car) return;
  const keep = new Set([faceArrow, faceTip]);
  const toRemove = [];
  car.children.forEach(ch => { if(!keep.has(ch)) toRemove.push(ch); });
  toRemove.forEach(ch=>{
    car.remove(ch);
    ch.traverse?.(o=>{ if(o.geometry) o.geometry.dispose(); if(o.material) o.material.dispose?.(); });
  });
}

function swapInGLB(){
  gltfLoader.load(
    "./models/octane.glb",
    (gltf)=>{
      const model = gltf.scene || gltf.scenes?.[0];
      if(!model){ console.warn("[GLB] No scene in file"); return; }

      // Center
      const preBox  = new THREE.Box3().setFromObject(model);
      const preSize = preBox.getSize(new THREE.Vector3());
      const preCtr  = preBox.getCenter(new THREE.Vector3());
      model.position.sub(preCtr);

      // Align +X → +Z if necessary (common in car assets)
      if (preSize.x > preSize.z * 1.2) {
        model.rotation.y = -Math.PI / 2;
      }

      // Scale GLB to placeholder longest dimension to keep dynamics consistent
      const targetLongest = (BOX ? Math.max(BOX.hx*2, BOX.hy*2, BOX.hz*2) : 240);
      const glbLongest = Math.max(preSize.x, preSize.y, preSize.z) || 1;
      const scale = targetLongest / glbLongest;
      model.scale.setScalar(scale);

      // Replace placeholder visuals
      clearCarMeshesKeepGadgets();
      car.add(model);

      // Recompute BOX so HUD arrow stays correct
      const box = new THREE.Box3().setFromObject(model);
      const s   = box.getSize(new THREE.Vector3());
      BOX = { hx: s.x/2, hy: s.y/2, hz: s.z/2 };

      // Update arrow plane to new front face (still moves with car)
      if(faceArrow && faceTip){
        const zFace = BOX.hz + FACE_OFFSET; // <<<
        const pos = faceArrow.geometry.attributes.position.array;
        pos[0]=0; pos[1]=0; pos[2]=zFace + FACE_EPS; // <<<
        pos[3]=0; pos[4]=0; pos[5]=zFace + FACE_EPS; // <<<
        faceArrow.geometry.attributes.position.needsUpdate = true;
        faceTip.position.set(0,0,zFace + FACE_EPS); // <<<
      }

      // Apply the global spawn orientation to the car group (not the GLB itself)
      applySpawnOrientation();
    },
    undefined,
    (err)=>{ console.error("[GLB] load failed:", err); }
  );
}

/* Build + boot */
buildCar(presets.octane, "octane");
applySpawnOrientation();
setRoll(-1);           // default Air Roll Left
positionHints();
applyZoom();
swapInGLB();           // load the GLB and replace the placeholder
requestAnimationFrame(tick);
</script>
</body>
</html>
