<!DOCTYPE html>
<html lang="en">
    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.164.0/build/three.module.js"
  }
}
</script>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>L4 — Blender-Style + XYZ Gizmo + DAR Toggle/Relocate</title>
<style>
  /* === CSS BASE START === */
  html,body{margin:0;padding:0;height:100%;background:#ffffff;color:#0e0f12;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overscroll-behavior:none}
  body{background:linear-gradient(180deg,#f6f7fb 0%,#eef1f6 45%,#e9edf3 100%);}
  *, *::before, *::after{box-sizing:border-box}
  *{user-select:none;-webkit-user-select:none;-ms-user-select:none;-webkit-touch-callout:none}
  #gl{position:fixed;inset:0;z-index:0;display:block}
  #hud{position:fixed;inset:0;z-index:1;display:block;touch-action:none}
  /* === CSS BASE END === */

  /* === HAMBURGER === */
  #menuBtn{
    position:fixed;top:.6rem;right:.6rem;z-index:3;width:44px;height:44px;
    border-radius:12px;border:1px solid #3a3d45;background:#181a20;display:grid;place-items:center;
    box-shadow:0 2px 10px rgba(0,0,0,.25)
  }
  #menuBtn .bar{display:block;width:20px;height:2px;background:#e8e8ea;margin:3px 0}
  #menuBtn.active{background:#0066ff;border-color:#4c8dff}

  /* === OVERLAY MENU PANEL === */
  #menuOverlay{
    position:fixed; inset:0; z-index:4; display:none;
    background:rgba(10,12,16,0.45); backdrop-filter: blur(3px);
    overflow-x:hidden;
  }
  #menuPanel{
    position:absolute; left:50%; top:12vh; transform:translateX(-50%);
    width:min(960px, calc(100vw - 2rem)); max-height:76vh; overflow:auto;
    background:rgba(24,26,32,.96); color:#e8e8ea; border:1px solid #3a3d45; border-radius:14px;
    box-shadow:0 20px 60px rgba(0,0,0,.35);
    overflow-x:hidden;
  }
  .mp-header{
    position:sticky; top:0; background:rgba(24,26,32,.98); z-index:1;
    padding:.9rem clamp(.8rem, 2vw, 1rem); border-bottom:1px solid #33373f; display:flex; align-items:center; justify-content:space-between;
  }
  .mp-title{font-weight:700;letter-spacing:.2px}
  .mp-close{border:1px solid #3a3d45;background:#181a20;color:#e8e8ea;border-radius:10px;padding:.35rem .6rem;font-weight:600}
  .mp-body{
    padding:clamp(.6rem,2vw,1rem);
    display:grid; grid-template-columns: 1fr 1fr; gap:14px;
  }
  @media (max-width: 860px){ .mp-body{grid-template-columns: 1fr;} }

  .card{
    background:#15171d; border:1px solid #33373f; border-radius:12px; padding:.9rem;
  }
  .card h3{margin:.1rem 0 .7rem; font-size:1rem; opacity:.95}
  .row{display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; margin:.45rem 0; width:100%;}
  .btn{border:1px solid #3a3d45;padding:.45rem .7rem;border-radius:999px;background:#181a20;color:#e8e8ea;font-weight:600;letter-spacing:.2px;cursor:pointer}
  .btn.active{background:#0066ff;border-color:#4c8dff}
  .tag{background:#181a20;border:1px solid #3a3d45;padding:.25rem .5rem;border-radius:999px;font-size:.82rem;white-space:nowrap}

  .sl{
    display:flex; align-items:center; gap:.6rem; flex-wrap:nowrap;
    width:100%; min-width:0;
  }
  .sl label{
    font-size:.88rem; opacity:.92; flex:0 0 150px; min-width:120px; max-width:220px;
  }
  .sl input[type=range]{
    accent-color:#4c8dff;
    flex:1 1 auto; min-width:0; max-width:100%; width:100%;
  }
  .sl .tag{flex:0 0 auto}

  @media (max-width:520px){
    .sl{flex-wrap:wrap}
    .sl label{flex:1 0 100%}
    .sl input[type=range]{flex:1 0 100%}
    .sl .tag{margin-left:auto}
  }

  select{background:#181a20;color:#e8e8ea;border:1px solid #3a3d45;border-radius:10px;padding:.35rem .5rem;max-width:100%}

  /* Hints (stick/DAR) */
  #joyHint,#darHint{position:fixed; z-index:2; pointer-events:none;background:rgba(24,26,32,.92); border:1px solid #3a3d45; color:#cfd3dc;
    padding:.35rem .55rem; border-radius:10px; font-size:.85rem; white-space:nowrap; transform:translate(-50%,-50%); opacity:0; transition:opacity .25s ease;}
  #joyHint.show,#darHint.show{opacity:1;}

  /* XYZ gizmo frame */
  #gizmoFrame{
    position:fixed; right:.6rem; top:64px; width:84px; height:84px; z-index:2;
    border-radius:10px; border:1px solid #3a3d45; background:rgba(24,26,32,.5);
    box-shadow:0 8px 24px rgba(0,0,0,.2); pointer-events:none;
  }
</style>
</head>
<body>
  <!-- CANVASES -->
  <canvas id="gl"></canvas>
  <canvas id="hud"></canvas>
  <div id="gizmoFrame"></div>

  <!-- HAMBURGER -->
  <button id="menuBtn" type="button" title="Open Menu"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button>

  <!-- OVERLAY MENU -->
  <div id="menuOverlay">
    <div id="menuPanel">
      <div class="mp-header">
        <div class="mp-title">L4 Controls & Settings</div>
        <button class="mp-close" id="menuCloseBtn" type="button">Close</button>
      </div>
      <div class="mp-body">

        <!-- Rotation -->
        <div class="card">
          <h3>Rotation</h3>
          <div class="row">
            <button id="rollL" class="btn" type="button">Air Roll Right</button>
            <button id="rollR" class="btn active" type="button">Air Roll Left</button>
            <button id="restart" class="btn" type="button">Restart</button>
            <button id="orbitCW" class="btn" type="button">Orbit CW</button>
            <button id="orbitCCW" class="btn" type="button">Orbit CCW</button>
          </div>

          <div class="row sl">
            <label for="spinSlider">DAR Roll</label>
            <input id="spinSlider" type="range" min="0" max="3.0" step="0.01" value="1.20"/>
            <span class="tag" id="rollVal">1.20 s/rot</span>
          </div>

          <div class="row" style="font-size:.86rem;opacity:.85;line-height:1.35;">
            Tip: With <b>Air Roll Right</b>, rotate the stick clockwise. With <b>Air Roll Left</b>, rotate the stick counter-clockwise.
          </div>
        </div>

<!-- Dynamics -->
<div class="card">
  <h3>Dynamics</h3>

  <div class="row sl">
    <label for="accelPitch">Max Pitch Accel (°/s²)</label>
    <input id="accelPitch" type="range" min="120" max="1200" step="5" value="400"/>
    <span class="tag" id="accelPitchTag">400</span>
  </div>

  <div class="row sl">
    <label for="accelYaw">Max Yaw Accel (°/s²)</label>
    <input id="accelYaw" type="range" min="120" max="1200" step="5" value="400"/>
    <span class="tag" id="accelYawTag">400</span>
  </div>

  <div class="row sl">
    <label for="accelRoll">Max Roll Accel (°/s²)</label>
    <input id="accelRoll" type="range" min="120" max="1200" step="5" value="400"/>
    <span class="tag" id="accelRollTag">400</span>
  </div>

  <div class="row sl">
    <label for="curveRange">Input Curve</label>
    <input id="curveRange" type="range" min="1.0" max="2.2" step="0.05" value="1.0"/>
    <span class="tag" id="curveTag">1.00</span>
  </div>

  <!-- Rest of your sliders stay the same -->
  <div class="row sl">
    <label for="dampRange">Damp</label>
    <input id="dampRange" type="range" min="0.0" max="1.2" step="0.05" value="1.2"/>
    <span class="tag" id="dampTag">1.20</span>
  </div>

  <div class="row sl">
    <label for="brakeRange">Release Brake</label>
    <input id="brakeRange" type="range" min="0.0" max="6.0" step="0.1" value="6.0"/>
    <span class="tag" id="brakeTag">6.0</span>
  </div>

  <div class="row sl">
    <label for="wmaxRange">Max ω (global)</label>
    <input id="wmaxRange" type="range" min="6.0" max="24.0" step="0.5" value="6.0"/>
    <span class="tag" id="wmaxTag">6.0</span>
  </div>

  <div class="row sl">
    <label for="wmaxPitch">Max Pitch ω</label>
    <input id="wmaxPitch" type="range" min="4.0" max="24.0" step="0.5" value="8.5"/>
    <span class="tag" id="wmaxPitchTag">8.5</span>
  </div>

  <div class="row sl">
    <label for="wmaxYaw">Max Yaw ω</label>
    <input id="wmaxYaw" type="range" min="4.0" max="24.0" step="0.5" value="9.0"/>
    <span class="tag" id="wmaxYawTag">9.0</span>
  </div>

  <div class="row sl">
    <label for="tornadoAngle">Tornado Cone Angle</label>
    <input id="tornadoAngle" type="range" min="0.10" max="1.00" step="0.05" value="0.40"/>
    <span class="tag" id="tornadoAngleTag">0.40</span>
  </div>
</div>
<!-- Car -->
<div class="card">
  <h3>Car</h3>
  <div class="row sl">
    <label for="presetSel">Body</label>
    <select id="presetSel">
      <option value="placeholder">Placeholder (140×56×240)</option>
      <option value="octane" selected>Octane proportions</option>
      <option value="dominus">Dominus proportions</option>
    </select>
  </div>
</div>
        <!-- View / HUD -->
        <div class="card">
          <h3>View & HUD</h3>

          <div class="row">
            <button id="themeToggle" class="btn active" type="button">Night Mode</button>
          </div>

          <div class="row sl">
            <label for="zoomSlider">Zoom</label>
            <input id="zoomSlider" type="range" min="0.70" max="1.60" step="0.01" value="1.00" />
            <span class="tag" id="zoomVal">1.00×</span>
          </div>

          <div class="row sl">
            <label for="stickSizeSlider">Stick Size</label>
            <input id="stickSizeSlider" type="range" min="60" max="180" step="1" value="100" />
            <span class="tag" id="stickVal">100</span>
          </div>

          <div class="row sl">
            <label for="arrowSlider">Arrow Size</label>
            <input id="arrowSlider" type="range" min="0.60" max="4.00" step="0.01" value="4.00" />
            <span class="tag" id="arrowVal">4.00×</span>
          </div>
        </div>

        <!-- Gamepad -->
        <div class="card">
          <h3>Gamepad</h3>
          <div class="row">
            <button id="gpEnable" class="btn active" type="button">Enable</button>
            <span class="tag" id="gpStatus">Enabled (waiting for gamepad)</span>
          </div>
          <div class="row sl">
            <label for="gpPreset">Preset</label>
            <select id="gpPreset">
              <option value="ps5" selected>PS5 / DualSense</option>
              <option value="xinput">Generic XInput</option>
            </select>
          </div>
          <div class="row">
            <button id="gpRemap" class="btn" type="button">Remap Action…</button>
            <select id="gpAction">
              <option value="toggleDAR">Toggle DAR</option>
              <option value="rollLeft">Air Roll Left</option>
              <option value="rollRight">Air Roll Right</option>
              <option value="restart">Restart</option>
              <option value="orbitCW">Orbit Clockwise</option>
              <option value="orbitCCW">Orbit Counter-Clockwise</option>
              <option value="toggleTheme">Toggle Day/Night Mode</option>
              <option value="openMenu">Open/Close Menu</option>
            </select>
            <span class="tag" id="gpBindLabel">—</span>
          </div>
          <div class="row">
            <button id="gpResetDefaults" class="btn" type="button">Reset to Defaults</button>
          </div>
          <div class="row" style="font-size:.86rem;opacity:.85;line-height:1.35;">
            Tip: Left stick moves the on-screen stick. Remap any action, then press a button or push an axis to bind.
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- Hints -->
  <div id="joyHint">Hold outside the stick to reposition (UI hidden)</div>
  <div id="darHint">Tap to toggle roll • Hold to move</div>

<script type="module">
import * as THREE from "three";
import { GLTFLoader } from "https://unpkg.com/three@0.164.0/examples/jsm/loaders/GLTFLoader.js";

/* ====== Renderer / Scene / Camera ====== */
const gl = document.getElementById('gl');
const hud = document.getElementById('hud');
const renderer = new THREE.WebGLRenderer({canvas: gl, antialias: true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0xeef1f6, 900, 2200);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
const CAM_BASE = { y: 280, z: 760 };
camera.position.set(0, CAM_BASE.y, CAM_BASE.z);
scene.add(camera);

/* Lights */
const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 1.15);
directionalLight.position.set(-350, 700, 900);
directionalLight.castShadow = false;
scene.add(directionalLight);

/* Grid */
const grid = new THREE.Group();
const gridMain = new THREE.GridHelper(2600, 26, 0xd7dde6, 0xE5E9F1);
gridMain.material.opacity = 0.65;
gridMain.material.transparent = true;
grid.add(gridMain);
grid.rotation.x = -Math.PI/2;
grid.position.y = -160;
scene.add(grid);

/* Colors */
const COL_UP   = 0xff5c5c;
const COL_RIGHT= 0x4c8dff;
const COL_DOWN = 0x53d769;
const COL_LEFT = 0xffd166;

/* Materials */
const MAT_BODY  = new THREE.MeshPhongMaterial({color: 0xdfe5ef, shininess: 50, specular: 0x666666});
const MAT_GLASS = new THREE.MeshPhongMaterial({color: 0x9aa6b7, shininess: 40, specular: 0x222222, transparent:true, opacity:0.65});
const MAT_ACCENT= new THREE.MeshPhongMaterial({color: 0xcbd3df, shininess: 35, specular: 0x222222});
const MAT_DARK  = new THREE.MeshPhongMaterial({color: 0xaeb7c4, shininess: 28, specular: 0x222222});
const MAT_EDGE  = (hex)=> new THREE.LineBasicMaterial({color: hex});
const MAT_TIRE_F= new THREE.MeshLambertMaterial({color: 0x8a93a0});
const MAT_TIRE_B= new THREE.MeshLambertMaterial({color: 0x808896});
const MAT_HUB   = new THREE.MeshBasicMaterial({color: 0x5a6270});

/* Theme configuration */
let isDarkMode = true;
const THEMES = {
  dark: {
    body: '#ffffff',
    fog: 0xeef1f6,
    fogNear: 900,
    fogFar: 2200,
    ambient: 0xffffff,
    ambientIntensity: 0.8,
    directional: 0xffffff,
    directionalIntensity: 1.15,
    gridMain: 0xd7dde6,
    gridSub: 0xE5E9F1,
    gridOpacity: 0.65,
    gridY: -160
  },
  light: {
    body: '#1a1d24',
    fog: 0x2a3040,
    fogNear: 1000,
    fogFar: 2500,
    ambient: 0xffffff,
    ambientIntensity: 1.2,
    directional: 0xffffff,
    directionalIntensity: 0.8,
    gridMain: 0x3a4050,
    gridSub: 0x2d3542,
    gridOpacity: 0.85,
    gridY: -160
  }
};

function applyTheme(dark) {
  const theme = dark ? THEMES.dark : THEMES.light;

  // Update body background
  document.body.style.background = dark
    ? 'linear-gradient(180deg,#f6f7fb 0%,#eef1f6 45%,#e9edf3 100%)'
    : 'linear-gradient(180deg,#1a1d24 0%,#252a35 45%,#2a3040 100%)';

  // Update fog
  scene.fog.color.setHex(theme.fog);
  scene.fog.near = theme.fogNear;
  scene.fog.far = theme.fogFar;

  // Update lights
  ambientLight.intensity = theme.ambientIntensity;
  directionalLight.intensity = theme.directionalIntensity;

  // Update grid
  gridMain.material.color.setHex(theme.gridMain);
  gridMain.material.opacity = theme.gridOpacity;

  // Update renderer background
  renderer.setClearColor(theme.fog);

  // Update car materials for better visibility in day mode
  if (!dark) {
    // Day mode - brighten the car
    MAT_BODY.color.setHex(0xf5f7fa);
    MAT_GLASS.color.setHex(0xc5d0df);
    MAT_ACCENT.color.setHex(0xe0e6ef);
    MAT_DARK.color.setHex(0xd0d8e2);
    MAT_TIRE_F.color.setHex(0xb0b8c5);
    MAT_TIRE_B.color.setHex(0xa8b0be);
    MAT_HUB.color.setHex(0x8a92a0);
  } else {
    // Night mode - original colors
    MAT_BODY.color.setHex(0xdfe5ef);
    MAT_GLASS.color.setHex(0x9aa6b7);
    MAT_ACCENT.color.setHex(0xcbd3df);
    MAT_DARK.color.setHex(0xaeb7c4);
    MAT_TIRE_F.color.setHex(0x8a93a0);
    MAT_TIRE_B.color.setHex(0x808896);
    MAT_HUB.color.setHex(0x5a6270);
  }
}

/* Presets */
const presets = {
  placeholder: { hx:70, hy:28, hz:120 },
  octane:      { hx:85.65, hy:36.8, hz:120 },
  dominus:     { hx:77.9,  hy:29.3, hz:120 }
};
const gltfLoader = new GLTFLoader();

function loadCarModel(presetName) {
  const url = `models/${presetName}.glb`;
  console.log("Loading GLB:", url);

  gltfLoader.load(
    url,
    (gltf) => {
      const model = gltf.scene;

      model.traverse((o) => {
        if (o.isMesh) {
          o.castShadow = false;
          o.receiveShadow = false;
        }
      });

      // Center / height
      model.position.set(0, -BOX.hy, 0);

      // Scale the GLB
      const CAR_SCALE = 1.6;
      model.scale.set(CAR_SCALE, CAR_SCALE, CAR_SCALE);

      // Rotate so nose points along +Z instead of +X
      model.rotation.y = -Math.PI / 2;

      car.add(model);
    },
    undefined,
    (err) => {
      console.error("Failed to load", url, err);
    }
  );
}


/* Car builder */
let car=null, BOX=null;
let faceArrow=null, faceTip=null;

function clearCar(){
  if(!car) return;
  scene.remove(car);
  car.traverse(o=>{
    if (o.geometry) o.geometry.dispose();
    if (o.material) {
      if (Array.isArray(o.material)) {
        o.material.forEach(m => m.dispose && m.dispose());
      } else {
        o.material.dispose && o.material.dispose();
      }
    }
  });
  car = null;
}
function buildCar(boxDims, presetName="placeholder"){
  console.log("buildCar preset:", presetName);

  clearCar();
  BOX = boxDims;
  car = new THREE.Group();
  car.position.y = 110;
  scene.add(car);

  if (presetName === "placeholder") {
    // Hitbox body + fancy fake car
    const body = new THREE.Mesh(
      new THREE.BoxGeometry(BOX.hx*2, BOX.hy*2, BOX.hz*2),
      MAT_BODY
    );
    car.add(body);
    buildPlaceholderFancy();

    // colored face edges ONLY for placeholder
    const vFL = new THREE.Vector3(-BOX.hx, +BOX.hy, +BOX.hz);
    const vFR = new THREE.Vector3(+BOX.hx, +BOX.hy, +BOX.hz);
    const vBR = new THREE.Vector3(+BOX.hx, -BOX.hy, +BOX.hz);
    const vBL = new THREE.Vector3(-BOX.hx, -BOX.hy, +BOX.hz);
    addEdge(vFR, vFL, COL_UP);
    addEdge(vBR, vFR, COL_LEFT);
    addEdge(vBL, vBR, COL_DOWN);
    addEdge(vFL, vBL, COL_RIGHT);
  }

  // GLB for octane/dominus (no hitbox body, no edges)
  if (presetName === "octane" || presetName === "dominus") {
    loadCarModel(presetName);
  }

  // arrow setup stays the same
  const zFace = BOX.hz + 0.6;
  const faceGeom = new THREE.BufferGeometry().setFromPoints([
    new THREE.Vector3(0,0,zFace),
    new THREE.Vector3(0,0,zFace)
  ]);
  faceArrow = new THREE.Line(faceGeom, new THREE.LineBasicMaterial({color: 0x333333}));
  car.add(faceArrow);

  faceTip = new THREE.Mesh(new THREE.ConeGeometry(6,12,12), new THREE.MeshBasicMaterial({color: 0x333333}));
  faceTip.position.set(0,0,zFace);
  car.add(faceTip);
  faceArrow.visible = false;
  faceTip.visible = false;
}
function addEdge(a,b,color){
  const geo = new THREE.BufferGeometry().setFromPoints([a,b]);
  const line = new THREE.Line(geo, MAT_EDGE(color));
  car.add(line);
}
function addWheel(x, z, r=18, w=12){
  const g = new THREE.CylinderGeometry(r, r, w, 16);
  const front = new THREE.Mesh(g, MAT_TIRE_F);
  const back  = new THREE.Mesh(g, MAT_TIRE_B);
  front.rotation.z = Math.PI/2; back.rotation.z  = Math.PI/2;
  const y = -BOX.hy- r*0.55;
  front.position.set(x, y, z + w/2);
  back .position.set(x, y, z - w/2);
  const hub = new THREE.Mesh(new THREE.CylinderGeometry(r*0.35, r*0.35, w*0.6, 10), MAT_HUB);
  hub.rotation.z = Math.PI/2; hub.position.set(x, y, z);
  const grp = new THREE.Group(); grp.add(back, front, hub); car.add(grp);
}
function addCabin(width, height, length, yOffset, zOffset){
  const cabin = new THREE.Mesh(new THREE.BoxGeometry(width, height, length), MAT_GLASS);
  cabin.position.set(0, yOffset, zOffset);
  car.add(cabin);
}
function addSpoiler(width, thickness, depth, yOffset, zOffset){
  const spoiler = new THREE.Mesh(new THREE.BoxGeometry(width, thickness, depth), MAT_ACCENT);
  spoiler.position.set(0, yOffset, zOffset);
  const st1 = new THREE.Mesh(new THREE.BoxGeometry(thickness, yOffset*0.5, thickness), MAT_ACCENT);
  const st2 = st1.clone();
  st1.position.set(-width*0.35, yOffset*0.25, zOffset - depth*0.2);
  st2.position.set(+width*0.35, yOffset*0.25, zOffset - depth*0.2);
  car.add(spoiler, st1, st2);
}
function addBumper(width, height, depth, yOffset, zOffset){
  const bumper = new THREE.Mesh(new THREE.BoxGeometry(width, height, depth), MAT_DARK);
  bumper.position.set(0, yOffset, zOffset);
  car.add(bumper);
}
function addFlares(xw, zw, r=10, w=6){
  const hemi = new THREE.CylinderGeometry(r, r, w, 10, 1, false, 0, Math.PI);
  const mat = MAT_ACCENT;
  const y = -BOX.hy + r*0.2;
  function flare(px, pz, flip){
    const f = new THREE.Mesh(hemi, mat);
    f.rotation.z = Math.PI/2;
    f.rotation.y = flip? Math.PI : 0;
    f.position.set(px, y, pz);
    car.add(f);
  }
  flare(+xw+6, +zw, false);
  flare(-xw-6, +zw, true);
  flare(+xw+6, -zw, true);
  flare(-xw-6, -zw, false);
}
function buildPlaceholderFancy(){
  const xOff = BOX.hx-10, zOff = BOX.hz*0.68;
   addWheel(+xOff, -zOff);
  addWheel(-xOff, -zOff);
  addWheel(+xOff, +zOff);
  addWheel(-xOff, +zOff);
  
  addFlares(xOff, zOff, 10, 6);
  addCabin(BOX.hx*1.0, BOX.hy*0.9, BOX.hz*0.55, BOX.hy*0.65, -BOX.hz*0.1);
  addSpoiler(BOX.hx*1.0, 6, 24, BOX.hy*0.8, -BOX.hz*0.95);
  addBumper(BOX.hx*0.9, 10, 18, -BOX.hy*0.7, +BOX.hz*0.98);
}
function buildOctane(){
  const xOff = BOX.hx-6, zOff = BOX.hz*0.64;
  addWheel(+xOff, -zOff, 19, 12); addWheel(-xOff, -zOff, 19, 12);
  addWheel(+xOff, +zOff, 18, 12); addWheel(-xOff, +zOff, 18, 12);
  addFlares(xOff, zOff, 12, 7);
  addCabin(BOX.hx*0.95, BOX.hy*1.1, BOX.hz*0.60, BOX.hy*0.85, -BOX.hz*0.05);
  addSpoiler(BOX.hx*1.2, 6, 30, BOX.hy*0.9, -BOX.hz*1.02);
  addBumper(BOX.hx*0.85, 12, 20, -BOX.hy*0.6, +BOX.hz*1.02);
}
function buildDominus(){
  const xOff = BOX.hx-8, zOff = BOX.hz*0.70;
  addWheel(+xOff, -zOff, 18, 12); addWheel(-xOff, -zOff, 18, 12);
  addWheel(+xOff, +zOff, 18, 12); addWheel(-xOff, +zOff, 18, 12);
  addFlares(xOff, zOff, 11, 6);
  addCabin(BOX.hx*1.05, BOX.hy*0.75, BOX.hz*0.75, BOX.hy*0.6, -BOX.hz*0.05);
  addSpoiler(BOX.hx*0.9, 5, 18, BOX.hy*0.72, -BOX.hz*1.0);
  addBumper(BOX.hx*1.05, 10, 30, -BOX.hy*0.55, +BOX.hz*1.05);
}

/* HUD utils */
const hctx = hud.getContext('2d');
function sizeHud(){ hud.width = innerWidth; hud.height = innerHeight; }
sizeHud();
function Hclear(){hctx.setTransform(1,0,0,1,0,0); hctx.clearRect(0,0,hud.width,hud.height);}
function Hcircle(x,y,r,strokeStyle,width){hctx.beginPath();hctx.lineWidth=width;hctx.strokeStyle=strokeStyle;hctx.arc(x,y,r,0,Math.PI*2);hctx.stroke();}
function HfillCircle(x,y,r,fillStyle){hctx.beginPath();hctx.fillStyle=fillStyle;hctx.arc(x,y,r,0,Math.PI*2);hctx.fill();}
function Harc(x,y,r,a1,a2,strokeStyle,width){hctx.beginPath();hctx.lineWidth=width;hctx.strokeStyle=strokeStyle;hctx.arc(x,y,r,a1,a2);hctx.stroke();}
function Hline(x1,y1,x2,y2,strokeStyle,width){hctx.beginPath();hctx.lineWidth=width;hctx.strokeStyle=strokeStyle;hctx.moveTo(x1,y1);hctx.lineTo(x2,y2);hctx.stroke();}
function Htri(x,y,a,r,fillStyle){hctx.save();hctx.translate(x,y);hctx.rotate(a);hctx.beginPath();hctx.moveTo(0,-r);hctx.lineTo(r*0.9,r*0.9);hctx.lineTo(-r*0.9,r*0.9);hctx.closePath();hctx.fillStyle=fillStyle;hctx.fill();hctx.restore();}

/* Joystick */
let JOY_BASE_R = 100, JOY_KNOB_R = Math.round(JOY_BASE_R*0.32);
let JOY_CENTER = new THREE.Vector2(126, innerHeight-170);
let joyActive=false, joyVec = new THREE.Vector2(0,0), smJoy = new THREE.Vector2(0,0);
const STICK_TAU_MS=8, RELOCATE_HOLD_MS=250, STICK_MIN=0.02;
let activeId=null, relocating=false, holdTimer=null;
const COLS = {UP:'#ff5c5c', RIGHT:'#4c8dff', DOWN:'#53d769', LEFT:'#ffd166'};

function drawJoystick(){
  const cx=JOY_CENTER.x, cy=JOY_CENTER.y, r=JOY_BASE_R;
  const t=performance.now(); const pulse=1+0.06*Math.sin(t*0.008), halo=r*pulse+10;
  Hcircle(cx,cy,halo, 'rgba(76,141,255,0.28)', 8);
  Harc(cx,cy,r, -Math.PI/4,  Math.PI/4,   COLS.RIGHT, 12);
  Harc(cx,cy,r,  Math.PI/4,  3*Math.PI/4, COLS.UP,    12);
  Harc(cx,cy,r,  3*Math.PI/4,5*Math.PI/4, COLS.LEFT,  12);
  Harc(cx,cy,r,  5*Math.PI/4,7*Math.PI/4, COLS.DOWN,  12);
  Hcircle(cx,cy,r-18, '#b9c1cd', 2);
  Hline(cx-r+12,cy,cx+r-12,cy,'#cfd6e2',1.5);
  Hline(cx,cy-r+12,cx,cy+r-12,'#cfd6e2',1.5);
  const kx=cx+joyVec.x, ky=cy+joyVec.y;
  Hcircle(kx,ky,JOY_KNOB_R,'#4c8dff',4); HfillCircle(kx,ky,JOY_KNOB_R,'#0f1116');
  hctx.fillStyle='#222'; hctx.beginPath(); hctx.arc(cx,cy,3,0,Math.PI*2);hctx.fill();
}
function inJoyLoose(x,y){
  const dx=x-JOY_CENTER.x, dy=y-JOY_CENTER.y;
  const loose=JOY_BASE_R+28;
  const inC = (dx*dx+dy*dy) <= loose*loose;
  const inB = (Math.abs(dx)<=JOY_BASE_R) && (Math.abs(dy)<=JOY_BASE_R+40);
  return inC || inB;
}
function vecFromJoyPx(x,y){
  let dx=x-JOY_CENTER.x, dy=y-JOY_CENTER.y;
  const m=Math.hypot(dx,dy);
  if(m>JOY_BASE_R){const k=JOY_BASE_R/(m||1); dx*=k; dy*=k;}
  return new THREE.Vector2(dx,dy);
}
function clampJoyCenter(){
  JOY_CENTER.x = Math.max(JOY_BASE_R+20, Math.min(innerWidth -(JOY_BASE_R+20), JOY_CENTER.x));
  JOY_CENTER.y = Math.max(JOY_BASE_R+20, Math.min(innerHeight-(JOY_BASE_R+20), JOY_CENTER.y));
}

/* DAR button (toggle + relocate) */
let DAR_R = 44;
let DAR_CENTER = new THREE.Vector2(innerWidth-120, innerHeight-150);
let darOn = false, darRelocating = false, darHoldTimer = null, darPressT=0;

function drawDAR(){
  const cx=DAR_CENTER.x, cy=DAR_CENTER.y, r=DAR_R;
  HfillCircle(cx,cy,r, darOn ? 'rgba(0,102,255,0.18)' : 'rgba(24,26,32,0.75)');
  Hcircle(cx,cy,r, darOn ? '#4c8dff' : '#3a3d45', darOn ? 5 : 3);
  const a = (airRoll>0) ? Math.PI/2 : -Math.PI/2;
  Htri(cx,cy,a, r*0.55, darOn ? '#0e0f12' : '#e8e8ea');
  Hcircle(cx,cy,r-12, '#bdbdbd', 1.5);
}
function inDAR(x,y){
  const dx=x-DAR_CENTER.x, dy=y-DAR_CENTER.y;
  return (dx*dx+dy*dy) <= (DAR_R*DAR_R);
}
function clampDARCenter(){
  const m=DAR_R+20;
  DAR_CENTER.x = Math.max(m, Math.min(innerWidth - m, DAR_CENTER.x));
  DAR_CENTER.y = Math.max(m, Math.min(innerHeight - m, DAR_CENTER.y));
}

/* Hints */
const joyHint = document.getElementById('joyHint');
const darHint = document.getElementById('darHint');
function showHint(el,ms){ el.classList.add('show'); setTimeout(()=>el.classList.remove('show'), ms); }
function positionHints(){
  joyHint.style.left = (JOY_CENTER.x + JOY_BASE_R + 18)+'px';
  joyHint.style.top  = (JOY_CENTER.y - JOY_BASE_R - 18)+'px';
  darHint.style.left = (DAR_CENTER.x + DAR_R + 18)+'px';
  darHint.style.top  = (DAR_CENTER.y - DAR_R - 18)+'px';
}

/* MENU open/close */
const menuBtn=document.getElementById('menuBtn');
const menuOverlay=document.getElementById('menuOverlay');
const menuCloseBtn=document.getElementById('menuCloseBtn');
let chromeShown=false;

function openMenu(){
  chromeShown=true;
  menuBtn.classList.add('active');
  menuOverlay.style.display='block';
}
function closeMenu(){
  chromeShown=false;
  menuBtn.classList.remove('active');
  menuOverlay.style.display='none';
}
menuBtn.addEventListener('click',()=> chromeShown ? closeMenu() : openMenu());
menuCloseBtn.addEventListener('click', closeMenu);
menuOverlay.addEventListener('click',(e)=>{ if(e.target===menuOverlay) closeMenu(); });

/* Buttons / presets */
let airRoll = -1; // default to Air Roll Left
function setRoll(dir){
  airRoll=dir;
  document.getElementById('rollL').classList.toggle('active',dir>0);
  document.getElementById('rollR').classList.toggle('active',dir<0);
}
document.getElementById('rollL').addEventListener('click',()=>setRoll(+1));
document.getElementById('rollR').addEventListener('click',()=>setRoll(-1));

document.getElementById('restart').addEventListener('click',()=>{
  if (car) car.quaternion.identity();
  w.set(0,0,0);
  orbitOn = false;
  orbitDir = 1;
  document.getElementById('orbitCW').classList.remove('active');
  document.getElementById('orbitCCW').classList.remove('active');
  orbitPhase = 0;
  camera.position.set(0, 220, 650);
  camera.lookAt(0,0,0);
  if (faceArrow) faceArrow.visible = false;
  if (faceTip)   faceTip.visible   = false;
});
let orbitOn=false, orbitDir=1;
document.getElementById('orbitCW').addEventListener('click',()=>{
  orbitOn = true;
  orbitDir = 1;
  document.getElementById('orbitCW').classList.add('active');
  document.getElementById('orbitCCW').classList.remove('active');
});
document.getElementById('orbitCCW').addEventListener('click',()=>{
  orbitOn = true;
  orbitDir = -1;
  document.getElementById('orbitCCW').classList.add('active');
  document.getElementById('orbitCW').classList.remove('active');
});

/* Theme toggle */
document.getElementById('themeToggle').addEventListener('click',()=>{
  isDarkMode = !isDarkMode;
  applyTheme(isDarkMode);
  const btn = document.getElementById('themeToggle');
  btn.classList.toggle('active', isDarkMode);
  btn.textContent = isDarkMode ? 'Night Mode' : 'Day Mode';
});

/* Sliders / select */
const accelPitch=document.getElementById('accelPitch'), accelPitchTag=document.getElementById('accelPitchTag');
const accelYaw=document.getElementById('accelYaw'), accelYawTag=document.getElementById('accelYawTag');
const accelRoll=document.getElementById('accelRoll'), accelRollTag=document.getElementById('accelRollTag');
const curveRange=document.getElementById('curveRange'), curveTag=document.getElementById('curveTag');
const dampRange=document.getElementById('dampRange'),   dampTag=document.getElementById('dampTag');
const brakeRange=document.getElementById('brakeRange'), brakeTag=document.getElementById('brakeTag');
const wmaxRange=document.getElementById('wmaxRange'),   wmaxTag=document.getElementById('wmaxTag');
const wmaxPitchRange=document.getElementById('wmaxPitch'), wmaxPitchTag=document.getElementById('wmaxPitchTag');
const wmaxYawRange=document.getElementById('wmaxYaw'), wmaxYawTag=document.getElementById('wmaxYawTag');
const tornadoAngleRange=document.getElementById('tornadoAngle'), tornadoAngleTag=document.getElementById('tornadoAngleTag');
const spinSlider=document.getElementById('spinSlider'), rollVal=document.getElementById('rollVal');
const sizeSlider=document.getElementById('stickSizeSlider'), stickVal=document.getElementById('stickVal');
const zoomSlider=document.getElementById('zoomSlider'), zoomVal=document.getElementById('zoomVal');
const arrowSlider=document.getElementById('arrowSlider'), arrowVal=document.getElementById('arrowVal');
const presetSel=document.getElementById('presetSel');

let maxAccelPitch=parseFloat(accelPitch.value),
    maxAccelYaw=parseFloat(accelYaw.value),
    maxAccelRoll=parseFloat(accelRoll.value),
    inputPow=parseFloat(curveRange.value),
    damp=parseFloat(dampRange.value),
    brakeOnRelease=parseFloat(brakeRange.value),
    wMax=parseFloat(wmaxRange.value),
    wMaxPitch=parseFloat(wmaxPitchRange.value),
    wMaxYaw=parseFloat(wmaxYawRange.value),
    maxTornadoAngle=parseFloat(tornadoAngleRange.value),
    freeRollPeriod=parseFloat(spinSlider.value),
    zoom=parseFloat(zoomSlider.value),
    arrowScale=parseFloat(arrowSlider.value);

function syncTags(){
  accelPitchTag.textContent=maxAccelPitch.toFixed(0);
accelYawTag.textContent=maxAccelYaw.toFixed(0);
accelRollTag.textContent=maxAccelRoll.toFixed(0);
  curveTag.textContent=inputPow.toFixed(2);
  dampTag.textContent=damp.toFixed(2);
  brakeTag.textContent=brakeOnRelease.toFixed(1);
  wmaxTag.textContent=wMax.toFixed(1);
  wmaxPitchTag.textContent=wMaxPitch.toFixed(1);
  wmaxYawTag.textContent=wMaxYaw.toFixed(1);
  tornadoAngleTag.textContent=maxTornadoAngle.toFixed(2);
  rollVal.textContent = (freeRollPeriod > 0) ? `${freeRollPeriod.toFixed(2)} s/rot` : 'off';
  stickVal.textContent = String(Math.round(JOY_BASE_R));
  zoomVal.textContent = `${(zoom||1).toFixed(2)}×`;
  arrowVal.textContent = `${(arrowScale||1).toFixed(2)}×`;
}
syncTags();

accelPitch.addEventListener('input',()=>{maxAccelPitch=parseFloat(accelPitch.value)||400; syncTags();});
accelYaw.addEventListener('input',()=>{maxAccelYaw=parseFloat(accelYaw.value)||400; syncTags();});
accelRoll.addEventListener('input',()=>{maxAccelRoll=parseFloat(accelRoll.value)||400; syncTags();});
curveRange.addEventListener('input',()=>{inputPow=parseFloat(curveRange.value)||1.0; syncTags();});
dampRange .addEventListener('input',()=>{damp=parseFloat(dampRange.value)||1.20; syncTags();});
brakeRange.addEventListener('input',()=>{brakeOnRelease=parseFloat(brakeRange.value)||6.0; syncTags();});
wmaxRange .addEventListener('input',()=>{wMax=parseFloat(wmaxRange.value)||6.0; syncTags();});
wmaxPitchRange.addEventListener('input',()=>{wMaxPitch=parseFloat(wmaxPitchRange.value)||8.5; syncTags();});
wmaxYawRange.addEventListener('input',()=>{wMaxYaw=parseFloat(wmaxYawRange.value)||9.0; syncTags();});
tornadoAngleRange.addEventListener('input',()=>{maxTornadoAngle=parseFloat(tornadoAngleRange.value)||0.40; syncTags();});
spinSlider.addEventListener('input',()=>{freeRollPeriod=parseFloat(spinSlider.value)||0; syncTags();});
sizeSlider.addEventListener('input',()=>{JOY_BASE_R=parseInt(stickSizeSlider.value,10)||100; JOY_KNOB_R=Math.round(JOY_BASE_R*0.32); clampJoyCenter(); positionHints(); syncTags();});
zoomSlider.addEventListener('input',()=>{zoom=parseFloat(zoomSlider.value)||1.0; applyZoom(); syncTags();});
arrowSlider.addEventListener('input',()=>{arrowScale=parseFloat(arrowSlider.value)||4.0; syncTags();});
presetSel .addEventListener('change',()=>{
  const name = presetSel.value;
  buildCar(presets[name], name);
  car.quaternion.identity(); w.set(0,0,0);
});

/* Pointer handlers */
hud.addEventListener('pointerdown',(e)=>{
  try{hud.setPointerCapture(e.pointerId);}catch(_){}
  activeId=e.pointerId;

  if(inDAR(e.clientX,e.clientY)){
    darPressT = performance.now();
    clearTimeout(darHoldTimer);
    darHoldTimer = setTimeout(()=>{
      if(activeId===e.pointerId){
        darRelocating = true; showHint(darHint, 2000);
      }
    }, RELOCATE_HOLD_MS);
    e.preventDefault(); return;
  }

  if(inJoyLoose(e.clientX,e.clientY)){
    joyActive=true; joyVec = vecFromJoyPx(e.clientX,e.clientY);
  }else if(!chromeShown){
    clearTimeout(holdTimer);
    holdTimer = setTimeout(()=>{
      if(activeId===e.pointerId && !chromeShown){
        relocating = true; showHint(joyHint, 1800);
      }
    }, RELOCATE_HOLD_MS);
  }
  e.preventDefault();
},{passive:false});
hud.addEventListener('pointermove',(e)=>{
  if(activeId!==e.pointerId)return;
  if(darRelocating){ DAR_CENTER.set(e.clientX,e.clientY); clampDARCenter(); positionHints(); }
  else if(relocating){ JOY_CENTER.set(e.clientX,e.clientY); clampJoyCenter(); positionHints(); }
  else if(joyActive){ joyVec = vecFromJoyPx(e.clientX,e.clientY); }
  e.preventDefault();
},{passive:false});
function endPtr(e){
  if(activeId!==e.pointerId) return;
  try{hud.releasePointerCapture(e.pointerId);}catch(_){}
  clearTimeout(holdTimer); relocating=false;

  if(!darRelocating && inDAR(e.clientX,e.clientY)){
    const heldMs = performance.now() - darPressT;
    if(heldMs < RELOCATE_HOLD_MS){ darOn = !darOn; }
  }
  clearTimeout(darHoldTimer); darRelocating=false;

  if(joyActive){ joyActive = false; joyVec.set(0,0); }
  activeId=null; e.preventDefault();
}
hud.addEventListener('pointerup',endPtr,{passive:false});
hud.addEventListener('pointercancel',endPtr,{passive:false});

/* ====== GAMEPAD SUPPORT (PS5 / Generic, remappable) ====== */
const gpEnableBtn = document.getElementById('gpEnable');
const gpStatusTag = document.getElementById('gpStatus');
const gpPresetSel = document.getElementById('gpPreset');
const gpActionSel = document.getElementById('gpAction');
const gpRemapBtn  = document.getElementById('gpRemap');
const gpBindLabel = document.getElementById('gpBindLabel');

let gpEnabled = true;      // enabled by default
let gpIndex   = -1;
let gpRemapping = false;
let gpPrevActionPressed = {};
const GP_DEADZONE = 0.15;

let gpBindings = {
  toggleDAR:   { kind:'button', index: 1 },
  rollLeft:    { kind:'button', index: 4 },
  rollRight:   { kind:'button', index: 5 },
  restart:     { kind:'button', index: 9 },
  orbitCW:     { kind:'button', index: 2 },
  orbitCCW:    { kind:'button', index: 3 },
  toggleTheme: { kind:'button', index: 8 },
  openMenu:    { kind:'button', index: 6 }
};

const GP_PRESETS = {
  ps5: {
    toggleDAR:   { kind:'button', index: 1 },  // Circle
    rollLeft:    { kind:'button', index: 4 },  // L1
    rollRight:   { kind:'button', index: 5 },  // R1
    restart:     { kind:'button', index: 9 },  // Options
    orbitCW:     { kind:'button', index: 2 },  // Cross
    orbitCCW:    { kind:'button', index: 3 },  // Square
    toggleTheme: { kind:'button', index: 8 },  // Share
    openMenu:    { kind:'button', index: 6 }   // L2
  },
  xinput: {
    toggleDAR:   { kind:'button', index: 1 },  // B
    rollLeft:    { kind:'button', index: 4 },  // LB
    rollRight:   { kind:'button', index: 5 },  // RB
    restart:     { kind:'button', index: 9 },  // Start
    orbitCW:     { kind:'button', index: 2 },  // A
    orbitCCW:    { kind:'button', index: 3 },  // X
    toggleTheme: { kind:'button', index: 8 },  // Back
    openMenu:    { kind:'button', index: 6 }   // LT
  }
};

function bindingToLabel(b){
  if(!b) return '—';
  if(b.kind==='button') return `Button ${b.index}`;
  const d = b.dir>0 ? '+' : '−';
  return `Axis ${b.axis}${d}`;
}
function setBindingPreset(name){
  const p = GP_PRESETS[name] || GP_PRESETS.ps5;
  gpBindings = JSON.parse(JSON.stringify(p));
  updateBindLabel();
}
function updateBindLabel(){
  const act = gpActionSel.value;
  gpBindLabel.textContent = bindingToLabel(gpBindings[act]);
}

gpEnableBtn.addEventListener('click',()=>{
  gpEnabled = !gpEnabled;
  gpEnableBtn.classList.toggle('active', gpEnabled);
  gpStatusTag.textContent = gpEnabled ? 'Enabled' : 'Disabled';
});
gpPresetSel.addEventListener('change', ()=> setBindingPreset(gpPresetSel.value));
gpActionSel.addEventListener('change', updateBindLabel);
gpRemapBtn.addEventListener('click',()=>{
  gpRemapping = true;
  gpBindLabel.textContent = 'Press button / move axis…';
});
document.getElementById('gpResetDefaults').addEventListener('click',()=>{
  setBindingPreset(gpPresetSel.value);
  gpStatusTag.textContent = 'Bindings reset to defaults';
  setTimeout(() => {
    const { pad } = readPads();
    if (pad) gpStatusTag.textContent = `Connected: ${pad.id}`;
    else gpStatusTag.textContent = gpEnabled ? 'Enabled (waiting for gamepad)' : 'No gamepad';
  }, 2000);
});

setBindingPreset('ps5');
updateBindLabel();

addEventListener('gamepadconnected', (e)=>{
  if(gpIndex<0){ gpIndex = e.gamepad.index; }
  gpStatusTag.textContent = `Connected: ${e.gamepad.id}`;
});
addEventListener('gamepaddisconnected', (e)=>{
  if(e.gamepad.index===gpIndex){ gpIndex=-1; }
  gpStatusTag.textContent = gpEnabled ? 'Enabled (waiting for gamepad)' : 'No gamepad';
});

function readPads(){
  const arr = (navigator.getGamepads?.() || []);
  if(gpIndex<0){
    for(let i=0;i<arr.length;i++){
      const p = arr[i];
      if(p && p.mapping==='standard'){ gpIndex=i; break; }
    }
  }
  return { pad: (gpIndex>=0 ? arr[gpIndex] : null), all: arr };
}

function isPressedForBinding(pad, binding){
  if(!binding || !pad) return false;
  if(binding.kind==='button'){
    const b = pad.buttons[binding.index];
    return !!(b && (b.value||0) > 0.5);
  }
  if(binding.kind==='axis'){
    const v = pad.axes[b.axis] || 0;
    return binding.dir>0 ? (v>0.6) : (v<-0.6);
  }
  return false;
}

function execBinding(action){
  switch(action){
    case 'toggleDAR':
      darOn = !darOn;
      break;
    case 'rollLeft':
      setRoll(-1);
      break;
    case 'rollRight':
      setRoll(+1);
      break;
    case 'restart': {
      if (car) car.quaternion.identity();
      w.set(0,0,0);
      orbitOn = false;
      orbitDir = 1;
      document.getElementById('orbitCW').classList.remove('active');
      document.getElementById('orbitCCW').classList.remove('active');
      orbitPhase = 0;
      camera.position.set(0, 220, 650);
      camera.lookAt(0,0,0);
      if (faceArrow) faceArrow.visible = false;
      if (faceTip)   faceTip.visible   = false;
      break;
    }
    case 'orbitToggle':
      orbitOn = !orbitOn;
      orbitDir = orbitOn ? 1 : 1;
      if (orbitOn) {
        document.getElementById('orbitCW').classList.add('active');
        document.getElementById('orbitCCW').classList.remove('active');
      } else {
        document.getElementById('orbitCW').classList.remove('active');
        document.getElementById('orbitCCW').classList.remove('active');
      }
      break;
    case 'orbitCW':
      orbitOn = true;
      orbitDir = 1;
      document.getElementById('orbitCW').classList.add('active');
      document.getElementById('orbitCCW').classList.remove('active');
      break;
    case 'orbitCCW':
      orbitOn = true;
      orbitDir = -1;
      document.getElementById('orbitCCW').classList.add('active');
      document.getElementById('orbitCW').classList.remove('active');
      break;
    case 'toggleTheme':
      isDarkMode = !isDarkMode;
      applyTheme(isDarkMode);
      const themeBtn = document.getElementById('themeToggle');
      themeBtn.classList.toggle('active', isDarkMode);
      themeBtn.textContent = isDarkMode ? 'Night Mode' : 'Day Mode';
      break;
    case 'openMenu':
      if (chromeShown) closeMenu();
      else openMenu();
      break;
    default: break;
  }
}

function handleRemap(pad){
  if(!gpRemapping || !pad) return;
  for(let i=0;i<pad.buttons.length;i++){
    if(pad.buttons[i] && (pad.buttons[i].value||0) > 0.5){
      gpBindings[gpActionSel.value] = { kind:'button', index:i };
      gpRemapping = false;
      updateBindLabel();
      return;
    }
  }
  for(let a=0;a<pad.axes.length;a++){
    const v = pad.axes[a] || 0;
    if(Math.abs(v) > 0.6){
      gpBindings[gpActionSel.value] = { kind:'axis', axis:a, dir: (v>0? +1 : -1) };
      gpRemapping = false;
      updateBindLabel();
      return;
    }
  }
}

function updateGamepadInput(){
  if(!gpEnabled) return;
  const { pad } = readPads();
  if(!pad){ gpStatusTag.textContent = 'Enabled (waiting for gamepad)'; return; }
  gpStatusTag.textContent = `Connected: ${pad.id}`;

  if(gpRemapping){ handleRemap(pad); }

  // Left stick → on-screen stick (natural Y: up=up)
  if(!joyActive && !relocating && !darRelocating){
    const lx = pad.axes[0] || 0;
    const ly = pad.axes[1] || 0;
    const mag = Math.hypot(lx, ly);
    let nx = 0, ny = 0;
    if(mag > GP_DEADZONE){
      const k = (mag - GP_DEADZONE) / (1 - GP_DEADZONE);
      nx = (lx / (mag||1)) * k;
      ny = (ly / (mag||1)) * k;
    }
    joyVec.set(nx * JOY_BASE_R, ny * JOY_BASE_R);
  }

  // Fire actions on rising edge
  for(const action of Object.keys(gpBindings)){
    const nowPressed = isPressedForBinding(pad, gpBindings[action]);
    const wasPressed = !!gpPrevActionPressed[action];
    if(nowPressed && !wasPressed){ execBinding(action); }
    gpPrevActionPressed[action] = nowPressed;
  }
}

/* Physics (independent caps for Pitch/Yaw) */
let w = new THREE.Vector3(0,0,0);
const STICK_DEADZONE = STICK_MIN;
const KP_ROLL = 3.2, KD_ROLL = 0.25;

// === NEW VARIABLES - Add these here ===
let inputHistory = { x: [], y: [] };
const INPUT_HISTORY_SIZE = 3;
let prevAlpha = new THREE.Vector3(0, 0, 0);

// === HELPER FUNCTIONS ===
function smoothInput(jx, jy) {
  inputHistory.x.push(jx);
  inputHistory.y.push(jy);
  if (inputHistory.x.length > INPUT_HISTORY_SIZE) {
    inputHistory.x.shift();
    inputHistory.y.shift();
  }
  
  const avgX = inputHistory.x.reduce((a, b) => a + b, 0) / inputHistory.x.length;
  const avgY = inputHistory.y.reduce((a, b) => a + b, 0) / inputHistory.y.length;
  return { x: avgX, y: avgY };
}

function softClampAngularVelocity(w, max) {
  const mag = w.length();
  if (mag <= max) return;
  
  const excess = mag - max;
  const reduction = Math.min(1.0, excess / max);
  const scale = 1.0 - (reduction * 0.3);
  w.multiplyScalar(scale);
}

// Put these near your other physics constants:
const KpPitch = 18.0, KdPitch = 4.0;
const KpYaw   = 18.0, KdYaw   = 4.0;
const KpRoll  = 12.0, KdRoll  = 3.0;

function integrate(dt) {
  // --- 1. Smooth joystick position ---
  const a = 1 - Math.exp(-(dt * 1000) / Math.max(1, STICK_TAU_MS));
  smJoy.lerp(joyVec, a);

  const jx = smJoy.x / JOY_BASE_R;
  const jy = -smJoy.y / JOY_BASE_R; // up is positive
  let mag = Math.hypot(jx, jy);

  let eff = 0;
  let ux = 0, uy = 0;

  if (mag > STICK_DEADZONE) {
    const m2 = (mag - STICK_DEADZONE) / (1 - STICK_DEADZONE);
    const shaped = Math.pow(Math.max(0, m2), inputPow || 1.0); // 0..1
    eff = shaped;

    ux = -jx / (mag || 1); // right = +ux
    uy = jy  / (mag || 1); // up = +uy
  }

  // --- 2. Front-face arrow (same behavior as before, just using ux,uy,eff) ---
  if (faceArrow && faceTip) {
    const show = eff > 0.02;
    faceArrow.visible = show;
    faceTip.visible   = show;

    if (show) {
      const lenMax = Math.min(BOX.hx, BOX.hy) * 0.95;
      const len    = Math.max(10, lenMax * eff * (arrowScale || 1));
      const zFace  = BOX.hz + 0.6;

      const x2 = ux * len;
      const y2 = -uy * len;

      const pos = faceArrow.geometry.attributes.position.array;
      pos[0] = 0;  pos[1] = 0;  pos[2] = zFace;
      pos[3] = x2; pos[4] = y2; pos[5] = zFace;
      faceArrow.geometry.attributes.position.needsUpdate = true;

      const col = (Math.abs(x2) > Math.abs(y2))
        ? (x2 >= 0 ? COL_LEFT : COL_RIGHT)
        : (uy >= 0 ? COL_DOWN : COL_UP);
      faceArrow.material.color.setHex(col);
      faceTip.material.color.setHex(col);

      faceTip.position.set(x2, y2, zFace);
      const ang = Math.atan2(x2, -y2) + Math.PI;
      faceTip.rotation.set(0, 0, ang);
      const s = 0.95 * (arrowScale || 1);
      faceTip.scale.set(s, s, 1);
    }
  }

  // --- 3. Slider conversions (deg/s² → rad/s²) ---
  const maxAccelPitchRad = (maxAccelPitch * Math.PI) / 180;
  const maxAccelYawRad   = (maxAccelYaw   * Math.PI) / 180;
  const maxAccelRollRad  = (maxAccelRoll  * Math.PI) / 180;

  // --- 4. Desired angular velocities (rate control) ---
  let maxPitchSpeed = wMaxPitch;  // rad/s, slider already in "ω"
  let maxYawSpeed   = wMaxYaw;    // rad/s
  let targetRollSpeed = 0;        // rad/s

  // DAR tornado cone: shrink pitch/yaw authority while rolling
  if (darOn && freeRollPeriod > 0) {
    targetRollSpeed = airRoll * (2 * Math.PI) / freeRollPeriod;

    const minTornadoAngle = 0.10;
    const tornadoFactor = minTornadoAngle + eff * (maxTornadoAngle - minTornadoAngle);

    maxPitchSpeed *= tornadoFactor;
    maxYawSpeed   *= tornadoFactor;
  }

  // stick → desired spin rates
  const wx_des = maxPitchSpeed * eff * uy; // pitch
  const wy_des = maxYawSpeed   * eff * ux; // yaw
  const wz_des = targetRollSpeed;         // roll from DAR

  // --- 5. PD control → angular acceleration per axis ---
  const ax_des = KpPitch * (wx_des - w.x) - KdPitch * w.x;
  const ay_des = KpYaw   * (wy_des - w.y) - KdYaw   * w.y;
  const az_des = KpRoll  * (wz_des - w.z) - KdRoll  * w.z;

  const ax = THREE.MathUtils.clamp(ax_des, -maxAccelPitchRad, maxAccelPitchRad);
  const ay = THREE.MathUtils.clamp(ay_des, -maxAccelYawRad,   maxAccelYawRad);
  const az = THREE.MathUtils.clamp(az_des, -maxAccelRollRad,  maxAccelRollRad);

  // --- 6. Integrate angular velocity ---
  w.x += ax * dt;
  w.y += ay * dt;
  w.z += az * dt;

  // --- 7. Damping + release brake ---
  const noStick = eff < 0.02;
  const dampEff = (damp || 0) + ((noStick && !darOn) ? (brakeOnRelease || 0) : 0);
  const scale = Math.exp(-dampEff * dt);
  w.multiplyScalar(scale);

  // --- 8. Per-axis caps + global cap ---
  if (Math.abs(w.x) > wMaxPitch) w.x = Math.sign(w.x) * wMaxPitch;
  if (Math.abs(w.y) > wMaxYaw)   w.y = Math.sign(w.y) * wMaxYaw;

  const wMag = w.length();
  if (wMag > wMax) {
    w.multiplyScalar(wMax / wMag);
  }

  // --- 9. Quaternion integration (unchanged) ---
  const wx = w.x, wy = w.y, wz = w.z, halfdt = 0.5 * dt;
  const q = car.quaternion;
  const rw = -q.x * wx - q.y * wy - q.z * wz;
  const rx =  q.w * wx + q.y * wz - q.z * wy;
  const ry =  q.w * wy + q.z * wx - q.x * wz;
  const rz =  q.w * wz + q.x * wy - q.y * wx;
  q.w += rw * halfdt;
  q.x += rx * halfdt;
  q.y += ry * halfdt;
  q.z += rz * halfdt;
  q.normalize();
}
/* Camera zoom/orbit *//* Camera zoom/orbit */
let orbitPhase=0;

function applyZoom(){
  const f = Math.max(0.7, Math.min(1.6, zoom||1));
  const dist = CAM_BASE.z / f;
  const h = CAM_BASE.y / f;
  if(!orbitOn){
    camera.position.set(0, h, dist);
    camera.lookAt(0, car ? car.position.y : 0, 0);
  }
}

function orbitStep(t){
  const f = Math.max(0.7, Math.min(1.6, zoom||1));
  const R = (CAM_BASE.z / f);
  const h = (CAM_BASE.y / f);
  const sp = 0.35 * orbitDir;
  const x = Math.sin(t*sp)*R;
  const z = Math.cos(t*sp)*R;
  camera.position.set(x, h, z);
  camera.lookAt(0, car ? car.position.y : 0, 0);
}

/* XYZ Gizmo */
/* XYZ Gizmo */
const gizmoRect = document.getElementById('gizmoFrame').getBoundingClientRect();
const gizmoScene = new THREE.Scene();
const gizmoCam = new THREE.PerspectiveCamera(40, gizmoRect.width/gizmoRect.height, 0.1, 100);
gizmoCam.position.set(0,0,6);
const gizmoAxes = new THREE.AxesHelper(3.2);
gizmoScene.add(gizmoAxes);
const gizmoTarget = new THREE.Object3D();
gizmoScene.add(gizmoTarget);
gizmoAxes.position.copy(gizmoTarget.position);

/* Render HUD & loop */
function renderHUD(){ Hclear(); drawJoystick(); drawDAR(); }

let lastT = performance.now()/1000;
function tick(){
  const t = performance.now()/1000;
  const dt = Math.min(0.033, Math.max(0.001, t - lastT));
  lastT = t;

  if(orbitOn){ orbitPhase += dt; orbitStep(orbitPhase); }

  updateGamepadInput();
  integrate(dt);

  renderer.setScissorTest(false);
  renderer.setViewport(0,0,innerWidth,innerHeight);
  renderer.render(scene, camera);

  if(car){
    gizmoTarget.quaternion.copy(car.quaternion);
    gizmoAxes.quaternion.copy(gizmoTarget.quaternion);
  }
  const gf = document.getElementById('gizmoFrame').getBoundingClientRect();
  const sx = Math.floor(gf.left), sy = Math.floor(innerHeight - gf.bottom);
  const sw = Math.floor(gf.width), sh = Math.floor(gf.height);
  renderer.setScissorTest(true);
  renderer.setScissor(sx,sy,sw,sh);
  renderer.setViewport(sx,sy,sw,sh);
  renderer.render(gizmoScene, gizmoCam);
  renderer.setScissorTest(false);

  renderHUD();
  requestAnimationFrame(tick);
}

/* Resize & boot */
function resize(){
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  sizeHud(); clampJoyCenter(); clampDARCenter(); positionHints(); applyZoom();
}
addEventListener('resize', resize);

buildCar(presets.octane, "octane");
setRoll(-1);           // default Air Roll Left
positionHints();
applyZoom();
applyTheme(isDarkMode); // Initialize theme
requestAnimationFrame(tick);
</script>
</body>
</html>
