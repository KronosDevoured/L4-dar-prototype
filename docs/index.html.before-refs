<!DOCTYPE html>
<html lang="en">
    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.164.0/build/three.module.js"
  }
}
</script>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>L4 Aerial Car Control Tool</title>
<link rel="icon" type="image/svg+xml" href="favicon.svg" />
<style>
  /* === CSS BASE START === */
  html,body{margin:0;padding:0;height:100%;background:#ffffff;color:#0e0f12;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overscroll-behavior:none}
  body{background:linear-gradient(180deg,#f6f7fb 0%,#eef1f6 45%,#e9edf3 100%);}
  *, *::before, *::after{box-sizing:border-box}
  *{-webkit-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none}
  #gl{position:fixed;inset:0;z-index:0;display:block}
  #hud{position:fixed;inset:0;z-index:1;display:block;touch-action:none}
  /* === CSS BASE END === */

  /* === HAMBURGER === */
  #menuBtn{
    position:fixed;top:.6rem;right:.6rem;z-index:3;width:44px;height:44px;
    border-radius:12px;border:1px solid #3a3d45;background:#181a20;display:grid;place-items:center;
    box-shadow:0 2px 10px rgba(0,0,0,.25)
  }
  #menuBtn .bar{display:block;width:20px;height:2px;background:#e8e8ea;margin:3px 0}
  #menuBtn.active{background:#0066ff;border-color:#4c8dff}

  /* === THEME BUTTON (Sun/Moon) === */
  #themeBtn{
    position:fixed;top:.6rem;right:3.5rem;z-index:3;width:44px;height:44px;
    border:none;background:transparent;font-size:1.8rem;cursor:pointer;
    display:grid;place-items:center;padding:0;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,.3));
  }
  #themeBtn:hover{transform:scale(1.1)}
  #themeBtn:active{transform:scale(0.95)}

  /* Fullscreen button */
  #fullscreenBtn{
    position:fixed;top:.6rem;right:7rem;z-index:3;width:44px;height:44px;
    border:2px solid #4c8dff;background:rgba(76,141,255,0.15);
    font-size:2rem;cursor:pointer;border-radius:8px;
    display:grid;place-items:center;padding:0;
    filter: drop-shadow(0 2px 8px rgba(76,141,255,.4));
    color:#4c8dff;
  }
  #fullscreenBtn:hover{transform:scale(1.1);background:rgba(76,141,255,0.25);}
  #fullscreenBtn:active{transform:scale(0.95)}

  /* === OVERLAY MENU PANEL === */
  #menuOverlay{
    position:fixed; inset:0; z-index:4; display:none;
    background:rgba(10,12,16,0.45); -webkit-backdrop-filter: blur(3px); backdrop-filter: blur(3px);
    overflow-x:hidden;
  }
  #menuPanel{
    position:absolute; left:50%; top:12vh; transform:translateX(-50%);
    width:min(960px, calc(100vw - 2rem)); max-height:76vh; overflow:auto;
    background:rgba(24,26,32,.96); color:#e8e8ea; border:1px solid #3a3d45; border-radius:14px;
    box-shadow:0 20px 60px rgba(0,0,0,.35);
    overflow-x:hidden;
  }
  .mp-header{
    position:sticky; top:0; background:rgba(24,26,32,.98); z-index:1;
    padding:.9rem clamp(.8rem, 2vw, 1rem); border-bottom:1px solid #33373f; display:flex; align-items:center; justify-content:space-between;
  }
  .mp-title{font-weight:700;letter-spacing:.2px}
  .mp-close{border:1px solid #3a3d45;background:#181a20;color:#e8e8ea;border-radius:10px;padding:.35rem .6rem;font-weight:600}
  .mp-body{
    padding:clamp(.6rem,2vw,1rem);
    display:grid; grid-template-columns: 1fr; gap:14px;
  }

  .card{
    background:#15171d; border:1px solid #33373f; border-radius:12px; padding:.9rem;
  }
  .card h3{
    margin:.1rem 0 .7rem; font-size:1rem; opacity:.95; cursor:pointer; user-select:none;
    display:flex; align-items:center; justify-content:space-between;
  }
  .card h3:hover{opacity:1; color:#4c8dff;}
  .card h3::after{
    content:'â–¼'; font-size:.8rem; transition: transform 0.2s;
  }
  .card.collapsed h3::after{
    transform: rotate(-90deg);
  }
  .card-content{
    overflow:hidden; transition: max-height 0.3s ease, opacity 0.2s ease;
  }
  .card.collapsed .card-content{
    max-height:0 !important; opacity:0;
  }
  .row{display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; margin:.45rem 0; width:100%;}
  .tip{
    font-size:.86rem; opacity:.85; line-height:1.5; margin:.5rem 0;
    padding:.5rem .7rem; background:rgba(255,255,255,.03);
    border-left:3px solid #4c8dff; border-radius:4px;
  }
  .btn{border:1px solid #3a3d45;padding:.45rem .7rem;border-radius:999px;background:#181a20;color:#e8e8ea;font-weight:600;letter-spacing:.2px;cursor:pointer}
  .btn.active{background:#0066ff;border-color:#4c8dff}
  .tag{
    background:#181a20;border:1px solid #3a3d45;padding:.25rem .5rem;
    border-radius:999px;font-size:.82rem;white-space:nowrap;
    cursor:text;user-select:text;
  }
  .tag:hover{border-color:#4c8dff}
  .tag:focus{outline:2px solid #4c8dff;background:#1f2229}

  .sl{
    display:flex; align-items:center; gap:.6rem; flex-wrap:nowrap;
    width:100%; min-width:0;
  }
  .sl label{
    font-size:.88rem; opacity:.92; flex:0 0 150px; min-width:120px; max-width:220px;
  }
  .sl input[type=range]{
    accent-color:#4c8dff;
    flex:1 1 auto; min-width:0; max-width:100%; width:100%;
  }
  .sl .tag{flex:0 0 auto}

  @media (max-width:520px){
    .sl{flex-wrap:wrap}
    .sl label{flex:1 0 100%}
    .sl input[type=range]{flex:1 0 100%}
    .sl .tag{margin-left:auto}
  }

  select{background:#181a20;color:#e8e8ea;border:1px solid #3a3d45;border-radius:10px;padding:.35rem .5rem;max-width:100%}

  /* Hints (stick/DAR) */
  #joyHint,#darHint{position:fixed; z-index:2; pointer-events:none;background:rgba(24,26,32,.92); border:1px solid #3a3d45; color:#cfd3dc;
    padding:.35rem .55rem; border-radius:10px; font-size:.85rem; white-space:nowrap; transform:translate(-50%,-50%); opacity:0; transition:opacity .25s ease;}
  #joyHint.show,#darHint.show{opacity:1;}

  /* XYZ gizmo frame */
  #gizmoFrame{
    position:fixed; right:.6rem; top:64px; width:84px; height:84px; z-index:2;
    border-radius:10px; border:1px solid #3a3d45; background:rgba(24,26,32,.5);
    box-shadow:0 8px 24px rgba(0,0,0,.2); pointer-events:none;
  }
</style>
</head>
<body>
  <!-- CANVASES -->
  <canvas id="gl"></canvas>
  <canvas id="hud"></canvas>
  <div id="gizmoFrame"></div>

  <!-- HAMBURGER -->
  <button id="menuBtn" type="button" title="Open Menu"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button>

  <!-- FULLSCREEN TOGGLE -->
  <button id="fullscreenBtn" type="button" title="Toggle Fullscreen">â›¶</button>

  <!-- THEME TOGGLE (Sun/Moon) -->
  <button id="themeBtn" type="button" title="Toggle Day/Night Mode">ðŸŒ™</button>

  <!-- OVERLAY MENU -->
  <div id="menuOverlay">
    <div id="menuPanel">
      <div class="mp-header">
        <div class="mp-title">L4 Controls & Settings</div>
        <button class="mp-close" id="menuCloseBtn" type="button">Close</button>
      </div>
      <div class="mp-body">

        <!-- Rotation -->
        <div class="card">
          <h3>Rotation</h3>
          <div class="row">
            <button id="rollL" class="btn" type="button">Air Roll Left</button>
            <button id="rollR" class="btn active" type="button">Air Roll Right</button>
            <button id="rollFree" class="btn" type="button">Air Roll (Free)</button>
            <button id="ringMode" class="btn" type="button">Ring Mode</button>
            <button id="restart" class="btn" type="button">Restart</button>
            <button id="orbitCW" class="btn" type="button">Orbit CW</button>
            <button id="orbitCCW" class="btn" type="button">Orbit CCW</button>
          </div>

          <div class="row">
            <label>Air Roll Mode:</label>
            <button id="toggleMode" class="btn active" type="button">Toggle</button>
          </div>

          <div class="tip">
            <b>Tip:</b> With Air Roll Right, rotate the stick clockwise. With Air Roll Left, rotate the stick counter-clockwise.
          </div>
        </div>

<!-- Dynamics -->
<div class="card">
  <h3>Dynamics</h3>

  <div class="row">
    <button id="resetPhysicsDefaults" class="btn" type="button">Reset to Defaults</button>
  </div>

  <div class="row sl">
    <label for="accelPitch">Max Pitch Accel (Â°/sÂ²)</label>
    <input id="accelPitch" type="range" min="120" max="1200" step="5" value="714"/>
    <span class="tag" id="accelPitchTag">714</span>
  </div>

  <div class="row sl">
    <label for="accelYaw">Max Yaw Accel (Â°/sÂ²)</label>
    <input id="accelYaw" type="range" min="120" max="1200" step="5" value="521"/>
    <span class="tag" id="accelYawTag">521</span>
  </div>

  <div class="row sl">
    <label for="accelRoll">Max Roll Accel (Â°/sÂ²)</label>
    <input id="accelRoll" type="range" min="120" max="2400" step="5" value="2153"/>
    <span class="tag" id="accelRollTag">2153</span>
  </div>

  <div class="row sl">
    <label for="curveRange">Input Curve</label>
    <input id="curveRange" type="range" min="1.0" max="2.2" step="0.05" value="1.0"/>
    <span class="tag" id="curveTag">1.00</span>
  </div>

  <div class="row sl">
    <label for="dampRange">Damp (No-DAR)</label>
    <input id="dampRange" type="range" min="0.0" max="6.0" step="0.05" value="2.96"/>
    <span class="tag" id="dampTag">2.96</span>
  </div>

  <div class="row sl">
    <label for="dampDARRange">Damp (DAR)</label>
    <input id="dampDARRange" type="range" min="0.0" max="6.0" step="0.05" value="4.35"/>
    <span class="tag" id="dampDARTag">4.35</span>
  </div>

  <div class="row sl">
    <label for="brakeRange">Release Brake</label>
    <input id="brakeRange" type="range" min="0.0" max="6.0" step="0.1" value="0.0"/>
    <span class="tag" id="brakeTag">0.0</span>
  </div>

  <div class="row sl">
    <label for="wmaxRange">Max Ï‰ (global)</label>
    <input id="wmaxRange" type="range" min="4.0" max="24.0" step="0.1" value="5.5"/>
    <span class="tag" id="wmaxTag">5.5</span>
  </div>

  <div class="row sl">
    <label for="wmaxPitch">Max Pitch Ï‰</label>
    <input id="wmaxPitch" type="range" min="4.0" max="24.0" step="0.5" value="24.0"/>
    <span class="tag" id="wmaxPitchTag">24.0</span>
  </div>

  <div class="row sl">
    <label for="wmaxYaw">Max Yaw Ï‰</label>
    <input id="wmaxYaw" type="range" min="4.0" max="24.0" step="0.5" value="24.0"/>
    <span class="tag" id="wmaxYawTag">24.0</span>
  </div>

  <div class="row sl">
    <label for="wmaxRoll">Max Roll Ï‰</label>
    <input id="wmaxRoll" type="range" min="4.0" max="24.0" step="0.5" value="24.0"/>
    <span class="tag" id="wmaxRollTag">24.0</span>
  </div>
</div>
<!-- Car -->
<div class="card">
  <h3>Car</h3>
  <div class="row sl">
    <label for="presetSel">Body</label>
    <select id="presetSel">
      <option value="placeholder">Placeholder (140Ã—56Ã—240)</option>
      <option value="octane" selected>Octane proportions</option>
      <option value="dominus">Dominus proportions</option>
    </select>
  </div>
</div>
        <!-- View / HUD -->
        <div class="card">
          <h3>View & HUD</h3>

          <div class="row">
            <button id="arrowToggle" class="btn active" type="button">Show Arrow</button>
            <button id="circleToggle" class="btn active" type="button">Show Circle</button>
          </div>

          <div class="row sl">
            <label for="zoomSlider">Zoom</label>
            <input id="zoomSlider" type="range" min="0.20" max="4.00" step="0.01" value="1.00" />
            <span class="tag" id="zoomVal">1.00Ã—</span>
          </div>

          <div class="row sl">
            <label for="stickSizeSlider">Stick Size</label>
            <input id="stickSizeSlider" type="range" min="60" max="180" step="1" value="100" />
            <span class="tag" id="stickVal">100</span>
          </div>

          <div class="row sl">
            <label for="arrowSlider">Arrow Size</label>
            <input id="arrowSlider" type="range" min="0.60" max="4.00" step="0.01" value="4.00" />
            <span class="tag" id="arrowVal">4.00Ã—</span>
          </div>

          <div class="row sl">
            <label for="circleScale">Circle Scale</label>
            <input id="circleScale" type="range" min="0.2" max="2.0" step="0.05" value="0.3"/>
            <span class="tag" id="circleScaleTag">0.30Ã—</span>
          </div>

          <div class="row sl">
            <label for="circleTilt">Circle Tilt Angle</label>
            <input id="circleTilt" type="range" min="0" max="45" step="1" value="34"/>
            <span class="tag" id="circleTiltTag">38Â°</span>
          </div>

          <div class="row sl">
            <label for="circleTiltModifier">Circle Tilt Modifier</label>
            <input id="circleTiltModifier" type="range" min="-45" max="45" step="1" value="0"/>
            <span class="tag" id="circleTiltModifierTag">0Â°</span>
          </div>

          <div class="row sl">
            <label for="brightnessSlider">Car Brightness</label>
            <input id="brightnessSlider" type="range" min="0.5" max="3.0" step="0.1" value="1.0" />
            <span class="tag" id="brightnessVal">1.00Ã—</span>
          </div>
        </div>

        <!-- Ring Mode Settings -->
        <div class="card">
          <h3>Ring Mode</h3>

          <div class="row">
            <label for="ringDifficulty">Difficulty</label>
            <select id="ringDifficulty">
              <option value="easy">Easy</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Hard</option>
            </select>
          </div>

          <div class="row sl">
            <label for="ringCameraSpeed">Camera Transition Speed</label>
            <input id="ringCameraSpeed" type="range" min="0.01" max="0.5" step="0.01" value="0.1" />
            <span class="tag" id="ringCameraSpeedVal">0.10</span>
          </div>

          <div class="tip">
            <b>Ring Mode:</b> Navigate through rings using boost. Lower camera speed = slower, smoother transitions to next ring.
            <br><br>
            <b>Difficulty:</b><br>
            â€¢ Easy: Large rings, slower speed, simple patterns<br>
            â€¢ Normal: Balanced challenge<br>
            â€¢ Hard: Smaller rings, faster speed, complex patterns
          </div>
        </div>

        <!-- Audio Settings -->
        <div class="card">
          <h3>Audio</h3>
          <div class="row">
            <button id="toggleSounds" class="btn active" type="button">Game Sounds</button>
            <span class="tag" id="soundsStatus">Enabled</span>
          </div>
          <div class="row">
            <button id="toggleMusic" class="btn active" type="button">Background Music</button>
            <span class="tag" id="musicStatus">Enabled</span>
          </div>
          <div class="tip">
            <b>Game Sounds:</b> Ring pass/miss sounds and boost rumble<br>
            <b>Background Music:</b> 8-bit style music during Ring Mode
          </div>
        </div>

        <!-- Gamepad -->
        <div class="card">
          <h3>Gamepad</h3>
          <div class="row">
            <button id="gpEnable" class="btn active" type="button">Enable</button>
            <span class="tag" id="gpStatus">Enabled (waiting for gamepad)</span>
          </div>
          <div class="row sl">
            <label for="gpPreset">Preset</label>
            <select id="gpPreset">
              <option value="ps5" selected>PS5 / DualSense</option>
              <option value="xinput">Generic XInput</option>
            </select>
          </div>
          <div class="row">
            <button id="gpRemap" class="btn" type="button">Remap Actionâ€¦</button>
            <select id="gpAction" aria-label="Select action to remap">
              <option value="toggleDAR">Toggle DAR</option>
              <option value="rollLeft">Air Roll Left</option>
              <option value="rollRight">Air Roll Right</option>
              <option value="rollFree">Air Roll (Free)</option>
              <option value="boost">Boost (Ring Mode)</option>
              <option value="pause">Pause (Ring Mode)</option>
              <option value="restart">Restart</option>
              <option value="orbitCW">Orbit Clockwise</option>
              <option value="orbitCCW">Orbit Counter-Clockwise</option>
              <option value="toggleTheme">Toggle Day/Night Mode</option>
              <option value="openMenu">Open/Close Menu</option>
            </select>
            <span class="tag" id="gpBindLabel">â€”</span>
          </div>
          <div class="row">
            <button id="gpResetDefaults" class="btn" type="button">Reset to Defaults</button>
          </div>
          <div class="tip">
            <b>Tip:</b> Left stick moves the on-screen stick. Remap any action, then press a button or push an axis to bind.
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- Hints -->
  <div id="joyHint">Hold outside the stick to reposition (UI hidden)</div>
  <div id="darHint">Tap to toggle roll â€¢ Hold to move</div>

<script type="module">
// Version: 2025-11-29-v2 (localStorage persistence fix)
import * as THREE from "three";

// Import modular components
import * as CONST from './js/modules/constants.js';
import * as Audio from './js/modules/audio.js';
import * as Settings from './js/modules/settings.js';
import * as Car from './js/modules/car.js';
import * as Rendering from './js/modules/rendering.js';
import * as Input from './js/modules/input.js';

/* ====== Renderer / Scene / Camera ====== */
const gl = document.getElementById('gl');
const hud = document.getElementById('hud');
const renderer = new THREE.WebGLRenderer({canvas: gl, antialias: true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);

// Detect if on mobile/tablet or desktop
const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent)
  || (navigator.maxTouchPoints && navigator.maxTouchPoints > 2);
const isDesktop = !isMobile;
console.log('Device type:', isMobile ? 'Mobile/Tablet' : 'Desktop');

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0xeef1f6, 900, 2200);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
camera.position.set(0, CONST.CAM_BASE.y, CONST.CAM_BASE.z);
scene.add(camera);

/* Lights */
const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 1.15);
directionalLight.position.set(-350, 700, 900);
directionalLight.castShadow = false;
scene.add(directionalLight);

/* Grid - expanded to look infinite */
const grid = new THREE.Group();
const gridMain = new THREE.GridHelper(10000, 100, 0xd7dde6, 0xE5E9F1); // 10x larger, more divisions
gridMain.material.opacity = 0.65;
gridMain.material.transparent = true;
gridMain.material.depthWrite = false; // Prevent z-fighting
grid.add(gridMain);
grid.rotation.x = -Math.PI/2;
grid.position.y = -160;
scene.add(grid);

/* Theme configuration */
let isDarkMode; // Will be initialized from localStorage
const THEMES = {
  dark: {
    body: '#000000',
    fog: 0x000000,
    fogNear: 1000,
    fogFar: 2500,
    ambient: 0xffffff,
    ambientIntensity: 1.5,
    directional: 0xffffff,
    directionalIntensity: 1.2,
    gridMain: 0x4a5060,
    gridSub: 0x353945,
    gridOpacity: 0.7,
    gridY: -160
  },
  light: {
    body: '#ffffff',
    fog: 0xeef1f6,
    fogNear: 900,
    fogFar: 2200,
    ambient: 0xffffff,
    ambientIntensity: 0.8,
    directional: 0xffffff,
    directionalIntensity: 1.15,
    gridMain: 0x8a95a5,
    gridSub: 0xb5bec8,
    gridOpacity: 0.85,
    gridY: -160
  }
};

function applyTheme(dark) {
  const theme = dark ? THEMES.dark : THEMES.light;

  // Update body background
  document.body.style.background = dark
    ? '#000000'
    : 'linear-gradient(180deg,#f6f7fb 0%,#eef1f6 45%,#e9edf3 100%)';

  // Update fog
  scene.fog.color.setHex(theme.fog);
  scene.fog.near = theme.fogNear;
  scene.fog.far = theme.fogFar;

  // Update lights with brightness multiplier
  const brightness = dark ? brightnessDark : brightnessLight;
  ambientLight.intensity = theme.ambientIntensity * brightness;
  directionalLight.intensity = theme.directionalIntensity * brightness;

  // Update grid
  gridMain.material.color.setHex(theme.gridMain);
  gridMain.material.opacity = theme.gridOpacity;

  // Update renderer background
  renderer.setClearColor(theme.fog);

  // Update car materials for better visibility in day mode
  Car.updateCarTheme(dark);
}

/* HUD utils */
Rendering.initHUD(hud);

// Input module will be initialized after all necessary functions are defined
const COLS = {UP:'#ff5c5c', RIGHT:'#4c8dff', DOWN:'#53d769', LEFT:'#ffd166'};

/* Touch controls, DAR button, Boost button, and Hints - all managed by Input module */

/* MENU open/close */
const menuBtn=document.getElementById('menuBtn');
const menuOverlay=document.getElementById('menuOverlay');
const menuCloseBtn=document.getElementById('menuCloseBtn');
let chromeShown=false;

function openMenu(){
  chromeShown=true;
  Input.setChromeShown(true);
  menuBtn.classList.add('active');
  menuOverlay.style.display='block';

  // Initialize collapsible cards on first open
  initCollapsibleCards();
}
function closeMenu(){
  chromeShown=false;
  Input.setChromeShown(false);
  menuBtn.classList.remove('active');
  menuOverlay.style.display='none';
}
menuBtn.addEventListener('click',()=> chromeShown ? closeMenu() : openMenu());
menuCloseBtn.addEventListener('click', closeMenu);
menuOverlay.addEventListener('click',(e)=>{ if(e.target===menuOverlay) closeMenu(); });

/* Sliders / select */
const accelPitch=document.getElementById('accelPitch'), accelPitchTag=document.getElementById('accelPitchTag');
const accelYaw=document.getElementById('accelYaw'), accelYawTag=document.getElementById('accelYawTag');
const accelRoll=document.getElementById('accelRoll'), accelRollTag=document.getElementById('accelRollTag');
const curveRange=document.getElementById('curveRange'), curveTag=document.getElementById('curveTag');
const dampRange=document.getElementById('dampRange'),   dampTag=document.getElementById('dampTag');
const dampDARRange=document.getElementById('dampDARRange'), dampDARTag=document.getElementById('dampDARTag');
const brakeRange=document.getElementById('brakeRange'), brakeTag=document.getElementById('brakeTag');
const wmaxRange=document.getElementById('wmaxRange'),   wmaxTag=document.getElementById('wmaxTag');
const wmaxPitchRange=document.getElementById('wmaxPitch'), wmaxPitchTag=document.getElementById('wmaxPitchTag');
const wmaxYawRange=document.getElementById('wmaxYaw'), wmaxYawTag=document.getElementById('wmaxYawTag');
const wmaxRollRange=document.getElementById('wmaxRoll'), wmaxRollTag=document.getElementById('wmaxRollTag');
const circleTiltRange=document.getElementById('circleTilt'), circleTiltTag=document.getElementById('circleTiltTag');
const circleTiltModifierRange=document.getElementById('circleTiltModifier'), circleTiltModifierTag=document.getElementById('circleTiltModifierTag');
const circleScaleRange=document.getElementById('circleScale'), circleScaleTag=document.getElementById('circleScaleTag');
const sizeSlider=document.getElementById('stickSizeSlider'), stickVal=document.getElementById('stickVal');
const zoomSlider=document.getElementById('zoomSlider'), zoomVal=document.getElementById('zoomVal');
const arrowSlider=document.getElementById('arrowSlider'), arrowVal=document.getElementById('arrowVal');
const brightnessSlider=document.getElementById('brightnessSlider'), brightnessVal=document.getElementById('brightnessVal');
const presetSel=document.getElementById('presetSel');

// Load settings from Settings module
const savedSettings = Settings.loadSettings();

// Initialize gamepad bindings early (will be properly set later)
let gpEnabled = savedSettings.gpEnabled ?? true;
let gpBindings = savedSettings.gpBindings ?? null; // Will be set to defaultGpBindings later if still null

// Restore theme mode (default to true = dark mode)
isDarkMode = savedSettings.isDarkMode ?? true;

let maxAccelPitch=savedSettings.maxAccelPitch ?? parseFloat(accelPitch.value),
    maxAccelYaw=savedSettings.maxAccelYaw ?? parseFloat(accelYaw.value),
    maxAccelRoll=savedSettings.maxAccelRoll ?? parseFloat(accelRoll.value),
    inputPow=savedSettings.inputPow ?? parseFloat(curveRange.value),
    damp=savedSettings.damp ?? parseFloat(dampRange.value),
    dampDAR=savedSettings.dampDAR ?? parseFloat(dampDARRange.value),
    brakeOnRelease=savedSettings.brakeOnRelease ?? parseFloat(brakeRange.value),
    wMax=savedSettings.wMax ?? parseFloat(wmaxRange.value),
    wMaxPitch=savedSettings.wMaxPitch ?? parseFloat(wmaxPitchRange.value),
    wMaxYaw=savedSettings.wMaxYaw ?? parseFloat(wmaxYawRange.value),
    wMaxRoll=savedSettings.wMaxRoll ?? parseFloat(wmaxRollRange.value),
    circleTiltAngle=savedSettings.circleTiltAngle ?? parseFloat(circleTiltRange.value),
    circleTiltModifier=savedSettings.circleTiltModifier ?? parseFloat(circleTiltModifierRange.value),
    circleScale=savedSettings.circleScale ?? parseFloat(circleScaleRange.value),
    zoom=savedSettings.zoom ?? parseFloat(zoomSlider.value),
    arrowScale=savedSettings.arrowScale ?? parseFloat(arrowSlider.value);

// Brightness settings (separate for dark and light modes)
let brightnessDark = savedSettings.brightnessDark ?? 1.0;
let brightnessLight = savedSettings.brightnessLight ?? 1.0;

// Audio settings
let gameSoundsEnabled = savedSettings.gameSoundsEnabled ?? true;
let gameMusicEnabled = savedSettings.gameMusicEnabled ?? true;

// Sync audio settings with Audio module
Audio.setGameSoundsEnabled(gameSoundsEnabled);
Audio.setGameMusicEnabled(gameMusicEnabled);

// Wrapper function to save settings to Settings module
function saveSettings() {
  // Collect current settings
  const currentSettings = {
    maxAccelPitch, maxAccelYaw, maxAccelRoll,
    inputPow, damp, dampDAR, brakeOnRelease,
    wMax, wMaxPitch, wMaxYaw, wMaxRoll,
    circleTiltAngle, circleTiltModifier, circleScale,
    zoom, arrowScale,
    isDarkMode, airRollIsToggle,
    brightnessDark, brightnessLight,
    gpEnabled, gpBindings,
    showArrow, showCircle,
    ringModeHighScore,
    lastActiveAirRoll,
    ringDifficulty: currentDifficulty,
    gameSoundsEnabled,
    gameMusicEnabled
  };

  // Add optional settings if elements exist
  const gpPresetEl = document.getElementById('gpPreset');
  if (gpPresetEl) {
    currentSettings.gpPreset = gpPresetEl.value;
  }

  const presetSelEl = document.getElementById('presetSel');
  if (presetSelEl) {
    currentSettings.selectedCarBody = presetSelEl.value;
  }

  // Save to Settings module
  Settings.saveSettings(currentSettings);
}

// Apply loaded values to sliders
accelPitch.value = maxAccelPitch;
accelYaw.value = maxAccelYaw;
accelRoll.value = maxAccelRoll;
curveRange.value = inputPow;
dampRange.value = damp;
dampDARRange.value = dampDAR;
brakeRange.value = brakeOnRelease;
wmaxRange.value = wMax;
wmaxPitchRange.value = wMaxPitch;
wmaxYawRange.value = wMaxYaw;
wmaxRollRange.value = wMaxRoll;
circleTiltRange.value = circleTiltAngle;
circleTiltModifierRange.value = circleTiltModifier;
circleScaleRange.value = circleScale;
zoomSlider.value = zoom;
arrowSlider.value = arrowScale;

/* Air Roll System - managed by Input module */

// Helper function to update menu button styling based on Input module state
function updateMenuButtonStyling(){
  const lastActive = Input.getLastActiveAirRoll();
  document.getElementById('rollL').classList.toggle('active', lastActive === -1);
  document.getElementById('rollR').classList.toggle('active', lastActive === 1);
  document.getElementById('rollFree').classList.toggle('active', lastActive === 2);
}

// Menu button click handlers - delegate to Input module
document.getElementById('rollL').addEventListener('click', () => {
  Input.selectAirRoll(-1);
  updateMenuButtonStyling();
});
document.getElementById('rollR').addEventListener('click', () => {
  Input.selectAirRoll(1);
  updateMenuButtonStyling();
});
document.getElementById('rollFree').addEventListener('click', () => {
  Input.selectAirRoll(2);
  updateMenuButtonStyling();
});

// Reset Physics to Defaults button
document.getElementById('resetPhysicsDefaults').addEventListener('click', () => {
  Settings.clearAllSettings();
  location.reload();
});

// Toggle/Hold mode button
document.getElementById('toggleMode').addEventListener('click', () => {
  const newMode = !Input.getAirRollIsToggle();
  Input.setAirRollIsToggle(newMode);
  const btn = document.getElementById('toggleMode');
  btn.classList.toggle('active', newMode);
  btn.textContent = newMode ? 'Toggle' : 'Hold';
});

/* Ring Mode */
/*
 * ===== COORDINATE SYSTEM GUIDE - READ THIS BEFORE ROTATING ANYTHING =====
 *
 * THREE.JS WORLD COORDINATES (Standard Right-Handed System):
 * - X axis: LEFT (-) to RIGHT (+) across the screen
 * - Y axis: DOWN (-) to UP (+) on the screen
 * - Z axis: AWAY from camera (-) to TOWARD camera (+) - THIS IS DEPTH
 *
 * CAMERA SETUP:
 * - Camera positioned at positive Z looking toward origin (0,0,0)
 * - From camera's view: +X = right, +Y = up, +Z = toward you, -Z = into screen
 *
 * ===== CRITICAL: UNDERSTANDING ROTATIONS IN THREE.JS =====
 *
 * When you call car.rotation.set(x, y, z), you are setting EULER ANGLES.
 * Three.js applies rotations in XYZ ORDER (this matters!):
 *   1. First: Rotate around X axis
 *   2. Second: Rotate around Y axis (which has now moved due to X rotation)
 *   3. Third: Rotate around Z axis (which has now moved due to X and Y rotations)
 *
 * VISUAL GUIDE - ROTATING FROM USER'S PERSPECTIVE:
 *   - X rotation: Pitch (nose up/down like nodding "yes")
 *   - Y rotation: Yaw (turning left/right like shaking head "no") - THIS IS DEPTH AXIS ROTATION
 *   - Z rotation: Roll (barrel roll, tilting left/right) - THIS IS UP/DOWN AXIS ROTATION
 *
 * IMPORTANT: The Y axis is the DEPTH axis (toward/away from camera)
 *            The Z axis is the UP/DOWN axis (vertical on screen)
 *            Rotating around Y = spinning on the depth axis
 *            Rotating around Z = spinning on the vertical axis
 *
 * ===== CAR MODEL DEFAULT ORIENTATION (at quaternion.identity, NO rotations) =====
 *
 * Default car orientation when spawned with NO rotation applied:
 * - Wheels/Bottom:  Facing UP (+Y, toward top of screen)
 * - Roof:           Facing DOWN (-Y, toward bottom of screen)
 * - Nose/Front:     Facing LEFT (-X, left side of screen)
 * - Rear/Back:      Facing RIGHT (+X, right side of screen)
 * - Right side:     Facing CAMERA (+Z, toward you)
 * - Left side:      Facing AWAY (-Z, away from you into screen)
 *
 * ===== DESIRED ORIENTATION FOR DAR TRAINING =====
 *
 * What we want to achieve:
 * - Roof:           Facing CAMERA (+Z, toward user)
 * - Wheels/Bottom:  Facing AWAY (-Z, into screen depth)
 * - Nose/Front:     Facing UP (+Y, top of screen)
 * - Rear/Back:      Facing DOWN (-Y, bottom of screen)
 * - Right side:     Facing RIGHT (+X)
 * - Left side:      Facing LEFT (-X)
 *
 * ===== FINAL WORKING ROTATION =====
 *
 * car.rotation.set(Math.PI * 1.5, 0, Math.PI)
 * Breaking it down:
 *   - X: +270Â° (Math.PI * 1.5) - Pitches nose UP, this gets us nose pointing up
 *   - Y: 0Â° - No depth rotation needed
 *   - Z: +180Â° (Math.PI) - Barrel roll to flip roof toward camera
 *
 * WHY THIS WORKS:
 * 1. Start: Car at identity (roof down, nose left, right-side toward camera)
 * 2. X rotation +270Â°: Pitches the car so nose points up (like tilting forward 3/4 turn)
 * 3. Z rotation +180Â°: Barrel rolls the car to flip roof toward camera
 *
 * ===== CAR MODEL LOCAL SPACE (GLB file internal axes) =====
 *
 * The GLB model has its own coordinate system baked in:
 * - Model +Z local: Points toward nose/front of car
 * - Model +X local: Points toward right side of car
 * - Model +Y local: Points toward roof of car
 *
 * Different car models may be exported with different default orientations:
 * - Dominus GLB: rotation.y = 0 (nose already points in correct direction)
 * - Octane GLB: rotation.y = -Math.PI/2 (-90Â°) needed to align nose correctly
 *
 * ===== ROTATION TESTING HISTORY (for reference) =====
 *
 * Attempts that DIDN'T work:
 * - (0, 0, Math.PI): Nose facing camera instead of up
 * - (Math.PI, 0, 0): Roof down, nose away from screen
 * - (Math.PI, -Math.PI/2, 0): Roof down, nose left
 * - (Math.PI/2, 0, Math.PI/2): Nose DOWN, rear UP, roof LEFT
 * - (0, -Math.PI/2, -Math.PI/2): Roof correct, but nose LEFT instead of UP
 * - (Math.PI/2, 0, -Math.PI/2): Various incorrect orientations
 * - (Math.PI, 0, -Math.PI/2): Still incorrect
 *
 * What WORKED: (Math.PI * 1.5, 0, Math.PI) - Nose UP confirmed, roof toward camera
 *
 * ===== RING MODE PHYSICS =====
 *
 * - Car is locked at world origin (0, 0, 0) - never moves in 3D space
 * - Visual movement simulated by translating car on 2D plane using ringModePosition
 * - Movement occurs in X-Y plane (left/right and up/down on screen)
 * - Rings spawn at negative Z (far from camera) and move toward positive Z (toward camera)
 * - This creates the illusion that the car is flying through depth
 *
 * ===== REMEMBER THIS TO AVOID CONFUSION =====
 *
 * If you need to rotate the car in the future:
 * 1. Y axis rotation = spinning around the DEPTH axis (toward/away from camera)
 * 2. Z axis rotation = spinning around the UP/DOWN axis (vertical on screen)
 * 3. X axis rotation = pitching nose up/down
 * 4. Rotations are applied in X-Y-Z order, so later rotations operate on moved axes
 * 5. Test one axis at a time in 90Â° increments to understand the effect
 * 6. The current working rotation is: car.rotation.set(Math.PI * 1.5, 0, Math.PI)
 *
 */
let ringModeActive = false;
let ringModeScore = 0;
let ringModeHighScore = savedSettings.ringModeHighScore ?? 0; // Track high score across sessions
let ringModeLives = 5;
let ringModeRingCount = 0;
let ringCameraSpeed = 0.1;

// Ring Mode Physics
let ringModeVelocity = new THREE.Vector2(0, 0); // XY velocity only
let ringModePosition = new THREE.Vector2(0, 0); // Car position in 2D plane
let ringModeBoostActive = false;
let ringModeStarted = false; // Track if player has started (boosted at least once)
let ringModePaused = false; // Track pause state

// Boost flame effects
let boostFlames = [];

// Camera smooth path tracking
let cameraTargetX = 0; // Smooth interpolated camera target position
let cameraTargetY = 0;

// Reset Ring Mode (for retry button)
function resetRingMode() {
  ringModeScore = 0;
  ringModeLives = CONST.DIFFICULTY_SETTINGS[currentDifficulty].initialLives;
  ringModeRingCount = 0;
  ringModeVelocity.set(0, 0);
  ringModePosition.set(0, 0);
  ringSpawnTimer = 0;
  ringSpawnIndex = 0;
  currentColorIndex = 0;
  ringModeStarted = false;
  ringModePaused = false;
  patternRingCount = 0;
  cameraTargetX = 0;
  cameraTargetY = 0;
  clearAllRings();
  clearBoostFlames();

  if (Car.car) {
    Car.car.quaternion.identity();
    Car.car.rotation.set(Math.PI * 1.5, 0, Math.PI);
    Car.car.position.set(0, 0, 0);
  }
  w.set(0,0,0);
  orbitOn = false;

  spawnRing();

  // Restart music
  Audio.startBackgroundMusic();
}

// Ring geometry and spawning
let rings = []; // Active rings in the scene
let currentColorIndex = 0;

// Preloaded ring resources (cached geometry and materials)
let ringGeometryCache = null;
let ringMaterialCache = new Map(); // Cache materials by color
let ringResourcesPreloaded = false;

// Ring spawning state
let ringSpawnTimer = 0;
let ringSpawnIndex = 0; // Track spawn order for camera focusing

let currentDifficulty = savedSettings.ringDifficulty ?? 'normal';

// Preload ring resources to prevent lag on first spawn
function preloadRingResources() {
  if (ringResourcesPreloaded) return;

  console.log('[Ring Mode] Preloading resources...');

  // Cache shared geometry (all rings use same torus geometry)
  ringGeometryCache = new THREE.TorusGeometry(CONST.INITIAL_RING_SIZE / 2, CONST.RING_TUBE_RADIUS, 16, 32);

  // Cache materials for each color
  CONST.RING_COLORS.forEach(color => {
    const material = new THREE.MeshStandardMaterial({
      color: color,
      emissive: color,
      emissiveIntensity: 0.8,
      metalness: 0.3,
      roughness: 0.2
    });
    ringMaterialCache.set(color, material);
  });

  // Create a dummy ring offscreen and render it to compile shaders
  const dummyRing = new THREE.Mesh(
    ringGeometryCache,
    ringMaterialCache.get(CONST.RING_COLORS[0])
  );
  dummyRing.position.set(0, 0, -5000); // Far offscreen

  // Add point light to compile light shaders too
  const dummyLight = new THREE.PointLight(CONST.RING_COLORS[0], 2, 150);
  dummyRing.add(dummyLight);

  scene.add(dummyRing);

  // Render one frame to compile shaders
  renderer.render(scene, camera);

  // Clean up dummy ring
  scene.remove(dummyRing);
  dummyLight.dispose();

  // Preload boost flame geometry/material (compile shaders)
  if (!Car.car) {
    console.warn('[Ring Mode] Car not loaded yet, skipping boost flame preload');
  } else {
    createBoostFlames();
    // Briefly activate to compile shaders
    updateBoostFlames(true, null);
    renderer.render(scene, camera);
    updateBoostFlames(false, null);
  }

  ringResourcesPreloaded = true;
  console.log('[Ring Mode] Resources preloaded successfully!');
}

// Create a ring with neon 80s aesthetic (now uses cached resources)
function createRing(x, y, z, size, speed, spawnIndex) {
  const color = CONST.RING_COLORS[currentColorIndex];
  currentColorIndex = (currentColorIndex + 1) % CONST.RING_COLORS.length;

  // ALWAYS use cached geometry for performance (prevents lag on spawn)
  // Scale the mesh instead of creating new geometry for different sizes
  const geometry = ringGeometryCache;
  const cachedMaterial = ringMaterialCache.get(color);
  const material = cachedMaterial || new THREE.MeshStandardMaterial({
    color: color,
    emissive: color,
    emissiveIntensity: 0.8,
    metalness: 0.3,
    roughness: 0.2
  });

  const ring = new THREE.Mesh(geometry, material);
  ring.position.set(x, y, z);

  // Scale ring to match requested size (cached geometry is for CONST.INITIAL_RING_SIZE)
  const scale = size / CONST.INITIAL_RING_SIZE;
  ring.scale.set(scale, scale, scale);

  // Add point light for glow effect
  const light = new THREE.PointLight(color, 2, 150);
  light.position.set(0, 0, 0);
  ring.add(light);

  scene.add(ring);

  return {
    mesh: ring,
    size: size,
    speed: speed,
    passed: false,
    missed: false,
    spawnIndex: spawnIndex // Track when this ring was spawned
  };
}

// Pattern generation variables
let currentPattern = 'random';
let patternProgress = 0; // Progress through current pattern (0-1)
let patternLength = 15; // Number of rings in this pattern
let patternRingCount = 0; // Rings spawned in current pattern
const PATTERN_TYPES = ['sine_horizontal', 'sine_vertical', 'spiral', 'helix', 'figure8', 'vertical_line', 'horizontal_line', 'wave_combo', 'random'];

// Pattern parameters (randomized when pattern changes)
let patternAmplitude = 400; // Wave/spiral amplitude
let patternFrequency = 0.5; // Oscillation frequency
let patternPhase = 0; // Starting phase offset

function selectNewPattern() {
  const settings = CONST.DIFFICULTY_SETTINGS[currentDifficulty];

  // Progressive difficulty based on rings completed (affected by difficulty setting)
  const difficultyLevel = Math.floor(ringModeRingCount / 5 * settings.progressionRate); // Increase every 5 rings

  // Use difficulty-specific allowed patterns or progressive unlock
  let availablePatterns = settings.allowedPatterns || PATTERN_TYPES;

  // If no specific pattern restriction, use progressive unlock (Normal/Hard modes)
  if (!settings.allowedPatterns) {
    if (difficultyLevel < 2) {
      // First 10 rings: easier straight/simple patterns
      availablePatterns = ['horizontal_line', 'vertical_line', 'sine_horizontal', 'sine_vertical'];
    } else if (difficultyLevel < 4) {
      // Rings 10-20: introduce more complex patterns
      availablePatterns = ['sine_horizontal', 'sine_vertical', 'wave_combo', 'helix', 'spiral'];
    }
    // After 20 rings: all patterns available

    // Exclude 'random' pattern if difficulty setting requires it (Normal mode)
    if (settings.excludeRandomPattern) {
      availablePatterns = availablePatterns.filter(p => p !== 'random');
    }
  }

  currentPattern = availablePatterns[Math.floor(Math.random() * availablePatterns.length)];
  patternRingCount = 0;
  patternLength = 8 + Math.floor(Math.random() * 12); // 8-20 rings per pattern

  // Progressive amplitude and frequency increase (affected by difficulty)
  const baseAmplitude = (200 + (difficultyLevel * 100)) * settings.patternAmplitudeMultiplier;
  const amplitudeVariance = (200 + (difficultyLevel * 50)) * settings.patternAmplitudeMultiplier;
  patternAmplitude = Math.min(baseAmplitude + Math.random() * amplitudeVariance, CONST.RING_GRID_BOUNDS * 0.9);

  const baseFrequency = 0.3 + (difficultyLevel * 0.1); // Faster oscillations as difficulty increases
  patternFrequency = Math.min(baseFrequency + Math.random() * 0.5, 2.0);

  patternPhase = Math.random() * Math.PI * 2;
  console.log(`New pattern: ${currentPattern}, length: ${patternLength}, difficulty: ${difficultyLevel}, amplitude: ${Math.round(patternAmplitude)}`);
}

function getPatternPosition(progress) {
  const t = progress; // 0 to 1 through the pattern
  let x = 0, y = 0;

  switch(currentPattern) {
    case 'sine_horizontal':
      // Horizontal sine wave
      x = Math.sin(t * Math.PI * 2 * patternFrequency + patternPhase) * patternAmplitude;
      y = (Math.random() - 0.5) * 200; // Small random Y variance
      break;

    case 'sine_vertical':
      // Vertical sine wave
      x = (Math.random() - 0.5) * 200;
      y = Math.sin(t * Math.PI * 2 * patternFrequency + patternPhase) * patternAmplitude;
      break;

    case 'spiral':
      // Expanding or contracting spiral
      const spiralRadius = patternAmplitude * (0.3 + t * 0.7);
      const spiralAngle = t * Math.PI * 4 + patternPhase;
      x = Math.cos(spiralAngle) * spiralRadius;
      y = Math.sin(spiralAngle) * spiralRadius;
      break;

    case 'helix':
      // Helix (circular with vertical oscillation)
      const helixAngle = t * Math.PI * 3 + patternPhase;
      x = Math.cos(helixAngle) * patternAmplitude;
      y = Math.sin(t * Math.PI * 2 * patternFrequency) * (patternAmplitude * 0.5);
      break;

    case 'figure8':
      // Figure-8 pattern
      const fig8t = t * Math.PI * 2 + patternPhase;
      x = Math.sin(fig8t) * patternAmplitude;
      y = Math.sin(fig8t * 2) * patternAmplitude * 0.7;
      break;

    case 'vertical_line':
      // Straight vertical line
      x = (Math.random() - 0.5) * 100;
      y = -patternAmplitude + (t * patternAmplitude * 2);
      break;

    case 'horizontal_line':
      // Straight horizontal line
      x = -patternAmplitude + (t * patternAmplitude * 2);
      y = (Math.random() - 0.5) * 100;
      break;

    case 'wave_combo':
      // Combined horizontal and vertical waves
      x = Math.sin(t * Math.PI * 2 * patternFrequency + patternPhase) * patternAmplitude;
      y = Math.cos(t * Math.PI * 2 * patternFrequency * 1.3) * (patternAmplitude * 0.6);
      break;

    case 'random':
    default:
      // Pure random
      x = (Math.random() - 0.5) * CONST.RING_GRID_BOUNDS * 0.8;
      y = (Math.random() - 0.5) * CONST.RING_GRID_BOUNDS * 0.8;
      break;
  }

  // Distance cap: Limit maximum distance from current player position
  // Max distance = grid radius (center to edge = 1500 units)
  const MAX_RING_DISTANCE = CONST.RING_GRID_BOUNDS; // 1500 units (half the total grid width)
  const dx = x - ringModePosition.x;
  const dy = y - ringModePosition.y;
  const distance = Math.sqrt(dx * dx + dy * dy);

  if (distance > MAX_RING_DISTANCE) {
    // Clamp to max distance while preserving direction
    const scale = MAX_RING_DISTANCE / distance;
    x = ringModePosition.x + dx * scale;
    y = ringModePosition.y + dy * scale;
  }

  return { x, y };
}

// Spawn a new ring
function spawnRing() {
  // Check if there's already a ring too close to spawn position
  // Prevent clustering by enforcing minimum Z-distance between rings
  // At base speed (200 u/s) and 3s interval, rings should be ~600 units apart
  const MIN_RING_Z_SPACING = 650; // Minimum units between rings on Z-axis
  const hasCloseRing = rings.some(r => Math.abs(r.mesh.position.z - CONST.RING_SPAWN_DISTANCE) < MIN_RING_Z_SPACING);

  if (hasCloseRing) {
    // Skip spawning this ring, try again next interval
    return;
  }

  // Check if we need a new pattern
  if (patternRingCount === 0 || patternRingCount >= patternLength) {
    selectNewPattern();
  }

  // Get position from current pattern
  patternProgress = patternRingCount / patternLength;
  const pos = getPatternPosition(patternProgress);
  const spawnX = pos.x;
  const spawnY = pos.y;
  const spawnZ = CONST.RING_SPAWN_DISTANCE;

  patternRingCount++;

  const settings = CONST.DIFFICULTY_SETTINGS[currentDifficulty];

  // Calculate progression based on ring count (every 10 rings, affected by difficulty)
  const progressionLevel = Math.floor(ringModeRingCount / 10 * settings.progressionRate);

  // Size: -5% every 10 rings (max 50% reduction), then apply difficulty multiplier
  const sizeReduction = progressionLevel * 0.05;
  const ringSize = CONST.INITIAL_RING_SIZE * (1 - Math.min(sizeReduction, 0.5)) * settings.sizeMultiplier;

  // Speed: +5% every 10 rings (max 50% increase), then apply difficulty multiplier
  const speedIncrease = progressionLevel * 0.05;
  let ringSpeed = CONST.RING_BASE_SPEED * (1 + Math.min(speedIncrease, 0.5)) * settings.speedMultiplier;

  // Distance-based speed modifier: slow down rings that spawn far away
  const distanceToRing = Math.sqrt(
    (spawnX - ringModePosition.x) ** 2 +
    (spawnY - ringModePosition.y) ** 2
  );
  const MAX_RING_DISTANCE = CONST.RING_GRID_BOUNDS; // 1500 units
  const distanceRatio = distanceToRing / MAX_RING_DISTANCE; // 0.0 to 1.0

  // If ring is far away (>50% of max distance), slow it down
  // At max distance (1500 units), speed is reduced by 50%
  if (distanceRatio > 0.5) {
    const slowdownFactor = 1 - ((distanceRatio - 0.5) * 1.0); // 1.0 at 50%, 0.5 at 100%
    ringSpeed *= slowdownFactor;
  }

  const ring = createRing(spawnX, spawnY, spawnZ, ringSize, ringSpeed, ringSpawnIndex++);
  rings.push(ring);
}

// Remove all rings from scene
function clearAllRings() {
  rings.forEach(r => {
    scene.remove(r.mesh);
    // Don't dispose geometry/materials - they're cached and reused!
    // Only dispose if not using cache (fallback case)
    if (r.mesh.geometry !== ringGeometryCache) {
      r.mesh.geometry.dispose();
    }
    if (!ringMaterialCache.has(r.mesh.material.color.getHex())) {
      r.mesh.material.dispose();
    }
  });
  rings = [];
}

// Create boost flame effects
function createBoostFlames() {
  if (!Car.car) return;

  // Create two flame cones for the tailpipes
  const flameGeometry = new THREE.ConeGeometry(16, 60, 8); // 2x bigger (radius: 8->16, height: 30->60)
  const flameMaterial = new THREE.MeshBasicMaterial({
    color: 0xff6600,
    transparent: true,
    opacity: 0.9
  });

  for (let i = 0; i < 2; i++) {
    const flame = new THREE.Mesh(flameGeometry, flameMaterial.clone());
    flame.visible = false;

    // Position in car's local space (at rear of car)
    const offset = (i === 0) ? -12 : 12; // Left and right offset
    flame.position.set(offset, 0, -100); // Local position: left/right, center height, rear

    // Rotate flame cone to point backward/downward (rear of car)
    // X rotation: tip points toward rear
    flame.rotation.set(Math.PI * 0.5, 0, 0); // 90Â° X rotation

    // Add point light for glow
    const light = new THREE.PointLight(0xff6600, 3, 80);
    flame.add(light);

    Car.car.add(flame); // Add as child of car so it moves with the car
    boostFlames.push(flame);
  }
}

// Update boost flame effects
function updateBoostFlames(active, forwardDir) {
  if (boostFlames.length === 0) {
    createBoostFlames();
  }

  if (!Car.car) return;

  boostFlames.forEach((flame, i) => {
    flame.visible = active;

    if (active) {
      // Flames are children of car, so they move automatically with it
      // Just animate the scale and opacity

      // Animate flame size
      const pulse = 0.7 + Math.random() * 0.6;
      flame.scale.set(pulse, pulse * 1.5, pulse);

      // Vary opacity
      flame.material.opacity = 0.7 + Math.random() * 0.3;
    }
  });
}

// Clear boost flames
function clearBoostFlames() {
  boostFlames.forEach(flame => {
    if (flame.parent) flame.parent.remove(flame);
    flame.geometry.dispose();
    flame.material.dispose();
  });
  boostFlames = [];
}

document.getElementById('ringMode').addEventListener('click', () => {
  ringModeActive = !ringModeActive;
  const btn = document.getElementById('ringMode');
  btn.classList.toggle('active', ringModeActive);

  if(ringModeActive){
    // Initialize Ring Mode
    ringModeScore = 0;
    ringModeLives = CONST.DIFFICULTY_SETTINGS[currentDifficulty].initialLives;
    ringModeRingCount = 0;
    ringModeVelocity.set(0, 0);
    ringModePosition.set(0, 0);
    ringSpawnTimer = 0;
    ringSpawnIndex = 0; // Reset spawn order tracking
    currentColorIndex = 0;
    ringModeStarted = false; // Reset started state
    ringModePaused = false;  // Reset pause state
    patternRingCount = 0;    // Reset pattern progress
    cameraTargetX = 0; // Reset smooth camera path
    cameraTargetY = 0;
    clearAllRings();

    // Resources already preloaded at startup, just spawn first ring
    spawnRing();

    if (Car.car) {
      Car.car.quaternion.identity();
      Car.car.rotation.set(Math.PI * 1.5, 0, Math.PI); // X: +270Â°, Y: 0Â°, Z: +180Â°
      Car.car.position.set(0, 0, 0); // Lock car to origin in Ring Mode
    }
    w.set(0,0,0);
    orbitOn = false;

    // Start background music when entering Ring Mode
    Audio.startBackgroundMusic();
  } else {
    // Exit Ring Mode
    ringModeVelocity.set(0, 0);
    ringModePosition.set(0, 0);
    clearAllRings();
    clearBoostFlames();
    if (Car.car) Car.car.position.set(0, 0, 0);

    // Stop background music when exiting Ring Mode
    Audio.stopBackgroundMusic();
    Audio.stopBoostRumble(); // Also stop boost rumble
  }
});

const ringCameraSpeedSlider = document.getElementById('ringCameraSpeed');
const ringCameraSpeedVal = document.getElementById('ringCameraSpeedVal');
ringCameraSpeedSlider.addEventListener('input', () => {
  ringCameraSpeed = parseFloat(ringCameraSpeedSlider.value);
  ringCameraSpeedVal.textContent = ringCameraSpeed.toFixed(2);
});

// Ring Mode difficulty selector
const ringDifficultySelector = document.getElementById('ringDifficulty');
ringDifficultySelector.addEventListener('change', () => {
  currentDifficulty = ringDifficultySelector.value;
  saveSettings();
  console.log('Ring Mode difficulty changed to:', currentDifficulty);

  // If Ring Mode is active, restart it with new difficulty
  if (ringModeActive) {
    ringModeScore = 0;
    ringModeLives = CONST.DIFFICULTY_SETTINGS[currentDifficulty].initialLives;
    ringModeRingCount = 0;
    ringModeVelocity.set(0, 0);
    ringModePosition.set(0, 0);
    ringSpawnTimer = 0;
    ringSpawnIndex = 0;
    patternRingCount = 0;
    clearAllRings();
    console.log('Ring Mode restarted with new difficulty');
  }
});

// Audio toggles
const toggleSoundsBtn = document.getElementById('toggleSounds');
const soundsStatusTag = document.getElementById('soundsStatus');
const toggleMusicBtn = document.getElementById('toggleMusic');
const musicStatusTag = document.getElementById('musicStatus');

// Set initial button states
toggleSoundsBtn.classList.toggle('active', gameSoundsEnabled);
soundsStatusTag.textContent = gameSoundsEnabled ? 'Enabled' : 'Disabled';
toggleMusicBtn.classList.toggle('active', gameMusicEnabled);
musicStatusTag.textContent = gameMusicEnabled ? 'Enabled' : 'Disabled';

toggleSoundsBtn.addEventListener('click', () => {
  gameSoundsEnabled = !gameSoundsEnabled;
  toggleSoundsBtn.classList.toggle('active', gameSoundsEnabled);
  soundsStatusTag.textContent = gameSoundsEnabled ? 'Enabled' : 'Disabled';

  // Update Audio module settings
  Audio.setGameSoundsEnabled(gameSoundsEnabled);

  saveSettings();
});

toggleMusicBtn.addEventListener('click', () => {
  gameMusicEnabled = !gameMusicEnabled;
  toggleMusicBtn.classList.toggle('active', gameMusicEnabled);
  musicStatusTag.textContent = gameMusicEnabled ? 'Enabled' : 'Disabled';

  // Update Audio module settings
  Audio.setGameMusicEnabled(gameMusicEnabled);

  // Start music if enabled and Ring Mode is active
  if (gameMusicEnabled && ringModeActive && ringModeStarted) {
    Audio.startBackgroundMusic();
  }

  saveSettings();
});

document.getElementById('restart').addEventListener('click',()=>{
  if (Car.car) {
    Car.car.quaternion.identity();
    Car.car.rotation.set(Math.PI * 1.5, 0, Math.PI); // X: +270Â°, Y: 0Â°, Z: +180Â°
  }
  w.set(0,0,0);
  orbitOn = false;
  orbitDir = 1;
  document.getElementById('orbitCW').classList.remove('active');
  document.getElementById('orbitCCW').classList.remove('active');
  orbitPhase = 0;
  camera.position.set(0, 220, 650);
  camera.lookAt(0,0,0);
  if (Car.faceArrow) Car.faceArrow.visible = false;
  if (Car.faceTip)   Car.faceTip.visible   = false;

  // Reset Ring Mode if active
  if(ringModeActive){
    ringModeScore = 0;
    ringModeLives = CONST.DIFFICULTY_SETTINGS[currentDifficulty].initialLives;
    ringModeRingCount = 0;
  }
});
let orbitOn=false, orbitDir=1;
document.getElementById('orbitCW').addEventListener('click',()=>{
  const btn = document.getElementById('orbitCW');
  if (orbitOn && orbitDir === 1) {
    // Turn off if already orbiting CW
    orbitOn = false;
    btn.classList.remove('active');
  } else {
    // Turn on CW orbit
    orbitOn = true;
    orbitDir = 1;
    btn.classList.add('active');
    document.getElementById('orbitCCW').classList.remove('active');
  }
});
document.getElementById('orbitCCW').addEventListener('click',()=>{
  const btn = document.getElementById('orbitCCW');
  if (orbitOn && orbitDir === -1) {
    // Turn off if already orbiting CCW
    orbitOn = false;
    btn.classList.remove('active');
  } else {
    // Turn on CCW orbit
    orbitOn = true;
    orbitDir = -1;
    btn.classList.add('active');
    document.getElementById('orbitCW').classList.remove('active');
  }
});

/* Theme toggle (main screen button) */
document.getElementById('themeBtn').addEventListener('click',()=>{
  isDarkMode = !isDarkMode;
  applyTheme(isDarkMode);
  const btn = document.getElementById('themeBtn');
  btn.textContent = isDarkMode ? 'ðŸŒ™' : 'â˜€ï¸';
  syncTags(); // Update brightness slider to show correct value for new theme
  saveSettings();
});

// Fullscreen toggle
document.getElementById('fullscreenBtn').addEventListener('click', () => {
  if (!document.fullscreenElement) {
    // Enter fullscreen
    document.documentElement.requestFullscreen().catch(err => {
      console.log(`Error attempting to enable fullscreen: ${err.message}`);
    });
  } else {
    // Exit fullscreen
    if (document.exitFullscreen) {
      document.exitFullscreen();
    }
  }
});

// Update fullscreen button icon when fullscreen state changes
document.addEventListener('fullscreenchange', () => {
  const btn = document.getElementById('fullscreenBtn');
  if (document.fullscreenElement) {
    btn.textContent = 'â›¶'; // Fullscreen exit icon
    btn.title = 'Exit Fullscreen';
  } else {
    btn.textContent = 'â›¶'; // Fullscreen enter icon
    btn.title = 'Enter Fullscreen';
  }
});

// Stop music when page loses focus (tab switching, app backgrounding)
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Page is hidden - stop all audio
    Audio.stopBackgroundMusic();
    Audio.stopBoostRumble();
  } else {
    // Page is visible again - restart music if Ring Mode is active
    if (ringModeActive && ringModeStarted && gameMusicEnabled) {
      Audio.startBackgroundMusic();
    }
  }
});

/* Arrow and Circle toggles */
let showArrow = savedSettings.showArrow ?? true;
let showCircle = savedSettings.showCircle ?? true;

document.getElementById('arrowToggle').addEventListener('click',()=>{
  showArrow = !showArrow;
  const btn = document.getElementById('arrowToggle');
  btn.classList.toggle('active', showArrow);
  btn.textContent = showArrow ? 'Show Arrow' : 'Hide Arrow';
  saveSettings();
});

document.getElementById('circleToggle').addEventListener('click',()=>{
  showCircle = !showCircle;
  const btn = document.getElementById('circleToggle');
  btn.classList.toggle('active', showCircle);
  btn.textContent = showCircle ? 'Show Circle' : 'Hide Circle';
  saveSettings();
});

function syncTags(){
  accelPitchTag.textContent=maxAccelPitch.toFixed(0);
accelYawTag.textContent=maxAccelYaw.toFixed(0);
accelRollTag.textContent=maxAccelRoll.toFixed(0);
  curveTag.textContent=inputPow.toFixed(2);
  dampTag.textContent=damp.toFixed(2);
  brakeTag.textContent=brakeOnRelease.toFixed(1);
  wmaxTag.textContent=wMax.toFixed(1);
  wmaxPitchTag.textContent=wMaxPitch.toFixed(1);
  wmaxYawTag.textContent=wMaxYaw.toFixed(1);
  wmaxRollTag.textContent=wMaxRoll.toFixed(1);
  circleTiltTag.textContent=`${circleTiltAngle.toFixed(0)}Â°`;
  circleTiltModifierTag.textContent=`${circleTiltModifier.toFixed(0)}Â°`;
  circleScaleTag.textContent=`${circleScale.toFixed(2)}Ã—`;
  stickVal.textContent = String(Math.round(JOY_BASE_R));
  zoomVal.textContent = `${(zoom||1).toFixed(2)}Ã—`;
  arrowVal.textContent = `${(arrowScale||1).toFixed(2)}Ã—`;
  const currentBrightness = isDarkMode ? brightnessDark : brightnessLight;
  brightnessVal.textContent = `${currentBrightness.toFixed(2)}Ã—`;
  brightnessSlider.value = currentBrightness;
}
syncTags();

// Make all tag elements editable
function setupEditableTags() {
  const tagMappings = [
    {tag: accelPitchTag, slider: accelPitch, setter: (v) => maxAccelPitch = Math.max(0, Math.min(1200, parseFloat(v) || 400))},
    {tag: accelYawTag, slider: accelYaw, setter: (v) => maxAccelYaw = Math.max(0, Math.min(1200, parseFloat(v) || 400))},
    {tag: accelRollTag, slider: accelRoll, setter: (v) => maxAccelRoll = Math.max(0, Math.min(1200, parseFloat(v) || 400))},
    {tag: curveTag, slider: curveRange, setter: (v) => inputPow = Math.max(1, Math.min(4, parseFloat(v) || 1.0))},
    {tag: dampTag, slider: dampRange, setter: (v) => damp = Math.max(0, Math.min(6, parseFloat(v) || 2.96))},
    {tag: dampDARTag, slider: dampDARRange, setter: (v) => dampDAR = Math.max(0, Math.min(6, parseFloat(v) || 4.35))},
    {tag: brakeTag, slider: brakeRange, setter: (v) => brakeOnRelease = Math.max(0, Math.min(6, parseFloat(v) || 0))},
    {tag: wmaxTag, slider: wmaxRange, setter: (v) => wMax = Math.max(6, Math.min(24, parseFloat(v) || 6))},
    {tag: wmaxPitchTag, slider: wmaxPitchRange, setter: (v) => wMaxPitch = Math.max(6, Math.min(24, parseFloat(v) || 8.5))},
    {tag: wmaxYawTag, slider: wmaxYawRange, setter: (v) => wMaxYaw = Math.max(6, Math.min(24, parseFloat(v) || 9))},
    {tag: wmaxRollTag, slider: wmaxRollRange, setter: (v) => wMaxRoll = Math.max(4, Math.min(24, parseFloat(v) || 6))},
    {tag: circleTiltTag, slider: circleTiltRange, setter: (v) => circleTiltAngle = Math.max(0, Math.min(45, parseFloat(v) || 34))},
    {tag: circleTiltModifierTag, slider: circleTiltModifierRange, setter: (v) => circleTiltModifier = Math.max(-45, Math.min(45, parseFloat(v) || 0))},
    {tag: circleScaleTag, slider: circleScaleRange, setter: (v) => circleScale = Math.max(0.2, Math.min(2.0, parseFloat(v) || 0.3))},
    {tag: zoomVal, slider: zoomSlider, setter: (v) => { zoom = Math.max(0.2, Math.min(4.0, parseFloat(v) || 1)); applyZoom(); }},
    {tag: arrowVal, slider: arrowSlider, setter: (v) => arrowScale = Math.max(0.6, Math.min(4, parseFloat(v) || 4))},
    {tag: brightnessVal, slider: brightnessSlider, setter: (v) => {
      const val = Math.max(0.5, Math.min(3, parseFloat(v) || 1));
      if (isDarkMode) brightnessDark = val; else brightnessLight = val;
      applyTheme(isDarkMode);
    }}
  ];

  tagMappings.forEach(mapping => {
    mapping.tag.contentEditable = true;
    mapping.tag.style.cursor = 'text';

    mapping.tag.addEventListener('click', (e) => {
      e.target.select?.() || document.execCommand('selectAll', false, null);
    });

    mapping.tag.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        e.target.blur();
      }
    });

    mapping.tag.addEventListener('blur', (e) => {
      const rawValue = e.target.textContent.replace(/[^\d.-]/g, '');
      mapping.setter(rawValue);
      mapping.slider.value = parseFloat(rawValue) || 0;
      syncTags();
      saveSettings();
    });
  });
}
setupEditableTags();

accelPitch.addEventListener('input',()=>{maxAccelPitch=parseFloat(accelPitch.value)||400; syncTags(); saveSettings();});
accelYaw.addEventListener('input',()=>{maxAccelYaw=parseFloat(accelYaw.value)||400; syncTags(); saveSettings();});
accelRoll.addEventListener('input',()=>{maxAccelRoll=parseFloat(accelRoll.value)||400; syncTags(); saveSettings();});
curveRange.addEventListener('input',()=>{inputPow=parseFloat(curveRange.value)||1.0; syncTags(); saveSettings();});
dampRange .addEventListener('input',()=>{damp=parseFloat(dampRange.value)||2.96; syncTags(); saveSettings();});
dampDARRange .addEventListener('input',()=>{dampDAR=parseFloat(dampDARRange.value)||4.35; syncTags(); saveSettings();});
brakeRange.addEventListener('input',()=>{brakeOnRelease=parseFloat(brakeRange.value)||0.0; syncTags(); saveSettings();});
wmaxRange .addEventListener('input',()=>{wMax=parseFloat(wmaxRange.value)||6.0; syncTags(); saveSettings();});
wmaxPitchRange.addEventListener('input',()=>{wMaxPitch=parseFloat(wmaxPitchRange.value)||8.5; syncTags(); saveSettings();});
wmaxYawRange.addEventListener('input',()=>{wMaxYaw=parseFloat(wmaxYawRange.value)||9.0; syncTags(); saveSettings();});
wmaxRollRange.addEventListener('input',()=>{wMaxRoll=parseFloat(wmaxRollRange.value)||6.0; syncTags(); saveSettings();});
circleTiltRange.addEventListener('input',()=>{circleTiltAngle=parseFloat(circleTiltRange.value)||38; syncTags(); saveSettings();});
circleTiltModifierRange.addEventListener('input',()=>{circleTiltModifier=parseFloat(circleTiltModifierRange.value)||0; syncTags(); saveSettings();});
circleScaleRange.addEventListener('input',()=>{circleScale=parseFloat(circleScaleRange.value)||0.3; syncTags(); saveSettings();});
sizeSlider.addEventListener('input',()=>{JOY_BASE_R=parseInt(stickSizeSlider.value,10)||100; JOY_KNOB_R=Math.round(JOY_BASE_R*0.32); clampJoyCenter(); positionHints(); syncTags();});
zoomSlider.addEventListener('input',()=>{zoom=parseFloat(zoomSlider.value)||1.0; applyZoom(); syncTags(); saveSettings();});
arrowSlider.addEventListener('input',()=>{arrowScale=parseFloat(arrowSlider.value)||4.0; syncTags(); saveSettings();});
brightnessSlider.addEventListener('input',()=>{
  const val = parseFloat(brightnessSlider.value) || 1.0;
  if (isDarkMode) {
    brightnessDark = val;
  } else {
    brightnessLight = val;
  }
  applyTheme(isDarkMode);
  syncTags();
  saveSettings();
});
presetSel .addEventListener('change',()=>{
  const name = presetSel.value;
  Car.buildCar(CONST.CAR_PRESETS[name], name, scene);
  Car.car.quaternion.identity();
  Car.car.rotation.set(Math.PI * 1.5, 0, Math.PI); // X: +270Â°, Y: 0Â°, Z: +180Â°
  w.set(0,0,0);
  saveSettings(); // Save selected car body
});


/* Physics (independent caps for Pitch/Yaw) */
let w = new THREE.Vector3(0,0,0);
const STICK_DEADZONE = STICK_MIN;
const KP_ROLL = 3.2, KD_ROLL = 0.25;

// === NEW VARIABLES - Add these here ===
let inputHistory = { x: [], y: [] };
const INPUT_HISTORY_SIZE = 3;
let prevAlpha = new THREE.Vector3(0, 0, 0);

// === HELPER FUNCTIONS ===
function smoothInput(jx, jy) {
  inputHistory.x.push(jx);
  inputHistory.y.push(jy);
  if (inputHistory.x.length > INPUT_HISTORY_SIZE) {
    inputHistory.x.shift();
    inputHistory.y.shift();
  }
  
  const avgX = inputHistory.x.reduce((a, b) => a + b, 0) / inputHistory.x.length;
  const avgY = inputHistory.y.reduce((a, b) => a + b, 0) / inputHistory.y.length;
  return { x: avgX, y: avgY };
}

function softClampAngularVelocity(w, max) {
  const mag = w.length();
  if (mag <= max) return;
  
  const excess = mag - max;
  const reduction = Math.min(1.0, excess / max);
  const scale = 1.0 - (reduction * 0.3);
  w.multiplyScalar(scale);
}

// Put these near your other physics constants:
// Increased from 18.0 to 36.0 for much more responsive air control in Ring Mode (DAR)
const KpPitch = 36.0, KdPitch = 4.0;
const KpYaw   = 36.0, KdYaw   = 4.0;
const KpRoll  = 12.0, KdRoll  = 3.0;

function integrate(dt) {
  // Skip physics when menu is open
  if (chromeShown) {
    return;
  }

  // --- 1. Smooth joystick position ---
  const a = 1 - Math.exp(-(dt * 1000) / Math.max(1, STICK_TAU_MS));
  smJoy.lerp(joyVec, a);

  const jx = smJoy.x / JOY_BASE_R;
  const jy = -smJoy.y / JOY_BASE_R; // up is positive
  let mag = Math.hypot(jx, jy);

  let eff = 0;
  let ux = 0, uy = 0;

  if (mag > STICK_DEADZONE) {
    const m2 = (mag - STICK_DEADZONE) / (1 - STICK_DEADZONE);
    const shaped = Math.pow(Math.max(0, m2), inputPow || 1.0); // 0..1
    eff = shaped;

    ux = -jx / (mag || 1); // right = +ux
    uy = jy  / (mag || 1); // up = +uy
  }

  // === RING MODE: Calculate movement forces (normal rotation physics will run below) ===
  if (ringModeActive && !ringModePaused && ringModeLives > 0) {
    // Get car's forward direction from quaternion
    const forward = new THREE.Vector3(0, 0, 1); // Car's local forward (flipped from -1 to 1)
    forward.applyQuaternion(Car.car.quaternion);

    // Project onto XY plane for 2D movement
    const boostDirX = forward.x;
    const boostDirY = forward.y;

    // Track if game has started (first boost press)
    if (ringModeBoostActive && !ringModeStarted) {
      ringModeStarted = true;
    }

    // Boost rumble sound control
    if (ringModeBoostActive) {
      Audio.startBoostRumble();
    } else {
      Audio.stopBoostRumble();
    }

    // Apply forces
    let accelX = 0;
    let accelY = ringModeStarted ? CONST.RING_GRAVITY : 0; // Only apply gravity after first boost

    if (ringModeBoostActive) {
      // Boost in the direction car's nose is facing
      accelX += boostDirX * CONST.RING_BOOST_ACCEL;
      accelY += boostDirY * CONST.RING_BOOST_ACCEL;
    }

    // Update boost flame visibility and position
    updateBoostFlames(ringModeBoostActive, forward);

    // Integrate velocity
    ringModeVelocity.x += accelX * dt;
    ringModeVelocity.y += accelY * dt;

    // Clamp to max speed
    const speed = ringModeVelocity.length();
    if (speed > CONST.RING_MAX_SPEED) {
      ringModeVelocity.multiplyScalar(CONST.RING_MAX_SPEED / speed);
    }

    // Integrate position
    ringModePosition.x += ringModeVelocity.x * dt;
    ringModePosition.y += ringModeVelocity.y * dt;

    // Clamp to bounds
    ringModePosition.x = THREE.MathUtils.clamp(ringModePosition.x, -CONST.RING_GRID_BOUNDS, CONST.RING_GRID_BOUNDS);
    ringModePosition.y = THREE.MathUtils.clamp(ringModePosition.y, -CONST.RING_GRID_BOUNDS, CONST.RING_GRID_BOUNDS);

    // Check out of bounds (player went too far)
    if (Math.abs(ringModePosition.x) >= CONST.RING_GRID_BOUNDS ||
        Math.abs(ringModePosition.y) >= CONST.RING_GRID_BOUNDS) {
      // Out of bounds - respawn at next ring position
      ringModeVelocity.set(0, 0);

      // Find next unpassed ring to respawn at
      const nextRing = rings.find(r => !r.passed && !r.missed);
      if (nextRing) {
        // Respawn at the ring's X/Y position
        ringModePosition.set(nextRing.mesh.position.x, nextRing.mesh.position.y);
      } else {
        // No rings available, respawn at center
        ringModePosition.set(0, 0);
      }

      ringModeStarted = false; // Wait for boost before falling
      ringModeLives--; // Lose a life
      console.log('Out of bounds! Lives:', ringModeLives);
    }

    // Continue to normal physics for rotation!
  }

  // --- 2. Front-face arrow (same behavior as before, just using ux,uy,eff) ---
  if (Car.faceArrow && Car.faceTip) {
    const show = showArrow && eff > 0.02;
    Car.faceArrow.visible = show;
    Car.faceTip.visible   = show;

    if (show) {
      const lenMax = Math.min(Car.BOX.hx, Car.BOX.hy) * 0.95;
      const len    = Math.max(10, lenMax * eff * (arrowScale || 1));
      const zFace  = Car.BOX.hz + 0.6;

      const x2 = ux * len;
      const y2 = -uy * len;

      const pos = Car.faceArrow.geometry.attributes.position.array;
      pos[0] = 0;  pos[1] = 0;  pos[2] = zFace;
      pos[3] = x2; pos[4] = y2; pos[5] = zFace;
      Car.faceArrow.geometry.attributes.position.needsUpdate = true;

      const col = (Math.abs(x2) > Math.abs(y2))
        ? (x2 >= 0 ? CONST.COL_LEFT : CONST.COL_RIGHT)
        : (uy >= 0 ? CONST.COL_DOWN : CONST.COL_UP);
      Car.faceArrow.material.color.setHex(col);
      Car.faceTip.material.color.setHex(col);

      Car.faceTip.position.set(x2, y2, zFace);
      const ang = Math.atan2(x2, -y2) + Math.PI;
      Car.faceTip.rotation.set(0, 0, ang);
      const s = 0.95 * (arrowScale || 1);
      Car.faceTip.scale.set(s, s, 1);
    }
  }

  // --- 2b. Tornado circle visualizer (shows DAR cone path) ---
  if (Car.tornadoCircle) {
    // Circle only shows for Air Roll Left/Right (not Free), when DAR is active
    const isDAR = (airRoll === -1 || airRoll === 1);
    const shouldShowCircle = showCircle && isDAR && darOn && eff > 0.02;
    Car.tornadoCircle.visible = shouldShowCircle;

    if (shouldShowCircle) {
      const zFace = Car.BOX.hz + 0.6;

      // Calculate circle radius based on stick input
      const baseRadius = Math.min(Car.BOX.hx, Car.BOX.hy) * 0.95;
      const arrowLength = baseRadius * eff * (arrowScale || 1);

      // Circle scale controlled by circleScale slider
      const circleRadius = arrowLength * (circleScale || 0.3);

      // The circle should be offset perpendicular to the arrow direction
      // Air Roll Left (airRoll = -1): offset +90 degrees (counter-clockwise)
      // Air Roll Right (airRoll = +1): offset -90 degrees (clockwise)
      const arrowAngle = Math.atan2(ux, uy); // angle of the arrow in XY plane
      const perpAngle = arrowAngle + (airRoll * Math.PI / 2); // offset 90 degrees based on roll direction

      // Position circle center perpendicular to arrow, distance = circle radius
      const centerX = Math.sin(perpAngle) * circleRadius;
      const centerY = -Math.cos(perpAngle) * circleRadius;

      Car.tornadoCircle.scale.set(circleRadius, circleRadius, 1);
      Car.tornadoCircle.position.set(centerX, centerY, zFace);

      // Update circle color based on stick direction (same as arrow)
      const col = (Math.abs(ux) > Math.abs(uy))
        ? (ux >= 0 ? CONST.COL_LEFT : CONST.COL_RIGHT)
        : (uy >= 0 ? CONST.COL_DOWN : CONST.COL_UP);
      Car.tornadoCircle.material.color.setHex(col);

      // Apply tilt rotation toward the car
      // Calculate modifier strength: 0 at stable points (every 45Â°), 1.0 at unstable points (between 45Â° marks)
      // Stable points: 0Â°, 45Â°, 90Â°, 135Â°, 180Â°, 225Â°, 270Â°, 315Â°
      // Using sin(4x) to create 8 peaks per rotation (frequency = 4)
      const arrowAngleDeg = (arrowAngle * 180 / Math.PI + 360) % 360;
      const modifierStrength = Math.abs(Math.sin(4 * arrowAngle)); // 0 at stable, 1 at unstable

      // Apply base tilt + modifier
      const totalTilt = circleTiltAngle + (circleTiltModifier * modifierStrength);
      const tiltRad = (totalTilt * Math.PI) / 180;

      // Reset rotation first
      Car.tornadoCircle.rotation.set(0, 0, 0);

      // Rotate around the axis perpendicular to the arrow (makes circle tilt toward car)
      // Negative tiltRad to tilt toward car instead of away
      Car.tornadoCircle.rotateOnAxis(
        new THREE.Vector3(-Math.cos(perpAngle), -Math.sin(perpAngle), 0).normalize(),
        -tiltRad
      );
    }
  }

  // --- 3. Slider conversions (deg/sÂ² â†’ rad/sÂ²) ---
  let maxAccelPitchRad = (maxAccelPitch * Math.PI) / 180;
  let maxAccelYawRad   = (maxAccelYaw   * Math.PI) / 180;
  let maxAccelRollRad  = (maxAccelRoll  * Math.PI) / 180;

  // --- 3.5. DAR acceleration multipliers (from RL measurements) ---
  if (darOn) {
    maxAccelPitchRad *= 0.997;  // DAR: 714â†’712 deg/sÂ²
    maxAccelYawRad *= 1.00;      // DAR: 521â†’522 deg/sÂ² (no change)
    maxAccelRollRad *= 0.98;     // DAR: 2153â†’2110 deg/sÂ²
  }

  // --- 4. Desired angular velocities (rate control) ---
  let maxPitchSpeed = wMaxPitch;  // rad/s, slider already in "Ï‰"
  let maxYawSpeed   = wMaxYaw;    // rad/s
  let targetRollSpeed = 0;        // rad/s

  // Check if using Air Roll (Free) mode
  const isAirRollFree = (airRoll === 2);

  // DAR tornado spin (measured from Rocket League)
  if (darOn && !isAirRollFree) {
    // RL tornado spin: 0.74 seconds per rotation
    const RL_TORNADO_PERIOD = 0.74;  // seconds
    targetRollSpeed = airRoll * (2 * Math.PI) / RL_TORNADO_PERIOD;  // airRoll = Â±1 for Left/Right
  }

  // stick â†’ desired spin rates
  let wx_des, wy_des, wz_des;

  if (isAirRollFree) {
    // Air Roll (Free): horizontal stick controls roll, vertical controls pitch
    wx_des = maxPitchSpeed * eff * uy; // pitch (up/down)
    wy_des = 0;                         // no yaw
    wz_des = wMaxRoll * eff * (-ux);   // roll (left stick = roll left, right stick = roll right)
  } else {
    // Normal or Air Roll Left/Right: standard controls
    wx_des = maxPitchSpeed * eff * uy; // pitch
    wy_des = maxYawSpeed   * eff * ux; // yaw
    wz_des = targetRollSpeed;          // roll from DAR
  }

  // --- 5. PD control â†’ angular acceleration per axis ---
  const ax_des = KpPitch * (wx_des - w.x) - KdPitch * w.x;
  const ay_des = KpYaw   * (wy_des - w.y) - KdYaw   * w.y;
  const az_des = KpRoll  * (wz_des - w.z) - KdRoll  * w.z;

  const ax = THREE.MathUtils.clamp(ax_des, -maxAccelPitchRad, maxAccelPitchRad);
  const ay = THREE.MathUtils.clamp(ay_des, -maxAccelYawRad,   maxAccelYawRad);
  const az = THREE.MathUtils.clamp(az_des, -maxAccelRollRad,  maxAccelRollRad);

  // --- 6. Integrate angular velocity ---
  w.x += ax * dt;
  w.y += ay * dt;
  w.z += az * dt;

  // --- 7. Damping + release brake ---
  // CRITICAL: Damping only applies when inputs are released!
  const noStick = eff < 0.08;
  if (noStick) {
    const baseDamp = darOn ? dampDAR : damp;
    const dampEff = (baseDamp || 0) + ((!darOn) ? (brakeOnRelease || 0) : 0);
    const scale = Math.exp(-dampEff * dt);
    w.multiplyScalar(scale);
  }

  // --- 8. Per-axis caps + global cap ---
  if (Math.abs(w.x) > wMaxPitch) w.x = Math.sign(w.x) * wMaxPitch;
  if (Math.abs(w.y) > wMaxYaw)   w.y = Math.sign(w.y) * wMaxYaw;

  const wMag = w.length();
  if (wMag > wMax) {
    w.multiplyScalar(wMax / wMag);
  }

  // --- 9. Quaternion integration (unchanged) ---
  const wx = w.x, wy = w.y, wz = w.z, halfdt = 0.5 * dt;
  const q = Car.car.quaternion;
  const rw = -q.x * wx - q.y * wy - q.z * wz;
  const rx =  q.w * wx + q.y * wz - q.z * wy;
  const ry =  q.w * wy + q.z * wx - q.x * wz;
  const rz =  q.w * wz + q.x * wy - q.y * wx;
  q.w += rw * halfdt;
  q.x += rx * halfdt;
  q.y += ry * halfdt;
  q.z += rz * halfdt;
  q.normalize();

  // === RING MODE: Override car position and update rings ===
  if (ringModeActive) {
    // Override car position to stay on grid
    if (Car.car) {
      Car.car.position.x = ringModePosition.x;
      Car.car.position.y = ringModePosition.y;
      Car.car.position.z = 0; // Locked to 2D plane
    }

    // Find the closest ring and the next ring ahead of the car (negative Z)
    // Prioritize by spawn order (oldest unpassed ring first), then by Z-distance
    let targetRing = null;
    let nextRing = null;

    // Filter to only active rings (behind camera, not passed/missed)
    const activeRings = rings.filter(r => r.mesh.position.z < 0 && !r.passed && !r.missed);

    if (activeRings.length > 0) {
      // Sort by spawn index (oldest first), then by Z-distance (closest first)
      activeRings.sort((a, b) => {
        // First priority: spawn order (lower index = spawned earlier)
        if (a.spawnIndex !== b.spawnIndex) {
          return a.spawnIndex - b.spawnIndex;
        }
        // Second priority: Z-distance (higher Z = closer to camera)
        return b.mesh.position.z - a.mesh.position.z;
      });

      // Oldest unpassed ring is the target
      targetRing = activeRings[0];

      // Next oldest unpassed ring (if exists)
      if (activeRings.length > 1) {
        nextRing = activeRings[1];
      }
    }

    // Smooth camera path following system - interpolate between multiple rings
    let cameraOffsetX = 0;
    let cameraOffsetY = CONST.CAM_BASE.y;

    if (targetRing) {
      // Calculate weighted average position of next 2-3 upcoming rings
      // This creates a smooth curve through ring centers
      let weightedX = 0;
      let weightedY = 0;
      let totalWeight = 0;

      // Get up to 3 upcoming rings for smooth path
      const upcomingRings = activeRings.slice(0, Math.min(3, activeRings.length));

      for (let i = 0; i < upcomingRings.length; i++) {
        const ring = upcomingRings[i];
        const ringDepth = Math.abs(ring.mesh.position.z);

        // Weight based on depth - closer rings have more influence
        // But far rings still contribute to keep them in frame
        let weight = 1.0;
        if (i === 0) {
          weight = 3.0; // Current target ring has strongest influence
        } else if (i === 1) {
          weight = 1.5; // Next ring has moderate influence
        } else {
          weight = 0.5; // Future rings have minimal influence
        }

        // Reduce weight for very far rings to prevent camera from overshooting
        const depthFactor = Math.min(ringDepth / 1000, 1.0);
        weight *= (1.0 - depthFactor * 0.5);

        weightedX += ring.mesh.position.x * weight;
        weightedY += ring.mesh.position.y * weight;
        totalWeight += weight;
      }

      // Calculate average target position (smooth path through rings)
      if (totalWeight > 0) {
        const pathTargetX = weightedX / totalWeight;
        const pathTargetY = weightedY / totalWeight;

        // Smoothly interpolate camera target toward path
        const smoothing = 0.05; // Very smooth interpolation
        cameraTargetX += (pathTargetX - cameraTargetX) * smoothing;
        cameraTargetY += (pathTargetY - cameraTargetY) * smoothing;

        // Calculate direction from car to smooth path target
        const deltaX = cameraTargetX - ringModePosition.x;
        const deltaY = cameraTargetY - ringModePosition.y;
        const distXY = Math.hypot(deltaX, deltaY);

        if (distXY > 0.1) {
          // Normalize direction
          const dirX = deltaX / distXY;
          const dirY = deltaY / distXY;

          // Minimal camera orbit - keep it simple and smooth
          const orbitRadius = 150; // Fixed moderate orbit

          // Camera aims to keep path visible
          cameraOffsetX = -dirX * orbitRadius;
          cameraOffsetY = CONST.CAM_BASE.y - dirY * 100;
        }
      }
    }

    // Smoothly move camera to target offset position
    const targetCamX = ringModePosition.x + cameraOffsetX;
    const targetCamY = ringModePosition.y + cameraOffsetY;
    const targetCamZ = CONST.CAM_BASE.z;

    // Lerp camera position for smooth movement
    camera.position.x += (targetCamX - camera.position.x) * ringCameraSpeed;
    camera.position.y += (targetCamY - camera.position.y) * ringCameraSpeed;
    camera.position.z = targetCamZ;

    // Look at point between car and next ring to keep distant rings visible
    let lookAtX = ringModePosition.x;
    let lookAtY = ringModePosition.y;
    let lookAtZ = 0;

    if (targetRing) {
      // Calculate full 3D distance from car to ring
      const dx = targetRing.mesh.position.x - ringModePosition.x;
      const dy = targetRing.mesh.position.y - ringModePosition.y;
      const dz = targetRing.mesh.position.z - 0; // Car is at Z=0
      const ringDistance3D = Math.sqrt(dx*dx + dy*dy + dz*dz);

      // Much gentler blend - max 20% toward ring to keep car on screen
      // Only blend if ring is very far (>2000 units)
      const blendFactor = ringDistance3D > 2000 ? Math.min((ringDistance3D - 2000) / 4000, 0.2) : 0;

      lookAtX = ringModePosition.x * (1 - blendFactor) + targetRing.mesh.position.x * blendFactor;
      lookAtY = ringModePosition.y * (1 - blendFactor) + targetRing.mesh.position.y * blendFactor;
      lookAtZ = 0 * (1 - blendFactor) + targetRing.mesh.position.z * blendFactor * 0.2; // Minimal Z shift
    }

    camera.lookAt(lookAtX, lookAtY, lookAtZ);

    // Move rings toward camera (only if not paused, game has started, and not game over)
    if (!ringModePaused && ringModeStarted && ringModeLives > 0) {
      for(let i = rings.length - 1; i >= 0; i--) {
        const ring = rings[i];
        const prevZ = ring.mesh.position.z;
        ring.mesh.position.z += ring.speed * dt; // Use individual ring speed for progression
        const newZ = ring.mesh.position.z;

        // Update visual effects based on distance for depth perception
        const distanceZ = Math.abs(ring.mesh.position.z);

        // Opacity fade: full opacity when close, fade out when far
        // Starts fading at 3000 units, fully visible at 1000 units
        const opacityFactor = THREE.MathUtils.clamp(1 - (distanceZ - 1000) / 2000, 0.3, 1);
        ring.mesh.material.opacity = opacityFactor;
        ring.mesh.material.transparent = true;

        // Emissive intensity: brighter when close, dimmer when far
        // This creates a fog-like effect
        const emissiveFactor = THREE.MathUtils.clamp(1 - distanceZ / 4000, 0.3, 0.8);
        ring.mesh.material.emissiveIntensity = emissiveFactor;

        // Point light intensity also fades with distance
        if (ring.mesh.children[0] && ring.mesh.children[0].isLight) {
          const lightIntensity = THREE.MathUtils.clamp(2 - distanceZ / 2000, 0.5, 2);
          ring.mesh.children[0].intensity = lightIntensity;
        }

        // Check if car passed through the ring's plane (Z=0, where car is locked)
        if (prevZ < 0 && newZ >= 0 && !ring.passed && !ring.missed) {
          // Ring crossed the car's Z plane - check for collision
          const carX = ringModePosition.x;
          const carY = ringModePosition.y;
          const ringX = ring.mesh.position.x;
          const ringY = ring.mesh.position.y;

          // Distance from car center to ring center in XY plane
          const dx = carX - ringX;
          const dy = carY - ringY;
          const distanceToCenter = Math.sqrt(dx * dx + dy * dy);

          // Ring outer and inner radii
          const ringOuterRadius = ring.size / 2 + CONST.RING_TUBE_RADIUS;
          const ringInnerRadius = ring.size / 2 - CONST.RING_TUBE_RADIUS;

          if (distanceToCenter <= ringInnerRadius) {
            // Clean pass - car went through the center
            ring.passed = true;
            ringModeScore++;
            ringModeRingCount++;
            console.log('Passed through ring! Score:', ringModeScore);

            // Audio feedback - play success sound
            Audio.playRingPassSound();
          } else if (distanceToCenter < ringOuterRadius) {
            // Hit the edge of the ring
            ring.missed = true;
            console.log('Hit ring edge! Heart damage');
            // Audio feedback - play miss sound
            Audio.playRingMissSound();
            // TODO: Apply heart damage
          } else {
            // Completely missed the ring
            ring.missed = true;
            ringModeLives--;
            console.log('Missed ring! Lives:', ringModeLives);
            // Audio feedback - play miss sound
            Audio.playRingMissSound();
            // TODO: Check if game over
          }
        }

        // Remove rings immediately after they pass through grid (Z=0)
        // No need to keep them traveling behind the player
        if(ring.mesh.position.z > 50) { // Small buffer past Z=0
          // Check if we missed an unpassed ring
          if (!ring.passed && !ring.missed) {
            ringModeLives--;
            console.log('Ring passed without going through! Lives:', ringModeLives);
            // Audio feedback - play miss sound
            Audio.playRingMissSound();
          }
          scene.remove(ring.mesh);
          ring.mesh.geometry.dispose();
          ring.mesh.material.dispose();
          rings.splice(i, 1);
        }
      }

      // Spawn new rings periodically (affected by difficulty)
      ringSpawnTimer += dt;
      const spawnInterval = CONST.RING_BASE_SPAWN_INTERVAL * CONST.DIFFICULTY_SETTINGS[currentDifficulty].spawnIntervalMultiplier;
      if(ringSpawnTimer >= spawnInterval) {
        spawnRing();
        ringSpawnTimer = 0;
      }
    }
  }
}
/* Camera zoom/orbit *//* Camera zoom/orbit */
let orbitPhase=0;

function applyZoom(){
  const f = Math.max(0.7, Math.min(1.6, zoom||1));
  const dist = CONST.CAM_BASE.z / f;
  const h = CONST.CAM_BASE.y / f;
  if(!orbitOn){
    camera.position.set(0, h, dist);
    camera.lookAt(0, Car.car ? Car.car.position.y : 0, 0);
  }
}

function orbitStep(t){
  const f = Math.max(0.7, Math.min(1.6, zoom||1));
  const R = (CONST.CAM_BASE.z / f);
  const h = (CONST.CAM_BASE.y / f);
  const sp = 0.35 * orbitDir;
  const x = Math.sin(t*sp)*R;
  const z = Math.cos(t*sp)*R;
  camera.position.set(x, h, z);
  camera.lookAt(0, Car.car ? Car.car.position.y : 0, 0);
}

/* XYZ Gizmo */
/* XYZ Gizmo */
const gizmoRect = document.getElementById('gizmoFrame').getBoundingClientRect();
const gizmoScene = new THREE.Scene();
const gizmoCam = new THREE.PerspectiveCamera(40, gizmoRect.width/gizmoRect.height, 0.1, 100);
gizmoCam.position.set(0,0,6);
const gizmoAxes = new THREE.AxesHelper(3.2);
gizmoScene.add(gizmoAxes);
const gizmoTarget = new THREE.Object3D();
gizmoScene.add(gizmoTarget);
gizmoAxes.position.copy(gizmoTarget.position);

/* Render HUD & loop */
function renderHUD(){
  Rendering.renderHUD({
    // Joystick state
    JOY_CENTER, JOY_BASE_R, JOY_KNOB_R, joyVec, COLS,
    // DAR button state
    DAR_CENTER, DAR_R, darOn, airRoll,
    // Boost button state
    BOOST_CENTER, BOOST_R, ringModeBoostActive, showBoostButton,
    // Ring Mode state
    ringModeActive, ringModeStarted, ringModePaused,
    ringModeLives, ringModeScore, ringModeHighScore, ringModeRingCount,
    ringModePosition, rings, isMobile, currentDifficulty
  });
}


let lastT = performance.now()/1000;
function tick(){
  const t = performance.now()/1000;
  const dt = Math.min(0.033, Math.max(0.001, t - lastT));
  lastT = t;

  if(orbitOn){ orbitPhase += dt; orbitStep(orbitPhase); }

  // Update input state from Input module
  Input.updateInput(dt);

  integrate(dt);

  renderer.setScissorTest(false);
  renderer.setViewport(0,0,innerWidth,innerHeight);
  renderer.render(scene, camera);

  if(Car.car){
    gizmoTarget.quaternion.copy(Car.car.quaternion);
    gizmoAxes.quaternion.copy(gizmoTarget.quaternion);
  }
  const gf = document.getElementById('gizmoFrame').getBoundingClientRect();
  const sx = Math.floor(gf.left), sy = Math.floor(innerHeight - gf.bottom);
  const sw = Math.floor(gf.width), sh = Math.floor(gf.height);
  renderer.setScissorTest(true);
  renderer.setScissor(sx,sy,sw,sh);
  renderer.setViewport(sx,sy,sw,sh);
  renderer.render(gizmoScene, gizmoCam);
  renderer.setScissorTest(false);

  renderHUD();
  requestAnimationFrame(tick);
}

/* Resize & boot */
function resize(){
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  Rendering.sizeHud();
  Input.handleResize();
  applyZoom();
}
addEventListener('resize', resize);

// Initialize Input module with callbacks
Input.initInput(hud, {
  openMenu: openMenu,
  closeMenu: closeMenu,
  retry: resetRingMode,
  getRingModeLives: () => ringModeLives
});

// Restore saved car body or default to octane
const savedCarBody = savedSettings.selectedCarBody || 'octane';
if (CONST.CAR_PRESETS[savedCarBody]) {
  Car.buildCar(CONST.CAR_PRESETS[savedCarBody], savedCarBody, scene);
  presetSel.value = savedCarBody;
} else {
  Car.buildCar(CONST.CAR_PRESETS.octane, "octane", scene);
}

// Set initial menu button styling based on saved selection
updateMenuButtonStyling();

// Set initial rotation: roof facing camera, nose pointing up
// X: +270Â°, Y: 0Â°, Z: +180Â°
if (Car.car) {
  Car.car.rotation.set(Math.PI * 1.5, 0, Math.PI); // X: +270Â°, Y: 0Â°, Z: +180Â°
}

// Preload Ring Mode resources after car is ready (prevents lag on first ring spawn)
preloadRingResources();

// Restore saved air roll (skipSave = true to avoid overwriting localStorage on load)
setRoll(airRoll, true);

positionHints();
applyZoom();
applyTheme(isDarkMode); // Initialize theme

// Restore theme button state (main screen)
const themeBtn = document.getElementById('themeBtn');
themeBtn.textContent = isDarkMode ? 'ðŸŒ™' : 'â˜€ï¸';

// Restore arrow and circle toggle button states
const arrowToggleBtn = document.getElementById('arrowToggle');
arrowToggleBtn.classList.toggle('active', showArrow);
arrowToggleBtn.textContent = showArrow ? 'Show Arrow' : 'Hide Arrow';

const circleToggleBtn = document.getElementById('circleToggle');
circleToggleBtn.classList.toggle('active', showCircle);
circleToggleBtn.textContent = showCircle ? 'Show Circle' : 'Hide Circle';

// Restore toggle/hold mode button state
const toggleModeBtn = document.getElementById('toggleMode');
toggleModeBtn.classList.toggle('active', airRollIsToggle);
toggleModeBtn.textContent = airRollIsToggle ? 'Toggle' : 'Hold';

// Restore gamepad enabled button state
gpEnableBtn.classList.toggle('active', gpEnabled);
gpStatusTag.textContent = gpEnabled ? 'Enabled (waiting for gamepad)' : 'Disabled';

// Restore Ring Mode difficulty selector
if (ringDifficultySelector) {
  ringDifficultySelector.value = currentDifficulty;
}

requestAnimationFrame(tick);
</script>
</body>
</html>
