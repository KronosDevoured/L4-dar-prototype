<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>L4 DAR Input Test Runner</title>
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.164.0/build/three.module.js",
      "three/examples/jsm/utils/BufferGeometryUtils.js": "https://unpkg.com/three@0.164.0/examples/jsm/utils/BufferGeometryUtils.js"
    }
  }
  </script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: #1a1a1a;
      color: #e0e0e0;
      padding: 20px;
    }
    .container {
      max-width: 1200px;
      margin: 0 auto;
    }
    h1 {
      margin-bottom: 20px;
      color: #4c8dff;
    }
    .controls {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    button {
      background: #4c8dff;
      color: white;
      border: none;
      padding: 10px 20px;
      border-radius: 5px;
      cursor: pointer;
      font-size: 14px;
    }
    button:hover { background: #3a7ae8; }
    button:disabled {
      background: #555;
      cursor: not-allowed;
    }
    .stats {
      background: #2a2a2a;
      padding: 15px;
      border-radius: 8px;
      margin-bottom: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
      gap: 15px;
    }
    .stat {
      text-align: center;
    }
    .stat-value {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 5px;
    }
    .stat-label {
      font-size: 12px;
      color: #888;
      text-transform: uppercase;
    }
    .pass { color: #4caf50; }
    .fail { color: #f44336; }
    .skip { color: #ff9800; }
    .tests {
      background: #2a2a2a;
      border-radius: 8px;
      overflow: hidden;
    }
    .test-category {
      border-bottom: 1px solid #3a3a3a;
    }
    .category-header {
      background: #333;
      padding: 12px 15px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .category-header:hover { background: #3a3a3a; }
    .category-title {
      font-weight: bold;
      font-size: 16px;
    }
    .category-stats {
      font-size: 12px;
      color: #888;
    }
    .test-list {
      display: none;
    }
    .test-list.expanded {
      display: block;
    }
    .test-item {
      padding: 10px 15px;
      border-bottom: 1px solid #3a3a3a;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    .test-item:last-child { border-bottom: none; }
    .test-name {
      flex: 1;
      font-size: 14px;
    }
    .test-status {
      padding: 4px 12px;
      border-radius: 3px;
      font-size: 12px;
      font-weight: bold;
      min-width: 80px;
      text-align: center;
    }
    .test-status.pending { background: #555; color: #aaa; }
    .test-status.running { background: #2196F3; color: white; }
    .test-status.pass { background: #4caf50; color: white; }
    .test-status.fail { background: #f44336; color: white; }
    .test-status.skip { background: #ff9800; color: white; }
    .test-error {
      margin-top: 5px;
      padding: 8px;
      background: #3a1a1a;
      border-left: 3px solid #f44336;
      font-size: 12px;
      font-family: 'Courier New', monospace;
      color: #ffaaaa;
    }
    .progress-bar {
      height: 4px;
      background: #3a3a3a;
      border-radius: 2px;
      overflow: hidden;
      margin-bottom: 20px;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #4c8dff, #3a7ae8);
      width: 0%;
      transition: width 0.3s ease;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>L4 DAR Input System Test Runner</h1>

    <div class="controls">
      <button id="runAll">Run All Tests</button>
      <button id="runFailed">Run Failed Only</button>
      <button id="clearResults">Clear Results</button>
      <button id="exportResults">Export Results</button>
    </div>

    <div class="progress-bar">
      <div class="progress-fill" id="progressBar"></div>
    </div>

    <div class="stats">
      <div class="stat">
        <div class="stat-value pass" id="passCount">0</div>
        <div class="stat-label">Passed</div>
      </div>
      <div class="stat">
        <div class="stat-value fail" id="failCount">0</div>
        <div class="stat-label">Failed</div>
      </div>
      <div class="stat">
        <div class="stat-value skip" id="skipCount">0</div>
        <div class="stat-label">Skipped</div>
      </div>
      <div class="stat">
        <div class="stat-value" id="totalCount">0</div>
        <div class="stat-label">Total</div>
      </div>
    </div>

    <div class="tests" id="testContainer"></div>
  </div>

  <script type="module">
    import * as Input from './js/modules/input.js';
    import * as TouchInput from './js/modules/input/touchInput.js';
    import * as KeyboardInput from './js/modules/input/keyboardInput.js';
    import * as GamepadInput from './js/modules/input/gamepadInput.js';
    import * as AirRollController from './js/modules/input/airRollController.js';
    import * as Settings from './js/modules/settings.js';

    // Test framework
    class TestRunner {
      constructor() {
        this.tests = [];
        this.results = [];
        this.stats = { pass: 0, fail: 0, skip: 0, total: 0 };
      }

      category(name, tests) {
        this.tests.push({ type: 'category', name, tests });
      }

      test(name, fn, options = {}) {
        return { name, fn, options };
      }

      async runAll() {
        this.results = [];
        this.stats = { pass: 0, fail: 0, skip: 0, total: 0 };
        this.updateStats();
        this.updateProgress(0);

        let testIndex = 0;
        const allTests = this.getAllTests();

        for (const category of this.tests) {
          for (const test of category.tests) {
            testIndex++;
            const result = await this.runTest(test, category.name);
            this.results.push({ ...result, category: category.name });
            this.updateUI(result, category.name);
            this.updateStats();
            this.updateProgress((testIndex / allTests.length) * 100);

            // Small delay between tests
            await new Promise(resolve => setTimeout(resolve, 10));
          }
        }
      }

      async runTest(test, categoryName) {
        const testId = `${categoryName}-${test.name}`;
        this.setTestStatus(testId, 'running');

        if (test.options.skip) {
          this.stats.skip++;
          return { name: test.name, status: 'skip', reason: test.options.skip };
        }

        try {
          await test.fn();
          this.stats.pass++;
          return { name: test.name, status: 'pass' };
        } catch (error) {
          this.stats.fail++;
          return { name: test.name, status: 'fail', error: error.message };
        }
      }

      getAllTests() {
        return this.tests.flatMap(cat => cat.tests);
      }

      setTestStatus(testId, status) {
        const element = document.getElementById(testId);
        if (element) {
          const statusEl = element.querySelector('.test-status');
          statusEl.textContent = status.toUpperCase();
          statusEl.className = `test-status ${status}`;
        }
      }

      updateUI(result, categoryName) {
        const testId = `${categoryName}-${result.name}`;
        const element = document.getElementById(testId);
        if (element) {
          const statusEl = element.querySelector('.test-status');
          statusEl.textContent = result.status.toUpperCase();
          statusEl.className = `test-status ${result.status}`;

          if (result.error) {
            const errorEl = document.createElement('div');
            errorEl.className = 'test-error';
            errorEl.textContent = result.error;
            element.appendChild(errorEl);
          }
        }
      }

      updateStats() {
        document.getElementById('passCount').textContent = this.stats.pass;
        document.getElementById('failCount').textContent = this.stats.fail;
        document.getElementById('skipCount').textContent = this.stats.skip;
        document.getElementById('totalCount').textContent = this.getAllTests().length;
      }

      updateProgress(percent) {
        document.getElementById('progressBar').style.width = `${percent}%`;
      }

      renderUI() {
        const container = document.getElementById('testContainer');
        container.innerHTML = '';

        this.tests.forEach(category => {
          const categoryEl = document.createElement('div');
          categoryEl.className = 'test-category';

          const header = document.createElement('div');
          header.className = 'category-header';
          header.innerHTML = `
            <span class="category-title">${category.name}</span>
            <span class="category-stats">${category.tests.length} tests</span>
          `;

          const testList = document.createElement('div');
          testList.className = 'test-list';

          category.tests.forEach(test => {
            const testEl = document.createElement('div');
            testEl.className = 'test-item';
            testEl.id = `${category.name}-${test.name}`;
            testEl.innerHTML = `
              <div class="test-name">${test.name}</div>
              <div class="test-status pending">PENDING</div>
            `;
            testList.appendChild(testEl);
          });

          header.addEventListener('click', () => {
            testList.classList.toggle('expanded');
          });

          categoryEl.appendChild(header);
          categoryEl.appendChild(testList);
          container.appendChild(categoryEl);
        });

        this.updateStats();
      }
    }

    // Create test runner
    const runner = new TestRunner();

    // Helper functions
    function assert(condition, message) {
      if (!condition) throw new Error(message);
    }

    function assertEquals(actual, expected, message) {
      if (actual !== expected) {
        throw new Error(`${message}\nExpected: ${expected}\nActual: ${actual}`);
      }
    }

    function assertExists(value, message) {
      if (value === undefined || value === null) {
        throw new Error(message || 'Value does not exist');
      }
    }

    // Define tests
    runner.category('Module Loading', [
      runner.test('Input module exports exist', () => {
        assertExists(Input.initInput, 'initInput should exist');
        assertExists(Input.updateInput, 'updateInput should exist');
        assertExists(Input.getJoyVec, 'getJoyVec should exist');
        assertExists(Input.getAirRoll, 'getAirRoll should exist');
      }),

      runner.test('TouchInput module exports exist', () => {
        assertExists(TouchInput.getJoyVec, 'TouchInput.getJoyVec should exist');
        assertExists(TouchInput.getJoyActive, 'TouchInput.getJoyActive should exist');
        assertExists(TouchInput.getDarOn, 'TouchInput.getDarOn should exist');
      }),

      runner.test('AirRollController module exports exist', () => {
        assertExists(AirRollController.getAirRoll, 'getAirRoll should exist');
        assertExists(AirRollController.setRoll, 'setRoll should exist');
        assertExists(AirRollController.getAirRollIsToggle, 'getAirRollIsToggle should exist');
      }),

      runner.test('Settings module exports exist', () => {
        assertExists(Settings.loadSettings, 'loadSettings should exist');
        assertExists(Settings.saveSettings, 'saveSettings should exist');
        assertExists(Settings.getAllSettings, 'getAllSettings should exist');
      }),
    ]);

    runner.category('Input Module State', [
      runner.test('Initial joystick vector is zero', () => {
        const vec = Input.getJoyVec();
        assertEquals(vec.x, 0, 'Joystick X should be 0');
        assertEquals(vec.y, 0, 'Joystick Y should be 0');
      }),

      runner.test('Initial air roll is off', () => {
        const airRoll = Input.getAirRoll();
        assert(airRoll === 0 || airRoll === -1 || airRoll === 1 || airRoll === 2,
          'Air roll should be a valid value');
      }),

      runner.test('Joystick base radius is positive', () => {
        const radius = Input.getJoyBaseR();
        assert(radius > 0, `Joystick radius should be > 0, got ${radius}`);
      }),

      runner.test('DAR center has valid coordinates', () => {
        const center = Input.getDarCenter();
        assertExists(center.x, 'DAR center X should exist');
        assertExists(center.y, 'DAR center Y should exist');
        assert(center.x > 0, 'DAR center X should be positive');
        assert(center.y > 0, 'DAR center Y should be positive');
      }),
    ]);

    runner.category('Air Roll Controller', [
      runner.test('Can set roll left', () => {
        AirRollController.setRoll(-1, true);
        assertEquals(AirRollController.getAirRoll(), -1, 'Should be roll left (-1)');
      }),

      runner.test('Can set roll right', () => {
        AirRollController.setRoll(1, true);
        assertEquals(AirRollController.getAirRoll(), 1, 'Should be roll right (1)');
      }),

      runner.test('Can set free roll', () => {
        AirRollController.setRoll(2, true);
        assertEquals(AirRollController.getAirRoll(), 2, 'Should be free roll (2)');
      }),

      runner.test('Can turn off roll', () => {
        AirRollController.setRoll(0, true);
        assertEquals(AirRollController.getAirRoll(), 0, 'Should be off (0)');
      }),

      runner.test('Last active roll is remembered', () => {
        AirRollController.setRoll(-1, true);
        AirRollController.setRoll(0, true);
        const lastActive = AirRollController.getLastActiveAirRoll();
        assertEquals(lastActive, -1, 'Should remember last active roll');
      }),
    ]);

    runner.category('Settings Persistence', [
      runner.test('Can load settings', () => {
        const settings = Settings.loadSettings();
        assertExists(settings, 'Settings should load');
        assertExists(settings.maxAccelPitch, 'Should have maxAccelPitch');
        assertExists(settings.damp, 'Should have damp');
      }),

      runner.test('Can get individual setting', () => {
        const damp = Settings.getSetting('damp');
        assertExists(damp, 'Should get damp setting');
        assert(typeof damp === 'number', 'Damp should be a number');
      }),

      runner.test('Settings returns copy (immutability)', () => {
        const settings1 = Settings.getAllSettings();
        const settings2 = Settings.getAllSettings();
        assert(settings1 !== settings2, 'Should return different object instances');
      }),
    ]);

    runner.category('Touch Input Getters', [
      runner.test('Joystick vector returns Vector2', () => {
        const vec = TouchInput.getJoyVec();
        assertExists(vec, 'Should return joystick vector');
        assertExists(vec.x, 'Should have x property');
        assertExists(vec.y, 'Should have y property');
      }),

      runner.test('Joystick active returns boolean', () => {
        const active = TouchInput.getJoyActive();
        assert(typeof active === 'boolean', 'Should return boolean');
      }),

      runner.test('DAR on returns boolean', () => {
        const darOn = TouchInput.getDarOn();
        assert(typeof darOn === 'boolean', 'DAR on should be boolean');
      }),

      runner.test('Centers return valid coordinates', () => {
        const joyCenter = TouchInput.getJoyCenter();
        const darCenter = TouchInput.getDarCenter();

        assertExists(joyCenter.x, 'Joy center X exists');
        assertExists(joyCenter.y, 'Joy center Y exists');
        assertExists(darCenter.x, 'DAR center X exists');
        assertExists(darCenter.y, 'DAR center Y exists');
      }),
    ]);

    runner.category('Gamepad State', [
      runner.test('Gamepad enabled state is boolean', () => {
        const enabled = GamepadInput.getGpEnabled();
        assert(typeof enabled === 'boolean', 'Should be boolean');
      }),

      runner.test('Gamepad bindings exist', () => {
        const bindings = GamepadInput.getGpBindings();
        assertExists(bindings, 'Bindings should exist');
        assertExists(bindings.toggleDAR, 'Should have toggleDAR binding');
        assertExists(bindings.rollLeft, 'Should have rollLeft binding');
        assertExists(bindings.boost, 'Should have boost binding');
      }),

      runner.test('Gamepad pressing air roll returns boolean', () => {
        const pressing = GamepadInput.isGamepadPressingAirRoll();
        assert(typeof pressing === 'boolean', 'Should be boolean');
      }),
    ]);

    runner.category('Input Module Exports', [
      runner.test('All getters are functions', () => {
        assert(typeof Input.getJoyVec === 'function', 'getJoyVec should be function');
        assert(typeof Input.getJoyActive === 'function', 'getJoyActive should be function');
        assert(typeof Input.getAirRoll === 'function', 'getAirRoll should be function');
        assert(typeof Input.getDarOn === 'function', 'getDarOn should be function');
      }),

      runner.test('Menu state getters exist', () => {
        assertExists(Input.getChromeShown, 'getChromeShown should exist');
        assert(typeof Input.getChromeShown === 'function', 'getChromeShown should be function');
      }),

      runner.test('Device detection works', () => {
        const isMobile = Input.getIsMobile();
        const isDesktop = Input.getIsDesktop();
        assert(typeof isMobile === 'boolean', 'isMobile should be boolean');
        assert(typeof isDesktop === 'boolean', 'isDesktop should be boolean');
      }),
    ]);

    runner.category('Constants and Configuration', [
      runner.test('STICK_DEADZONE is defined', () => {
        assertExists(Input.STICK_DEADZONE, 'STICK_DEADZONE should exist');
        assert(Input.STICK_DEADZONE > 0, 'Deadzone should be positive');
        assert(Input.STICK_DEADZONE < 1, 'Deadzone should be less than 1');
      }),

      runner.test('Joystick size is configurable', () => {
        const initialSize = Input.getJoyBaseR();
        Input.updateJoystickSize(150);
        const newSize = Input.getJoyBaseR();
        assertEquals(newSize, 150, 'Joystick size should update');
        Input.updateJoystickSize(initialSize); // Restore
      }),
    ]);

    // UI Event Handlers
    document.getElementById('runAll').addEventListener('click', async () => {
      document.getElementById('runAll').disabled = true;
      await runner.runAll();
      document.getElementById('runAll').disabled = false;
    });

    document.getElementById('runFailed').addEventListener('click', async () => {
      // TODO: Implement run failed only
      alert('Run Failed Only - Coming soon!');
    });

    document.getElementById('clearResults').addEventListener('click', () => {
      runner.results = [];
      runner.stats = { pass: 0, fail: 0, skip: 0, total: 0 };
      runner.renderUI();
      runner.updateProgress(0);
    });

    document.getElementById('exportResults').addEventListener('click', () => {
      const results = {
        timestamp: new Date().toISOString(),
        stats: runner.stats,
        tests: runner.results
      };
      const blob = new Blob([JSON.stringify(results, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `test-results-${Date.now()}.json`;
      a.click();
    });

    // Initialize UI
    runner.renderUI();
    console.log('Test runner initialized. Click "Run All Tests" to begin.');
  </script>
</body>
</html>
