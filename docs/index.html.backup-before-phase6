<!DOCTYPE html>
<html lang="en">
    <script type="importmap">
{
  "imports": {
    "three": "https://unpkg.com/three@0.164.0/build/three.module.js"
  }
}
</script>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>L4 Aerial Car Control Tool</title>
<link rel="icon" type="image/svg+xml" href="favicon.svg" />
<style>
  /* === CSS BASE START === */
  html,body{margin:0;padding:0;height:100%;background:#ffffff;color:#0e0f12;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;overscroll-behavior:none}
  body{background:linear-gradient(180deg,#f6f7fb 0%,#eef1f6 45%,#e9edf3 100%);}
  *, *::before, *::after{box-sizing:border-box}
  *{-webkit-user-select:none;-ms-user-select:none;user-select:none;-webkit-touch-callout:none}
  #gl{position:fixed;inset:0;z-index:0;display:block}
  #hud{position:fixed;inset:0;z-index:1;display:block;touch-action:none}
  /* === CSS BASE END === */

  /* === HAMBURGER === */
  #menuBtn{
    position:fixed;top:.6rem;right:.6rem;z-index:3;width:44px;height:44px;
    border-radius:12px;border:1px solid #3a3d45;background:#181a20;display:grid;place-items:center;
    box-shadow:0 2px 10px rgba(0,0,0,.25)
  }
  #menuBtn .bar{display:block;width:20px;height:2px;background:#e8e8ea;margin:3px 0}
  #menuBtn.active{background:#0066ff;border-color:#4c8dff}

  /* === THEME BUTTON (Sun/Moon) === */
  #themeBtn{
    position:fixed;top:.6rem;right:3.5rem;z-index:3;width:44px;height:44px;
    border:none;background:transparent;font-size:1.8rem;cursor:pointer;
    display:grid;place-items:center;padding:0;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,.3));
  }
  #themeBtn:hover{transform:scale(1.1)}
  #themeBtn:active{transform:scale(0.95)}

  /* Fullscreen button */
  #fullscreenBtn{
    position:fixed;top:.6rem;right:7rem;z-index:3;width:44px;height:44px;
    border:2px solid #4c8dff;background:rgba(76,141,255,0.15);
    font-size:2rem;cursor:pointer;border-radius:8px;
    display:grid;place-items:center;padding:0;
    filter: drop-shadow(0 2px 8px rgba(76,141,255,.4));
    color:#4c8dff;
  }
  #fullscreenBtn:hover{transform:scale(1.1);background:rgba(76,141,255,0.25);}
  #fullscreenBtn:active{transform:scale(0.95)}

  /* === OVERLAY MENU PANEL === */
  #menuOverlay{
    position:fixed; inset:0; z-index:4; display:none;
    background:rgba(10,12,16,0.45); -webkit-backdrop-filter: blur(3px); backdrop-filter: blur(3px);
    overflow-x:hidden;
  }
  #menuPanel{
    position:absolute; left:50%; top:12vh; transform:translateX(-50%);
    width:min(960px, calc(100vw - 2rem)); max-height:76vh; overflow:auto;
    background:rgba(24,26,32,.96); color:#e8e8ea; border:1px solid #3a3d45; border-radius:14px;
    box-shadow:0 20px 60px rgba(0,0,0,.35);
    overflow-x:hidden;
  }
  .mp-header{
    position:sticky; top:0; background:rgba(24,26,32,.98); z-index:1;
    padding:.9rem clamp(.8rem, 2vw, 1rem); border-bottom:1px solid #33373f; display:flex; align-items:center; justify-content:space-between;
  }
  .mp-title{font-weight:700;letter-spacing:.2px}
  .mp-close{border:1px solid #3a3d45;background:#181a20;color:#e8e8ea;border-radius:10px;padding:.35rem .6rem;font-weight:600}
  .mp-body{
    padding:clamp(.6rem,2vw,1rem);
    display:grid; grid-template-columns: 1fr; gap:14px;
  }

  .card{
    background:#15171d; border:1px solid #33373f; border-radius:12px; padding:.9rem;
  }
  .card h3{
    margin:.1rem 0 .7rem; font-size:1rem; opacity:.95; cursor:pointer; user-select:none;
    display:flex; align-items:center; justify-content:space-between;
  }
  .card h3:hover{opacity:1; color:#4c8dff;}
  .card h3::after{
    content:'â–¼'; font-size:.8rem; transition: transform 0.2s;
  }
  .card.collapsed h3::after{
    transform: rotate(-90deg);
  }
  .card-content{
    overflow:hidden; transition: max-height 0.3s ease, opacity 0.2s ease;
  }
  .card.collapsed .card-content{
    max-height:0 !important; opacity:0;
  }
  .row{display:flex; align-items:center; gap:.5rem; flex-wrap:wrap; margin:.45rem 0; width:100%;}
  .tip{
    font-size:.86rem; opacity:.85; line-height:1.5; margin:.5rem 0;
    padding:.5rem .7rem; background:rgba(255,255,255,.03);
    border-left:3px solid #4c8dff; border-radius:4px;
  }
  .btn{border:1px solid #3a3d45;padding:.45rem .7rem;border-radius:999px;background:#181a20;color:#e8e8ea;font-weight:600;letter-spacing:.2px;cursor:pointer}
  .btn.active{background:#0066ff;border-color:#4c8dff}
  .tag{
    background:#181a20;border:1px solid #3a3d45;padding:.25rem .5rem;
    border-radius:999px;font-size:.82rem;white-space:nowrap;
    cursor:text;user-select:text;
  }
  .tag:hover{border-color:#4c8dff}
  .tag:focus{outline:2px solid #4c8dff;background:#1f2229}

  .sl{
    display:flex; align-items:center; gap:.6rem; flex-wrap:nowrap;
    width:100%; min-width:0;
  }
  .sl label{
    font-size:.88rem; opacity:.92; flex:0 0 150px; min-width:120px; max-width:220px;
  }
  .sl input[type=range]{
    accent-color:#4c8dff;
    flex:1 1 auto; min-width:0; max-width:100%; width:100%;
  }
  .sl .tag{flex:0 0 auto}

  @media (max-width:520px){
    .sl{flex-wrap:wrap}
    .sl label{flex:1 0 100%}
    .sl input[type=range]{flex:1 0 100%}
    .sl .tag{margin-left:auto}
  }

  select{background:#181a20;color:#e8e8ea;border:1px solid #3a3d45;border-radius:10px;padding:.35rem .5rem;max-width:100%}

  /* Hints (stick/DAR) */
  #joyHint,#darHint{position:fixed; z-index:2; pointer-events:none;background:rgba(24,26,32,.92); border:1px solid #3a3d45; color:#cfd3dc;
    padding:.35rem .55rem; border-radius:10px; font-size:.85rem; white-space:nowrap; transform:translate(-50%,-50%); opacity:0; transition:opacity .25s ease;}
  #joyHint.show,#darHint.show{opacity:1;}

  /* XYZ gizmo frame */
  #gizmoFrame{
    position:fixed; right:.6rem; top:64px; width:84px; height:84px; z-index:2;
    border-radius:10px; border:1px solid #3a3d45; background:rgba(24,26,32,.5);
    box-shadow:0 8px 24px rgba(0,0,0,.2); pointer-events:none;
  }
</style>
</head>
<body>
  <!-- CANVASES -->
  <canvas id="gl"></canvas>
  <canvas id="hud"></canvas>
  <div id="gizmoFrame"></div>

  <!-- HAMBURGER -->
  <button id="menuBtn" type="button" title="Open Menu"><span class="bar"></span><span class="bar"></span><span class="bar"></span></button>

  <!-- FULLSCREEN TOGGLE -->
  <button id="fullscreenBtn" type="button" title="Toggle Fullscreen">â›¶</button>

  <!-- THEME TOGGLE (Sun/Moon) -->
  <button id="themeBtn" type="button" title="Toggle Day/Night Mode">ðŸŒ™</button>

  <!-- OVERLAY MENU -->
  <div id="menuOverlay">
    <div id="menuPanel">
      <div class="mp-header">
        <div class="mp-title">L4 Controls & Settings</div>
        <button class="mp-close" id="menuCloseBtn" type="button">Close</button>
      </div>
      <div class="mp-body">

        <!-- Rotation -->
        <div class="card">
          <h3>Rotation</h3>
          <div class="row">
            <button id="rollL" class="btn" type="button">Air Roll Left</button>
            <button id="rollR" class="btn active" type="button">Air Roll Right</button>
            <button id="rollFree" class="btn" type="button">Air Roll (Free)</button>
            <button id="ringMode" class="btn" type="button">Ring Mode</button>
            <button id="restart" class="btn" type="button">Restart</button>
            <button id="orbitCW" class="btn" type="button">Orbit CW</button>
            <button id="orbitCCW" class="btn" type="button">Orbit CCW</button>
          </div>

          <div class="row">
            <label>Air Roll Mode:</label>
            <button id="toggleMode" class="btn active" type="button">Toggle</button>
          </div>

          <div class="tip">
            <b>Tip:</b> With Air Roll Right, rotate the stick clockwise. With Air Roll Left, rotate the stick counter-clockwise.
          </div>
        </div>

<!-- Dynamics -->
<div class="card">
  <h3>Dynamics</h3>

  <div class="row">
    <button id="resetPhysicsDefaults" class="btn" type="button">Reset to Defaults</button>
  </div>

  <div class="row sl">
    <label for="accelPitch">Max Pitch Accel (Â°/sÂ²)</label>
    <input id="accelPitch" type="range" min="120" max="1200" step="5" value="714"/>
    <span class="tag" id="accelPitchTag">714</span>
  </div>

  <div class="row sl">
    <label for="accelYaw">Max Yaw Accel (Â°/sÂ²)</label>
    <input id="accelYaw" type="range" min="120" max="1200" step="5" value="521"/>
    <span class="tag" id="accelYawTag">521</span>
  </div>

  <div class="row sl">
    <label for="accelRoll">Max Roll Accel (Â°/sÂ²)</label>
    <input id="accelRoll" type="range" min="120" max="2400" step="5" value="2153"/>
    <span class="tag" id="accelRollTag">2153</span>
  </div>

  <div class="row sl">
    <label for="curveRange">Input Curve</label>
    <input id="curveRange" type="range" min="1.0" max="2.2" step="0.05" value="1.0"/>
    <span class="tag" id="curveTag">1.00</span>
  </div>

  <div class="row sl">
    <label for="dampRange">Damp (No-DAR)</label>
    <input id="dampRange" type="range" min="0.0" max="6.0" step="0.05" value="2.96"/>
    <span class="tag" id="dampTag">2.96</span>
  </div>

  <div class="row sl">
    <label for="dampDARRange">Damp (DAR)</label>
    <input id="dampDARRange" type="range" min="0.0" max="6.0" step="0.05" value="4.35"/>
    <span class="tag" id="dampDARTag">4.35</span>
  </div>

  <div class="row sl">
    <label for="brakeRange">Release Brake</label>
    <input id="brakeRange" type="range" min="0.0" max="6.0" step="0.1" value="0.0"/>
    <span class="tag" id="brakeTag">0.0</span>
  </div>

  <div class="row sl">
    <label for="wmaxRange">Max Ï‰ (global)</label>
    <input id="wmaxRange" type="range" min="4.0" max="24.0" step="0.1" value="5.5"/>
    <span class="tag" id="wmaxTag">5.5</span>
  </div>

  <div class="row sl">
    <label for="wmaxPitch">Max Pitch Ï‰</label>
    <input id="wmaxPitch" type="range" min="4.0" max="24.0" step="0.5" value="24.0"/>
    <span class="tag" id="wmaxPitchTag">24.0</span>
  </div>

  <div class="row sl">
    <label for="wmaxYaw">Max Yaw Ï‰</label>
    <input id="wmaxYaw" type="range" min="4.0" max="24.0" step="0.5" value="24.0"/>
    <span class="tag" id="wmaxYawTag">24.0</span>
  </div>

  <div class="row sl">
    <label for="wmaxRoll">Max Roll Ï‰</label>
    <input id="wmaxRoll" type="range" min="4.0" max="24.0" step="0.5" value="24.0"/>
    <span class="tag" id="wmaxRollTag">24.0</span>
  </div>
</div>
<!-- Car -->
<div class="card">
  <h3>Car</h3>
  <div class="row sl">
    <label for="presetSel">Body</label>
    <select id="presetSel">
      <option value="placeholder">Placeholder (140Ã—56Ã—240)</option>
      <option value="octane" selected>Octane proportions</option>
      <option value="dominus">Dominus proportions</option>
    </select>
  </div>
</div>
        <!-- View / HUD -->
        <div class="card">
          <h3>View & HUD</h3>

          <div class="row">
            <button id="arrowToggle" class="btn active" type="button">Show Arrow</button>
            <button id="circleToggle" class="btn active" type="button">Show Circle</button>
          </div>

          <div class="row sl">
            <label for="zoomSlider">Zoom</label>
            <input id="zoomSlider" type="range" min="0.20" max="4.00" step="0.01" value="1.00" />
            <span class="tag" id="zoomVal">1.00Ã—</span>
          </div>

          <div class="row sl">
            <label for="stickSizeSlider">Stick Size</label>
            <input id="stickSizeSlider" type="range" min="60" max="180" step="1" value="100" />
            <span class="tag" id="stickVal">100</span>
          </div>

          <div class="row sl">
            <label for="arrowSlider">Arrow Size</label>
            <input id="arrowSlider" type="range" min="0.60" max="4.00" step="0.01" value="4.00" />
            <span class="tag" id="arrowVal">4.00Ã—</span>
          </div>

          <div class="row sl">
            <label for="circleScale">Circle Scale</label>
            <input id="circleScale" type="range" min="0.2" max="2.0" step="0.05" value="0.3"/>
            <span class="tag" id="circleScaleTag">0.30Ã—</span>
          </div>

          <div class="row sl">
            <label for="circleTilt">Circle Tilt Angle</label>
            <input id="circleTilt" type="range" min="0" max="45" step="1" value="34"/>
            <span class="tag" id="circleTiltTag">38Â°</span>
          </div>

          <div class="row sl">
            <label for="circleTiltModifier">Circle Tilt Modifier</label>
            <input id="circleTiltModifier" type="range" min="-45" max="45" step="1" value="0"/>
            <span class="tag" id="circleTiltModifierTag">0Â°</span>
          </div>

          <div class="row sl">
            <label for="brightnessSlider">Car Brightness</label>
            <input id="brightnessSlider" type="range" min="0.5" max="3.0" step="0.1" value="1.0" />
            <span class="tag" id="brightnessVal">1.00Ã—</span>
          </div>
        </div>

        <!-- Ring Mode Settings -->
        <div class="card">
          <h3>Ring Mode</h3>

          <div class="row">
            <label for="ringDifficulty">Difficulty</label>
            <select id="ringDifficulty">
              <option value="easy">Easy</option>
              <option value="normal" selected>Normal</option>
              <option value="hard">Hard</option>
            </select>
          </div>

          <div class="row sl">
            <label for="ringCameraSpeed">Camera Transition Speed</label>
            <input id="ringCameraSpeed" type="range" min="0.01" max="0.5" step="0.01" value="0.1" />
            <span class="tag" id="ringCameraSpeedVal">0.10</span>
          </div>

          <div class="tip">
            <b>Ring Mode:</b> Navigate through rings using boost. Lower camera speed = slower, smoother transitions to next ring.
            <br><br>
            <b>Difficulty:</b><br>
            â€¢ Easy: Large rings, slower speed, simple patterns<br>
            â€¢ Normal: Balanced challenge<br>
            â€¢ Hard: Smaller rings, faster speed, complex patterns
          </div>
        </div>

        <!-- Audio Settings -->
        <div class="card">
          <h3>Audio</h3>
          <div class="row">
            <button id="toggleSounds" class="btn active" type="button">Game Sounds</button>
            <span class="tag" id="soundsStatus">Enabled</span>
          </div>
          <div class="row">
            <button id="toggleMusic" class="btn active" type="button">Background Music</button>
            <span class="tag" id="musicStatus">Enabled</span>
          </div>
          <div class="tip">
            <b>Game Sounds:</b> Ring pass/miss sounds and boost rumble<br>
            <b>Background Music:</b> 8-bit style music during Ring Mode
          </div>
        </div>

        <!-- Gamepad -->
        <div class="card">
          <h3>Gamepad</h3>
          <div class="row">
            <button id="gpEnable" class="btn active" type="button">Enable</button>
            <span class="tag" id="gpStatus">Enabled (waiting for gamepad)</span>
          </div>
          <div class="row sl">
            <label for="gpPreset">Preset</label>
            <select id="gpPreset">
              <option value="ps5" selected>PS5 / DualSense</option>
              <option value="xinput">Generic XInput</option>
            </select>
          </div>
          <div class="row">
            <button id="gpRemap" class="btn" type="button">Remap Actionâ€¦</button>
            <select id="gpAction" aria-label="Select action to remap">
              <option value="toggleDAR">Toggle DAR</option>
              <option value="rollLeft">Air Roll Left</option>
              <option value="rollRight">Air Roll Right</option>
              <option value="rollFree">Air Roll (Free)</option>
              <option value="boost">Boost (Ring Mode)</option>
              <option value="pause">Pause (Ring Mode)</option>
              <option value="restart">Restart</option>
              <option value="orbitCW">Orbit Clockwise</option>
              <option value="orbitCCW">Orbit Counter-Clockwise</option>
              <option value="toggleTheme">Toggle Day/Night Mode</option>
              <option value="openMenu">Open/Close Menu</option>
            </select>
            <span class="tag" id="gpBindLabel">â€”</span>
          </div>
          <div class="row">
            <button id="gpResetDefaults" class="btn" type="button">Reset to Defaults</button>
          </div>
          <div class="tip">
            <b>Tip:</b> Left stick moves the on-screen stick. Remap any action, then press a button or push an axis to bind.
          </div>
        </div>

      </div>
    </div>
  </div>

  <!-- Hints -->
  <div id="joyHint">Hold outside the stick to reposition (UI hidden)</div>
  <div id="darHint">Tap to toggle roll â€¢ Hold to move</div>

<script type="module">
// Version: 2025-11-29-v2 (localStorage persistence fix)
import * as THREE from "three";

// Import modular components
import * as CONST from './js/modules/constants.js';
import * as Audio from './js/modules/audio.js';
import * as Settings from './js/modules/settings.js';
import * as Car from './js/modules/car.js';
import * as Rendering from './js/modules/rendering.js';
import * as Input from './js/modules/input.js';
import * as RingMode from './js/modules/ringMode.js';

/* ====== Renderer / Scene / Camera ====== */
const gl = document.getElementById('gl');
const hud = document.getElementById('hud');
const renderer = new THREE.WebGLRenderer({canvas: gl, antialias: true});
renderer.setPixelRatio(Math.min(devicePixelRatio, 2));
renderer.setSize(innerWidth, innerHeight);

// Device detection managed by Input module
console.log('Device type:', Input.getIsMobile() ? 'Mobile/Tablet' : 'Desktop');

const scene = new THREE.Scene();
scene.fog = new THREE.Fog(0xeef1f6, 900, 2200);

const camera = new THREE.PerspectiveCamera(55, innerWidth/innerHeight, 0.1, 5000);
camera.position.set(0, CONST.CAM_BASE.y, CONST.CAM_BASE.z);
scene.add(camera);

/* Lights */
const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
scene.add(ambientLight);
const directionalLight = new THREE.DirectionalLight(0xffffff, 1.15);
directionalLight.position.set(-350, 700, 900);
directionalLight.castShadow = false;
scene.add(directionalLight);

/* Grid - expanded to look infinite */
const grid = new THREE.Group();
const gridMain = new THREE.GridHelper(10000, 100, 0xd7dde6, 0xE5E9F1); // 10x larger, more divisions
gridMain.material.opacity = 0.65;
gridMain.material.transparent = true;
gridMain.material.depthWrite = false; // Prevent z-fighting
grid.add(gridMain);
grid.rotation.x = -Math.PI/2;
grid.position.y = -160;
scene.add(grid);

/* Theme configuration */
let isDarkMode; // Will be initialized from localStorage
const THEMES = {
  dark: {
    body: '#000000',
    fog: 0x000000,
    fogNear: 1000,
    fogFar: 2500,
    ambient: 0xffffff,
    ambientIntensity: 1.5,
    directional: 0xffffff,
    directionalIntensity: 1.2,
    gridMain: 0x4a5060,
    gridSub: 0x353945,
    gridOpacity: 0.7,
    gridY: -160
  },
  light: {
    body: '#ffffff',
    fog: 0xeef1f6,
    fogNear: 900,
    fogFar: 2200,
    ambient: 0xffffff,
    ambientIntensity: 0.8,
    directional: 0xffffff,
    directionalIntensity: 1.15,
    gridMain: 0x8a95a5,
    gridSub: 0xb5bec8,
    gridOpacity: 0.85,
    gridY: -160
  }
};

function applyTheme(dark) {
  const theme = dark ? THEMES.dark : THEMES.light;

  // Update body background
  document.body.style.background = dark
    ? '#000000'
    : 'linear-gradient(180deg,#f6f7fb 0%,#eef1f6 45%,#e9edf3 100%)';

  // Update fog
  scene.fog.color.setHex(theme.fog);
  scene.fog.near = theme.fogNear;
  scene.fog.far = theme.fogFar;

  // Update lights with brightness multiplier
  const brightness = dark ? brightnessDark : brightnessLight;
  ambientLight.intensity = theme.ambientIntensity * brightness;
  directionalLight.intensity = theme.directionalIntensity * brightness;

  // Update grid
  gridMain.material.color.setHex(theme.gridMain);
  gridMain.material.opacity = theme.gridOpacity;

  // Update renderer background
  renderer.setClearColor(theme.fog);

  // Update car materials for better visibility in day mode
  Car.updateCarTheme(dark);
}

/* HUD utils */
Rendering.initHUD(hud);

// Input module will be initialized after all necessary functions are defined
const COLS = {UP:'#ff5c5c', RIGHT:'#4c8dff', DOWN:'#53d769', LEFT:'#ffd166'};

/* Touch controls, DAR button, Boost button, and Hints - all managed by Input module */

/* MENU open/close */
const menuBtn=document.getElementById('menuBtn');
const menuOverlay=document.getElementById('menuOverlay');
const menuCloseBtn=document.getElementById('menuCloseBtn');
let chromeShown=false;

// Collapsible cards initialization
let cardsInitialized = false;
function initCollapsibleCards() {
  // Only initialize once to avoid duplicate event listeners
  if (cardsInitialized) return;
  cardsInitialized = true;

  const cards = document.querySelectorAll('.card');
  cards.forEach((card, index) => {
    const h3 = card.querySelector('h3');
    if (!h3) return;

    // Wrap all content after h3 in a card-content div
    if (!card.querySelector('.card-content')) {
      const content = document.createElement('div');
      content.className = 'card-content';

      // Move all children after h3 into content div
      const children = Array.from(card.children);
      children.forEach(child => {
        if (child !== h3) {
          content.appendChild(child);
        }
      });
      card.appendChild(content);

      // Collapse all cards except the first one (Rotation)
      const isRotationCard = h3.textContent.trim() === 'Rotation';
      if (!isRotationCard) {
        card.classList.add('collapsed');
        content.style.maxHeight = '0';
      } else {
        content.style.maxHeight = content.scrollHeight + 'px';
      }
    }

    // Add click handler to h3
    h3.addEventListener('click', (e) => {
      e.stopPropagation();
      const content = card.querySelector('.card-content');
      const isCollapsed = card.classList.contains('collapsed');

      if (isCollapsed) {
        card.classList.remove('collapsed');
        content.style.maxHeight = content.scrollHeight + 'px';
      } else {
        card.classList.add('collapsed');
        content.style.maxHeight = '0';
      }
    });
  });
}

function openMenu(){
  chromeShown=true;
  menuBtn.classList.add('active');
  menuOverlay.style.display='block';

  // Initialize collapsible cards on first open
  initCollapsibleCards();

  // Initialize Input module menu navigation after DOM is visible
  setTimeout(() => {
    Input.setChromeShown(true);
  }, 10);
}
function closeMenu(){
  chromeShown=false;
  Input.setChromeShown(false);
  menuBtn.classList.remove('active');
  menuOverlay.style.display='none';
}
menuBtn.addEventListener('click',()=> chromeShown ? closeMenu() : openMenu());
menuCloseBtn.addEventListener('click', closeMenu);
menuOverlay.addEventListener('click',(e)=>{ if(e.target===menuOverlay) closeMenu(); });

/* Sliders / select */
const accelPitch=document.getElementById('accelPitch'), accelPitchTag=document.getElementById('accelPitchTag');
const accelYaw=document.getElementById('accelYaw'), accelYawTag=document.getElementById('accelYawTag');
const accelRoll=document.getElementById('accelRoll'), accelRollTag=document.getElementById('accelRollTag');
const curveRange=document.getElementById('curveRange'), curveTag=document.getElementById('curveTag');
const dampRange=document.getElementById('dampRange'),   dampTag=document.getElementById('dampTag');
const dampDARRange=document.getElementById('dampDARRange'), dampDARTag=document.getElementById('dampDARTag');
const brakeRange=document.getElementById('brakeRange'), brakeTag=document.getElementById('brakeTag');
const wmaxRange=document.getElementById('wmaxRange'),   wmaxTag=document.getElementById('wmaxTag');
const wmaxPitchRange=document.getElementById('wmaxPitch'), wmaxPitchTag=document.getElementById('wmaxPitchTag');
const wmaxYawRange=document.getElementById('wmaxYaw'), wmaxYawTag=document.getElementById('wmaxYawTag');
const wmaxRollRange=document.getElementById('wmaxRoll'), wmaxRollTag=document.getElementById('wmaxRollTag');
const circleTiltRange=document.getElementById('circleTilt'), circleTiltTag=document.getElementById('circleTiltTag');
const circleTiltModifierRange=document.getElementById('circleTiltModifier'), circleTiltModifierTag=document.getElementById('circleTiltModifierTag');
const circleScaleRange=document.getElementById('circleScale'), circleScaleTag=document.getElementById('circleScaleTag');
const sizeSlider=document.getElementById('stickSizeSlider'), stickVal=document.getElementById('stickVal');
const zoomSlider=document.getElementById('zoomSlider'), zoomVal=document.getElementById('zoomVal');
const arrowSlider=document.getElementById('arrowSlider'), arrowVal=document.getElementById('arrowVal');
const brightnessSlider=document.getElementById('brightnessSlider'), brightnessVal=document.getElementById('brightnessVal');
const presetSel=document.getElementById('presetSel');

// Load settings from Settings module
const savedSettings = Settings.loadSettings();

// Gamepad bindings managed by Input module

// Restore theme mode (default to true = dark mode)
isDarkMode = savedSettings.isDarkMode ?? true;

let maxAccelPitch=savedSettings.maxAccelPitch ?? parseFloat(accelPitch.value),
    maxAccelYaw=savedSettings.maxAccelYaw ?? parseFloat(accelYaw.value),
    maxAccelRoll=savedSettings.maxAccelRoll ?? parseFloat(accelRoll.value),
    inputPow=savedSettings.inputPow ?? parseFloat(curveRange.value),
    damp=savedSettings.damp ?? parseFloat(dampRange.value),
    dampDAR=savedSettings.dampDAR ?? parseFloat(dampDARRange.value),
    brakeOnRelease=savedSettings.brakeOnRelease ?? parseFloat(brakeRange.value),
    wMax=savedSettings.wMax ?? parseFloat(wmaxRange.value),
    wMaxPitch=savedSettings.wMaxPitch ?? parseFloat(wmaxPitchRange.value),
    wMaxYaw=savedSettings.wMaxYaw ?? parseFloat(wmaxYawRange.value),
    wMaxRoll=savedSettings.wMaxRoll ?? parseFloat(wmaxRollRange.value),
    circleTiltAngle=savedSettings.circleTiltAngle ?? parseFloat(circleTiltRange.value),
    circleTiltModifier=savedSettings.circleTiltModifier ?? parseFloat(circleTiltModifierRange.value),
    circleScale=savedSettings.circleScale ?? parseFloat(circleScaleRange.value),
    zoom=savedSettings.zoom ?? parseFloat(zoomSlider.value),
    arrowScale=savedSettings.arrowScale ?? parseFloat(arrowSlider.value);

// Brightness settings (separate for dark and light modes)
let brightnessDark = savedSettings.brightnessDark ?? 1.0;
let brightnessLight = savedSettings.brightnessLight ?? 1.0;

// Audio settings
let gameSoundsEnabled = savedSettings.gameSoundsEnabled ?? true;
let gameMusicEnabled = savedSettings.gameMusicEnabled ?? true;

// Sync audio settings with Audio module
Audio.setGameSoundsEnabled(gameSoundsEnabled);
Audio.setGameMusicEnabled(gameMusicEnabled);

// Wrapper function to save settings to Settings module
function saveSettings() {
  // Collect current settings
  // Note: Input-related settings (airRoll, gpEnabled, etc.) are saved by Input module automatically
  const currentSettings = {
    maxAccelPitch, maxAccelYaw, maxAccelRoll,
    inputPow, damp, dampDAR, brakeOnRelease,
    wMax, wMaxPitch, wMaxYaw, wMaxRoll,
    circleTiltAngle, circleTiltModifier, circleScale,
    zoom, arrowScale,
    isDarkMode,
    brightnessDark, brightnessLight,
    showArrow, showCircle,
    ringModeHighScore: RingMode.getRingModeHighScore(),
    ringDifficulty: RingMode.getCurrentDifficulty(),
    gameSoundsEnabled,
    gameMusicEnabled
  };

  // Add optional settings if elements exist
  const gpPresetEl = document.getElementById('gpPreset');
  if (gpPresetEl) {
    currentSettings.gpPreset = gpPresetEl.value;
  }

  const presetSelEl = document.getElementById('presetSel');
  if (presetSelEl) {
    currentSettings.selectedCarBody = presetSelEl.value;
  }

  // Save to Settings module
  Settings.saveSettings(currentSettings);
}

// Apply loaded values to sliders
accelPitch.value = maxAccelPitch;
accelYaw.value = maxAccelYaw;
accelRoll.value = maxAccelRoll;
curveRange.value = inputPow;
dampRange.value = damp;
dampDARRange.value = dampDAR;
brakeRange.value = brakeOnRelease;
wmaxRange.value = wMax;
wmaxPitchRange.value = wMaxPitch;
wmaxYawRange.value = wMaxYaw;
wmaxRollRange.value = wMaxRoll;
circleTiltRange.value = circleTiltAngle;
circleTiltModifierRange.value = circleTiltModifier;
circleScaleRange.value = circleScale;
zoomSlider.value = zoom;
arrowSlider.value = arrowScale;

/* Air Roll System - managed by Input module */

// Helper function to update menu button styling based on Input module state
function updateMenuButtonStyling(){
  const lastActive = Input.getLastActiveAirRoll();
  document.getElementById('rollL').classList.toggle('active', lastActive === -1);
  document.getElementById('rollR').classList.toggle('active', lastActive === 1);
  document.getElementById('rollFree').classList.toggle('active', lastActive === 2);
}

// Menu button click handlers - delegate to Input module
document.getElementById('rollL').addEventListener('click', () => {
  Input.selectAirRoll(-1);
  updateMenuButtonStyling();
});
document.getElementById('rollR').addEventListener('click', () => {
  Input.selectAirRoll(1);
  updateMenuButtonStyling();
});
document.getElementById('rollFree').addEventListener('click', () => {
  Input.selectAirRoll(2);
  updateMenuButtonStyling();
});

// Reset Physics to Defaults button
document.getElementById('resetPhysicsDefaults').addEventListener('click', () => {
  Settings.clearAllSettings();
  location.reload();
});

// Toggle/Hold mode button
document.getElementById('toggleMode').addEventListener('click', () => {
  const newMode = !Input.getAirRollIsToggle();
  Input.setAirRollIsToggle(newMode);
  const btn = document.getElementById('toggleMode');
  btn.classList.toggle('active', newMode);
  btn.textContent = newMode ? 'Toggle' : 'Hold';
});

/* Ring Mode */
/*
 * ===== COORDINATE SYSTEM GUIDE - READ THIS BEFORE ROTATING ANYTHING =====
 *
 * THREE.JS WORLD COORDINATES (Standard Right-Handed System):
 * - X axis: LEFT (-) to RIGHT (+) across the screen
 * - Y axis: DOWN (-) to UP (+) on the screen
 * - Z axis: AWAY from camera (-) to TOWARD camera (+) - THIS IS DEPTH
 *
 * CAMERA SETUP:
 * - Camera positioned at positive Z looking toward origin (0,0,0)
 * - From camera's view: +X = right, +Y = up, +Z = toward you, -Z = into screen
 *
 * ===== CRITICAL: UNDERSTANDING ROTATIONS IN THREE.JS =====
 *
 * When you call car.rotation.set(x, y, z), you are setting EULER ANGLES.
 * Three.js applies rotations in XYZ ORDER (this matters!):
 *   1. First: Rotate around X axis
 *   2. Second: Rotate around Y axis (which has now moved due to X rotation)
 *   3. Third: Rotate around Z axis (which has now moved due to X and Y rotations)
 *
 * VISUAL GUIDE - ROTATING FROM USER'S PERSPECTIVE:
 *   - X rotation: Pitch (nose up/down like nodding "yes")
 *   - Y rotation: Yaw (turning left/right like shaking head "no") - THIS IS DEPTH AXIS ROTATION
 *   - Z rotation: Roll (barrel roll, tilting left/right) - THIS IS UP/DOWN AXIS ROTATION
 *
 * IMPORTANT: The Y axis is the DEPTH axis (toward/away from camera)
 *            The Z axis is the UP/DOWN axis (vertical on screen)
 *            Rotating around Y = spinning on the depth axis
 *            Rotating around Z = spinning on the vertical axis
 *
 * ===== CAR MODEL DEFAULT ORIENTATION (at quaternion.identity, NO rotations) =====
 *
 * Default car orientation when spawned with NO rotation applied:
 * - Wheels/Bottom:  Facing UP (+Y, toward top of screen)
 * - Roof:           Facing DOWN (-Y, toward bottom of screen)
 * - Nose/Front:     Facing LEFT (-X, left side of screen)
 * - Rear/Back:      Facing RIGHT (+X, right side of screen)
 * - Right side:     Facing CAMERA (+Z, toward you)
 * - Left side:      Facing AWAY (-Z, away from you into screen)
 *
 * ===== DESIRED ORIENTATION FOR DAR TRAINING =====
 *
 * What we want to achieve:
 * - Roof:           Facing CAMERA (+Z, toward user)
 * - Wheels/Bottom:  Facing AWAY (-Z, into screen depth)
 * - Nose/Front:     Facing UP (+Y, top of screen)
 * - Rear/Back:      Facing DOWN (-Y, bottom of screen)
 * - Right side:     Facing RIGHT (+X)
 * - Left side:      Facing LEFT (-X)
 *
 * ===== FINAL WORKING ROTATION =====
 *
 * car.rotation.set(Math.PI * 1.5, 0, Math.PI)
 * Breaking it down:
 *   - X: +270Â° (Math.PI * 1.5) - Pitches nose UP, this gets us nose pointing up
 *   - Y: 0Â° - No depth rotation needed
 *   - Z: +180Â° (Math.PI) - Barrel roll to flip roof toward camera
 *
 * WHY THIS WORKS:
 * 1. Start: Car at identity (roof down, nose left, right-side toward camera)
 * 2. X rotation +270Â°: Pitches the car so nose points up (like tilting forward 3/4 turn)
 * 3. Z rotation +180Â°: Barrel rolls the car to flip roof toward camera
 *
 * ===== CAR MODEL LOCAL SPACE (GLB file internal axes) =====
 *
 * The GLB model has its own coordinate system baked in:
 * - Model +Z local: Points toward nose/front of car
 * - Model +X local: Points toward right side of car
 * - Model +Y local: Points toward roof of car
 *
 * Different car models may be exported with different default orientations:
 * - Dominus GLB: rotation.y = 0 (nose already points in correct direction)
 * - Octane GLB: rotation.y = -Math.PI/2 (-90Â°) needed to align nose correctly
 *
 * ===== ROTATION TESTING HISTORY (for reference) =====
 *
 * Attempts that DIDN'T work:
 * - (0, 0, Math.PI): Nose facing camera instead of up
 * - (Math.PI, 0, 0): Roof down, nose away from screen
 * - (Math.PI, -Math.PI/2, 0): Roof down, nose left
 * - (Math.PI/2, 0, Math.PI/2): Nose DOWN, rear UP, roof LEFT
 * - (0, -Math.PI/2, -Math.PI/2): Roof correct, but nose LEFT instead of UP
 * - (Math.PI/2, 0, -Math.PI/2): Various incorrect orientations
 * - (Math.PI, 0, -Math.PI/2): Still incorrect
 *
 * What WORKED: (Math.PI * 1.5, 0, Math.PI) - Nose UP confirmed, roof toward camera
 *
 * ===== RING MODE PHYSICS =====
 *
 * - Car is locked at world origin (0, 0, 0) - never moves in 3D space
 * - Visual movement simulated by translating car on 2D plane using ringModePosition
 * - Movement occurs in X-Y plane (left/right and up/down on screen)
 * - Rings spawn at negative Z (far from camera) and move toward positive Z (toward camera)
 * - This creates the illusion that the car is flying through depth
 *
 * ===== REMEMBER THIS TO AVOID CONFUSION =====
 *
 * If you need to rotate the car in the future:
 * 1. Y axis rotation = spinning around the DEPTH axis (toward/away from camera)
 * 2. Z axis rotation = spinning around the UP/DOWN axis (vertical on screen)
 * 3. X axis rotation = pitching nose up/down
 * 4. Rotations are applied in X-Y-Z order, so later rotations operate on moved axes
 * 5. Test one axis at a time in 90Â° increments to understand the effect
 * 6. The current working rotation is: car.rotation.set(Math.PI * 1.5, 0, Math.PI)
 *
 */

document.getElementById('ringMode').addEventListener('click', () => {
  const active = RingMode.toggleRingMode();
  const btn = document.getElementById('ringMode');
  btn.classList.toggle('active', active);
});

const ringCameraSpeedSlider = document.getElementById('ringCameraSpeed');
const ringCameraSpeedVal = document.getElementById('ringCameraSpeedVal');
ringCameraSpeedSlider.addEventListener('input', () => {
  const speed = parseFloat(ringCameraSpeedSlider.value);
  RingMode.setRingCameraSpeed(speed);
  ringCameraSpeedVal.textContent = speed.toFixed(2);
});

// Ring Mode difficulty selector
const ringDifficultySelector = document.getElementById('ringDifficulty');
ringDifficultySelector.addEventListener('change', () => {
  const difficulty = ringDifficultySelector.value;
  RingMode.setCurrentDifficulty(difficulty);
  saveSettings();
  console.log('Ring Mode difficulty changed to:', difficulty);

  // If Ring Mode is active, restart it with new difficulty
  if (RingMode.getRingModeActive()) {
    RingMode.resetRingMode();
  }
});

// Audio toggles
const toggleSoundsBtn = document.getElementById('toggleSounds');
const soundsStatusTag = document.getElementById('soundsStatus');
const toggleMusicBtn = document.getElementById('toggleMusic');
const musicStatusTag = document.getElementById('musicStatus');

// Set initial button states
toggleSoundsBtn.classList.toggle('active', gameSoundsEnabled);
soundsStatusTag.textContent = gameSoundsEnabled ? 'Enabled' : 'Disabled';
toggleMusicBtn.classList.toggle('active', gameMusicEnabled);
musicStatusTag.textContent = gameMusicEnabled ? 'Enabled' : 'Disabled';

toggleSoundsBtn.addEventListener('click', () => {
  gameSoundsEnabled = !gameSoundsEnabled;
  toggleSoundsBtn.classList.toggle('active', gameSoundsEnabled);
  soundsStatusTag.textContent = gameSoundsEnabled ? 'Enabled' : 'Disabled';

  // Update Audio module settings
  Audio.setGameSoundsEnabled(gameSoundsEnabled);

  saveSettings();
});

toggleMusicBtn.addEventListener('click', () => {
  gameMusicEnabled = !gameMusicEnabled;
  toggleMusicBtn.classList.toggle('active', gameMusicEnabled);
  musicStatusTag.textContent = gameMusicEnabled ? 'Enabled' : 'Disabled';

  // Update Audio module settings
  Audio.setGameMusicEnabled(gameMusicEnabled);

  // Start music if enabled and Ring Mode is active
  if (gameMusicEnabled && RingMode.getRingModeActive() && RingMode.getRingModeStarted()) {
    Audio.startBackgroundMusic();
  }

  saveSettings();
});

document.getElementById('restart').addEventListener('click',()=>{
  if (Car.car) {
    Car.car.quaternion.identity();
    Car.car.rotation.set(Math.PI * 1.5, 0, Math.PI); // X: +270Â°, Y: 0Â°, Z: +180Â°
  }
  w.set(0,0,0);
  orbitOn = false;
  orbitDir = 1;
  document.getElementById('orbitCW').classList.remove('active');
  document.getElementById('orbitCCW').classList.remove('active');
  orbitPhase = 0;
  camera.position.set(0, 220, 650);
  camera.lookAt(0,0,0);
  if (Car.faceArrow) Car.faceArrow.visible = false;
  if (Car.faceTip)   Car.faceTip.visible   = false;

  // Reset Ring Mode if active
  if(RingMode.getRingModeActive()){
    RingMode.resetRingMode();
  }
});
let orbitOn=false, orbitDir=1;
document.getElementById('orbitCW').addEventListener('click',()=>{
  const btn = document.getElementById('orbitCW');
  if (orbitOn && orbitDir === 1) {
    // Turn off if already orbiting CW
    orbitOn = false;
    btn.classList.remove('active');
  } else {
    // Turn on CW orbit
    orbitOn = true;
    orbitDir = 1;
    btn.classList.add('active');
    document.getElementById('orbitCCW').classList.remove('active');
  }
});
document.getElementById('orbitCCW').addEventListener('click',()=>{
  const btn = document.getElementById('orbitCCW');
  if (orbitOn && orbitDir === -1) {
    // Turn off if already orbiting CCW
    orbitOn = false;
    btn.classList.remove('active');
  } else {
    // Turn on CCW orbit
    orbitOn = true;
    orbitDir = -1;
    btn.classList.add('active');
    document.getElementById('orbitCW').classList.remove('active');
  }
});

/* Theme toggle (main screen button) */
document.getElementById('themeBtn').addEventListener('click',()=>{
  isDarkMode = !isDarkMode;
  applyTheme(isDarkMode);
  const btn = document.getElementById('themeBtn');
  btn.textContent = isDarkMode ? 'ðŸŒ™' : 'â˜€ï¸';
  syncTags(); // Update brightness slider to show correct value for new theme
  saveSettings();
});

// Fullscreen toggle
document.getElementById('fullscreenBtn').addEventListener('click', () => {
  if (!document.fullscreenElement) {
    // Enter fullscreen
    document.documentElement.requestFullscreen().catch(err => {
      console.log(`Error attempting to enable fullscreen: ${err.message}`);
    });
  } else {
    // Exit fullscreen
    if (document.exitFullscreen) {
      document.exitFullscreen();
    }
  }
});

// Update fullscreen button icon when fullscreen state changes
document.addEventListener('fullscreenchange', () => {
  const btn = document.getElementById('fullscreenBtn');
  if (document.fullscreenElement) {
    btn.textContent = 'â›¶'; // Fullscreen exit icon
    btn.title = 'Exit Fullscreen';
  } else {
    btn.textContent = 'â›¶'; // Fullscreen enter icon
    btn.title = 'Enter Fullscreen';
  }
});

// Stop music when page loses focus (tab switching, app backgrounding)
document.addEventListener('visibilitychange', () => {
  if (document.hidden) {
    // Page is hidden - stop all audio
    Audio.stopBackgroundMusic();
    Audio.stopBoostRumble();
  } else {
    // Page is visible again - restart music if Ring Mode is active
    if (RingMode.getRingModeActive() && RingMode.getRingModeStarted() && gameMusicEnabled) {
      Audio.startBackgroundMusic();
    }
  }
});

/* Arrow and Circle toggles */
let showArrow = savedSettings.showArrow ?? true;
let showCircle = savedSettings.showCircle ?? true;

document.getElementById('arrowToggle').addEventListener('click',()=>{
  showArrow = !showArrow;
  const btn = document.getElementById('arrowToggle');
  btn.classList.toggle('active', showArrow);
  btn.textContent = showArrow ? 'Show Arrow' : 'Hide Arrow';
  saveSettings();
});

document.getElementById('circleToggle').addEventListener('click',()=>{
  showCircle = !showCircle;
  const btn = document.getElementById('circleToggle');
  btn.classList.toggle('active', showCircle);
  btn.textContent = showCircle ? 'Show Circle' : 'Hide Circle';
  saveSettings();
});

function syncTags(){
  accelPitchTag.textContent=maxAccelPitch.toFixed(0);
accelYawTag.textContent=maxAccelYaw.toFixed(0);
accelRollTag.textContent=maxAccelRoll.toFixed(0);
  curveTag.textContent=inputPow.toFixed(2);
  dampTag.textContent=damp.toFixed(2);
  brakeTag.textContent=brakeOnRelease.toFixed(1);
  wmaxTag.textContent=wMax.toFixed(1);
  wmaxPitchTag.textContent=wMaxPitch.toFixed(1);
  wmaxYawTag.textContent=wMaxYaw.toFixed(1);
  wmaxRollTag.textContent=wMaxRoll.toFixed(1);
  circleTiltTag.textContent=`${circleTiltAngle.toFixed(0)}Â°`;
  circleTiltModifierTag.textContent=`${circleTiltModifier.toFixed(0)}Â°`;
  circleScaleTag.textContent=`${circleScale.toFixed(2)}Ã—`;
  stickVal.textContent = String(Math.round(Input.getJoyBaseR()));
  zoomVal.textContent = `${(zoom||1).toFixed(2)}Ã—`;
  arrowVal.textContent = `${(arrowScale||1).toFixed(2)}Ã—`;
  const currentBrightness = isDarkMode ? brightnessDark : brightnessLight;
  brightnessVal.textContent = `${currentBrightness.toFixed(2)}Ã—`;
  brightnessSlider.value = currentBrightness;
}
syncTags();

// Make all tag elements editable
function setupEditableTags() {
  const tagMappings = [
    {tag: accelPitchTag, slider: accelPitch, setter: (v) => maxAccelPitch = Math.max(0, Math.min(1200, parseFloat(v) || 400))},
    {tag: accelYawTag, slider: accelYaw, setter: (v) => maxAccelYaw = Math.max(0, Math.min(1200, parseFloat(v) || 400))},
    {tag: accelRollTag, slider: accelRoll, setter: (v) => maxAccelRoll = Math.max(0, Math.min(1200, parseFloat(v) || 400))},
    {tag: curveTag, slider: curveRange, setter: (v) => inputPow = Math.max(1, Math.min(4, parseFloat(v) || 1.0))},
    {tag: dampTag, slider: dampRange, setter: (v) => damp = Math.max(0, Math.min(6, parseFloat(v) || 2.96))},
    {tag: dampDARTag, slider: dampDARRange, setter: (v) => dampDAR = Math.max(0, Math.min(6, parseFloat(v) || 4.35))},
    {tag: brakeTag, slider: brakeRange, setter: (v) => brakeOnRelease = Math.max(0, Math.min(6, parseFloat(v) || 0))},
    {tag: wmaxTag, slider: wmaxRange, setter: (v) => wMax = Math.max(6, Math.min(24, parseFloat(v) || 6))},
    {tag: wmaxPitchTag, slider: wmaxPitchRange, setter: (v) => wMaxPitch = Math.max(6, Math.min(24, parseFloat(v) || 8.5))},
    {tag: wmaxYawTag, slider: wmaxYawRange, setter: (v) => wMaxYaw = Math.max(6, Math.min(24, parseFloat(v) || 9))},
    {tag: wmaxRollTag, slider: wmaxRollRange, setter: (v) => wMaxRoll = Math.max(4, Math.min(24, parseFloat(v) || 6))},
    {tag: circleTiltTag, slider: circleTiltRange, setter: (v) => circleTiltAngle = Math.max(0, Math.min(45, parseFloat(v) || 34))},
    {tag: circleTiltModifierTag, slider: circleTiltModifierRange, setter: (v) => circleTiltModifier = Math.max(-45, Math.min(45, parseFloat(v) || 0))},
    {tag: circleScaleTag, slider: circleScaleRange, setter: (v) => circleScale = Math.max(0.2, Math.min(2.0, parseFloat(v) || 0.3))},
    {tag: zoomVal, slider: zoomSlider, setter: (v) => { zoom = Math.max(0.2, Math.min(4.0, parseFloat(v) || 1)); applyZoom(); }},
    {tag: arrowVal, slider: arrowSlider, setter: (v) => arrowScale = Math.max(0.6, Math.min(4, parseFloat(v) || 4))},
    {tag: brightnessVal, slider: brightnessSlider, setter: (v) => {
      const val = Math.max(0.5, Math.min(3, parseFloat(v) || 1));
      if (isDarkMode) brightnessDark = val; else brightnessLight = val;
      applyTheme(isDarkMode);
    }}
  ];

  tagMappings.forEach(mapping => {
    mapping.tag.contentEditable = true;
    mapping.tag.style.cursor = 'text';

    mapping.tag.addEventListener('click', (e) => {
      e.target.select?.() || document.execCommand('selectAll', false, null);
    });

    mapping.tag.addEventListener('keydown', (e) => {
      if (e.key === 'Enter') {
        e.preventDefault();
        e.target.blur();
      }
    });

    mapping.tag.addEventListener('blur', (e) => {
      const rawValue = e.target.textContent.replace(/[^\d.-]/g, '');
      mapping.setter(rawValue);
      mapping.slider.value = parseFloat(rawValue) || 0;
      syncTags();
      saveSettings();
    });
  });
}
setupEditableTags();

accelPitch.addEventListener('input',()=>{maxAccelPitch=parseFloat(accelPitch.value)||400; syncTags(); saveSettings();});
accelYaw.addEventListener('input',()=>{maxAccelYaw=parseFloat(accelYaw.value)||400; syncTags(); saveSettings();});
accelRoll.addEventListener('input',()=>{maxAccelRoll=parseFloat(accelRoll.value)||400; syncTags(); saveSettings();});
curveRange.addEventListener('input',()=>{inputPow=parseFloat(curveRange.value)||1.0; syncTags(); saveSettings();});
dampRange .addEventListener('input',()=>{damp=parseFloat(dampRange.value)||2.96; syncTags(); saveSettings();});
dampDARRange .addEventListener('input',()=>{dampDAR=parseFloat(dampDARRange.value)||4.35; syncTags(); saveSettings();});
brakeRange.addEventListener('input',()=>{brakeOnRelease=parseFloat(brakeRange.value)||0.0; syncTags(); saveSettings();});
wmaxRange .addEventListener('input',()=>{wMax=parseFloat(wmaxRange.value)||6.0; syncTags(); saveSettings();});
wmaxPitchRange.addEventListener('input',()=>{wMaxPitch=parseFloat(wmaxPitchRange.value)||8.5; syncTags(); saveSettings();});
wmaxYawRange.addEventListener('input',()=>{wMaxYaw=parseFloat(wmaxYawRange.value)||9.0; syncTags(); saveSettings();});
wmaxRollRange.addEventListener('input',()=>{wMaxRoll=parseFloat(wmaxRollRange.value)||6.0; syncTags(); saveSettings();});
circleTiltRange.addEventListener('input',()=>{circleTiltAngle=parseFloat(circleTiltRange.value)||38; syncTags(); saveSettings();});
circleTiltModifierRange.addEventListener('input',()=>{circleTiltModifier=parseFloat(circleTiltModifierRange.value)||0; syncTags(); saveSettings();});
circleScaleRange.addEventListener('input',()=>{circleScale=parseFloat(circleScaleRange.value)||0.3; syncTags(); saveSettings();});
sizeSlider.addEventListener('input',()=>{Input.getJoyBaseR()=parseInt(stickSizeSlider.value,10)||100; Input.getJoyKnobR()=Math.round(Input.getJoyBaseR()*0.32); clampJoyCenter(); positionHints(); syncTags();});
zoomSlider.addEventListener('input',()=>{zoom=parseFloat(zoomSlider.value)||1.0; applyZoom(); syncTags(); saveSettings();});
arrowSlider.addEventListener('input',()=>{arrowScale=parseFloat(arrowSlider.value)||4.0; syncTags(); saveSettings();});
brightnessSlider.addEventListener('input',()=>{
  const val = parseFloat(brightnessSlider.value) || 1.0;
  if (isDarkMode) {
    brightnessDark = val;
  } else {
    brightnessLight = val;
  }
  applyTheme(isDarkMode);
  syncTags();
  saveSettings();
});
presetSel .addEventListener('change',()=>{
  const name = presetSel.value;
  Car.buildCar(CONST.CAR_PRESETS[name], name, scene);
  Car.car.quaternion.identity();
  Car.car.rotation.set(Math.PI * 1.5, 0, Math.PI); // X: +270Â°, Y: 0Â°, Z: +180Â°
  w.set(0,0,0);
  saveSettings(); // Save selected car body
});


/* Physics (independent caps for Pitch/Yaw) */
let w = new THREE.Vector3(0,0,0);
const STICK_DEADZONE = 0.02; // Local deadzone constant
const KP_ROLL = 3.2, KD_ROLL = 0.25;

// === NEW VARIABLES - Add these here ===
let inputHistory = { x: [], y: [] };
const INPUT_HISTORY_SIZE = 3;
let prevAlpha = new THREE.Vector3(0, 0, 0);

// === HELPER FUNCTIONS ===
function smoothInput(jx, jy) {
  inputHistory.x.push(jx);
  inputHistory.y.push(jy);
  if (inputHistory.x.length > INPUT_HISTORY_SIZE) {
    inputHistory.x.shift();
    inputHistory.y.shift();
  }
  
  const avgX = inputHistory.x.reduce((a, b) => a + b, 0) / inputHistory.x.length;
  const avgY = inputHistory.y.reduce((a, b) => a + b, 0) / inputHistory.y.length;
  return { x: avgX, y: avgY };
}

function softClampAngularVelocity(w, max) {
  const mag = w.length();
  if (mag <= max) return;
  
  const excess = mag - max;
  const reduction = Math.min(1.0, excess / max);
  const scale = 1.0 - (reduction * 0.3);
  w.multiplyScalar(scale);
}

// Put these near your other physics constants:
// Increased from 18.0 to 36.0 for much more responsive air control in Ring Mode (DAR)
const KpPitch = 36.0, KdPitch = 4.0;
const KpYaw   = 36.0, KdYaw   = 4.0;
const KpRoll  = 12.0, KdRoll  = 3.0;

function integrate(dt) {
  // Skip physics when menu is open OR when Ring Mode is paused
  if (chromeShown || (RingMode.getRingModeActive() && RingMode.getRingModePaused())) {
    return;
  }

  // --- 1. Get smoothed joystick position from Input module ---
  const joyVec = Input.getJoyVec();
  const jx = joyVec.x / Input.getJoyBaseR();
  const jy = -joyVec.y / Input.getJoyBaseR(); // up is positive
  let mag = Math.hypot(jx, jy);

  let eff = 0;
  let ux = 0, uy = 0;

  if (mag > Input.STICK_DEADZONE) {
    const m2 = (mag - Input.STICK_DEADZONE) / (1 - Input.STICK_DEADZONE);
    const shaped = Math.pow(Math.max(0, m2), inputPow || 1.0); // 0..1
    eff = shaped;

    ux = -jx / (mag || 1); // right = +ux
    uy = jy  / (mag || 1); // up = +uy
  }

  // === RING MODE: Calculate movement forces (normal rotation physics will run below) ===
  if (RingMode.getRingModeActive() && !RingMode.getRingModePaused() && RingMode.getRingModeLives() > 0) {
    RingMode.updateRingModePhysics(dt, {
      boostActive: Input.getRingModeBoostActive()
    }, Car.car.quaternion);
  }

  // --- 2. Front-face arrow (same behavior as before, just using ux,uy,eff) ---
  if (Car.faceArrow && Car.faceTip) {
    const show = showArrow && eff > 0.02;
    Car.faceArrow.visible = show;
    Car.faceTip.visible   = show;

    if (show) {
      const lenMax = Math.min(Car.BOX.hx, Car.BOX.hy) * 0.95;
      const len    = Math.max(10, lenMax * eff * (arrowScale || 1));
      const zFace  = Car.BOX.hz + 0.6;

      const x2 = ux * len;
      const y2 = -uy * len;

      const pos = Car.faceArrow.geometry.attributes.position.array;
      pos[0] = 0;  pos[1] = 0;  pos[2] = zFace;
      pos[3] = x2; pos[4] = y2; pos[5] = zFace;
      Car.faceArrow.geometry.attributes.position.needsUpdate = true;

      const col = (Math.abs(x2) > Math.abs(y2))
        ? (x2 >= 0 ? CONST.COL_LEFT : CONST.COL_RIGHT)
        : (uy >= 0 ? CONST.COL_DOWN : CONST.COL_UP);
      Car.faceArrow.material.color.setHex(col);
      Car.faceTip.material.color.setHex(col);

      Car.faceTip.position.set(x2, y2, zFace);
      const ang = Math.atan2(x2, -y2) + Math.PI;
      Car.faceTip.rotation.set(0, 0, ang);
      const s = 0.95 * (arrowScale || 1);
      Car.faceTip.scale.set(s, s, 1);
    }
  }

  // --- 2b. Tornado circle visualizer (shows DAR cone path) ---
  if (Car.tornadoCircle) {
    // Circle only shows for Air Roll Left/Right (not Free), when DAR is active
    const isDAR = (Input.getAirRoll() === -1 || Input.getAirRoll() === 1);
    const shouldShowCircle = showCircle && isDAR && Input.getDarOn() && eff > 0.02;
    Car.tornadoCircle.visible = shouldShowCircle;

    if (shouldShowCircle) {
      const zFace = Car.BOX.hz + 0.6;

      // Calculate circle radius based on stick input
      const baseRadius = Math.min(Car.BOX.hx, Car.BOX.hy) * 0.95;
      const arrowLength = baseRadius * eff * (arrowScale || 1);

      // Circle scale controlled by circleScale slider
      const circleRadius = arrowLength * (circleScale || 0.3);

      // The circle should be offset perpendicular to the arrow direction
      // Air Roll Left (Input.getAirRoll() = -1): offset +90 degrees (counter-clockwise)
      // Air Roll Right (Input.getAirRoll() = +1): offset -90 degrees (clockwise)
      const arrowAngle = Math.atan2(ux, uy); // angle of the arrow in XY plane
      const perpAngle = arrowAngle + (Input.getAirRoll() * Math.PI / 2); // offset 90 degrees based on roll direction

      // Position circle center perpendicular to arrow, distance = circle radius
      const centerX = Math.sin(perpAngle) * circleRadius;
      const centerY = -Math.cos(perpAngle) * circleRadius;

      Car.tornadoCircle.scale.set(circleRadius, circleRadius, 1);
      Car.tornadoCircle.position.set(centerX, centerY, zFace);

      // Update circle color based on stick direction (same as arrow)
      const col = (Math.abs(ux) > Math.abs(uy))
        ? (ux >= 0 ? CONST.COL_LEFT : CONST.COL_RIGHT)
        : (uy >= 0 ? CONST.COL_DOWN : CONST.COL_UP);
      Car.tornadoCircle.material.color.setHex(col);

      // Apply tilt rotation toward the car
      // Calculate modifier strength: 0 at stable points (every 45Â°), 1.0 at unstable points (between 45Â° marks)
      // Stable points: 0Â°, 45Â°, 90Â°, 135Â°, 180Â°, 225Â°, 270Â°, 315Â°
      // Using sin(4x) to create 8 peaks per rotation (frequency = 4)
      const arrowAngleDeg = (arrowAngle * 180 / Math.PI + 360) % 360;
      const modifierStrength = Math.abs(Math.sin(4 * arrowAngle)); // 0 at stable, 1 at unstable

      // Apply base tilt + modifier
      const totalTilt = circleTiltAngle + (circleTiltModifier * modifierStrength);
      const tiltRad = (totalTilt * Math.PI) / 180;

      // Reset rotation first
      Car.tornadoCircle.rotation.set(0, 0, 0);

      // Rotate around the axis perpendicular to the arrow (makes circle tilt toward car)
      // Negative tiltRad to tilt toward car instead of away
      Car.tornadoCircle.rotateOnAxis(
        new THREE.Vector3(-Math.cos(perpAngle), -Math.sin(perpAngle), 0).normalize(),
        -tiltRad
      );
    }
  }

  // --- 3. Slider conversions (deg/sÂ² â†’ rad/sÂ²) ---
  let maxAccelPitchRad = (maxAccelPitch * Math.PI) / 180;
  let maxAccelYawRad   = (maxAccelYaw   * Math.PI) / 180;
  let maxAccelRollRad  = (maxAccelRoll  * Math.PI) / 180;

  // --- 3.5. DAR acceleration multipliers (from RL measurements) ---
  if (Input.getDarOn()) {
    maxAccelPitchRad *= 0.997;  // DAR: 714â†’712 deg/sÂ²
    maxAccelYawRad *= 1.00;      // DAR: 521â†’522 deg/sÂ² (no change)
    maxAccelRollRad *= 0.98;     // DAR: 2153â†’2110 deg/sÂ²
  }

  // --- 4. Desired angular velocities (rate control) ---
  let maxPitchSpeed = wMaxPitch;  // rad/s, slider already in "Ï‰"
  let maxYawSpeed   = wMaxYaw;    // rad/s
  let targetRollSpeed = 0;        // rad/s

  // Check if using Air Roll (Free) mode
  const isAirRollFree = (Input.getAirRoll() === 2);

  // DAR tornado spin (measured from Rocket League)
  if (Input.getDarOn() && !isAirRollFree) {
    // RL tornado spin: 0.74 seconds per rotation
    const RL_TORNADO_PERIOD = 0.74;  // seconds
    targetRollSpeed = Input.getAirRoll() * (2 * Math.PI) / RL_TORNADO_PERIOD;  // Input.getAirRoll() = Â±1 for Left/Right
  }

  // stick â†’ desired spin rates
  let wx_des, wy_des, wz_des;

  if (isAirRollFree) {
    // Air Roll (Free): horizontal stick controls roll, vertical controls pitch
    wx_des = maxPitchSpeed * eff * uy; // pitch (up/down)
    wy_des = 0;                         // no yaw
    wz_des = wMaxRoll * eff * (-ux);   // roll (left stick = roll left, right stick = roll right)
  } else {
    // Normal or Air Roll Left/Right: standard controls
    wx_des = maxPitchSpeed * eff * uy; // pitch
    wy_des = maxYawSpeed   * eff * ux; // yaw
    wz_des = targetRollSpeed;          // roll from DAR
  }

  // --- 5. PD control â†’ angular acceleration per axis ---
  const ax_des = KpPitch * (wx_des - w.x) - KdPitch * w.x;
  const ay_des = KpYaw   * (wy_des - w.y) - KdYaw   * w.y;
  const az_des = KpRoll  * (wz_des - w.z) - KdRoll  * w.z;

  const ax = THREE.MathUtils.clamp(ax_des, -maxAccelPitchRad, maxAccelPitchRad);
  const ay = THREE.MathUtils.clamp(ay_des, -maxAccelYawRad,   maxAccelYawRad);
  const az = THREE.MathUtils.clamp(az_des, -maxAccelRollRad,  maxAccelRollRad);

  // --- 6. Integrate angular velocity ---
  w.x += ax * dt;
  w.y += ay * dt;
  w.z += az * dt;

  // --- 7. Damping + release brake ---
  // CRITICAL: Damping only applies when inputs are released!
  const noStick = eff < 0.08;
  if (noStick) {
    const baseDamp = Input.getDarOn() ? dampDAR : damp;
    const dampEff = (baseDamp || 0) + ((!Input.getDarOn()) ? (brakeOnRelease || 0) : 0);
    const scale = Math.exp(-dampEff * dt);
    w.multiplyScalar(scale);
  }

  // --- 8. Per-axis caps + global cap ---
  if (Math.abs(w.x) > wMaxPitch) w.x = Math.sign(w.x) * wMaxPitch;
  if (Math.abs(w.y) > wMaxYaw)   w.y = Math.sign(w.y) * wMaxYaw;

  const wMag = w.length();
  if (wMag > wMax) {
    w.multiplyScalar(wMax / wMag);
  }

  // --- 9. Quaternion integration (unchanged) ---
  const wx = w.x, wy = w.y, wz = w.z, halfdt = 0.5 * dt;
  const q = Car.car.quaternion;
  const rw = -q.x * wx - q.y * wy - q.z * wz;
  const rx =  q.w * wx + q.y * wz - q.z * wy;
  const ry =  q.w * wy + q.z * wx - q.x * wz;
  const rz =  q.w * wz + q.x * wy - q.y * wx;
  q.w += rw * halfdt;
  q.x += rx * halfdt;
  q.y += ry * halfdt;
  q.z += rz * halfdt;
  q.normalize();

  // === RING MODE: Override car position and update rings ===
  RingMode.updateRingModeRendering(dt);
}
/* Camera zoom/orbit *//* Camera zoom/orbit */
let orbitPhase=0;

function applyZoom(){
  const f = Math.max(0.7, Math.min(1.6, zoom||1));
  const dist = CONST.CAM_BASE.z / f;
  const h = CONST.CAM_BASE.y / f;
  if(!orbitOn){
    camera.position.set(0, h, dist);
    camera.lookAt(0, Car.car ? Car.car.position.y : 0, 0);
  }
}

function orbitStep(t){
  const f = Math.max(0.7, Math.min(1.6, zoom||1));
  const R = (CONST.CAM_BASE.z / f);
  const h = (CONST.CAM_BASE.y / f);
  const sp = 0.35 * orbitDir;
  const x = Math.sin(t*sp)*R;
  const z = Math.cos(t*sp)*R;
  camera.position.set(x, h, z);
  camera.lookAt(0, Car.car ? Car.car.position.y : 0, 0);
}

/* XYZ Gizmo */
/* XYZ Gizmo */
const gizmoRect = document.getElementById('gizmoFrame').getBoundingClientRect();
const gizmoScene = new THREE.Scene();
const gizmoCam = new THREE.PerspectiveCamera(40, gizmoRect.width/gizmoRect.height, 0.1, 100);
gizmoCam.position.set(0,0,6);
const gizmoAxes = new THREE.AxesHelper(3.2);
gizmoScene.add(gizmoAxes);
const gizmoTarget = new THREE.Object3D();
gizmoScene.add(gizmoTarget);
gizmoAxes.position.copy(gizmoTarget.position);

/* Render HUD & loop */
function renderHUD(){
  Rendering.renderHUD({
    // Joystick state
    JOY_CENTER: Input.getJoyCenter(),
    JOY_BASE_R: Input.getJoyBaseR(),
    JOY_KNOB_R: Input.getJoyKnobR(),
    joyVec: Input.getJoyVec(),
    COLS,
    // DAR button state
    DAR_CENTER: Input.getDarCenter(),
    DAR_R: Input.getDarR(),
    darOn: Input.getDarOn(),
    airRoll: Input.getAirRoll(),
    // Boost button state
    BOOST_CENTER: Input.getBoostCenter(),
    BOOST_R: Input.getBoostR(),
    ringModeBoostActive: Input.getRingModeBoostActive(),
    showBoostButton: Input.getShowBoostButton(),
    // Ring Mode state
    ringModeActive: RingMode.getRingModeActive(),
    ringModeStarted: RingMode.getRingModeStarted(),
    ringModePaused: RingMode.getRingModePaused(),
    ringModeLives: RingMode.getRingModeLives(),
    ringModeScore: RingMode.getRingModeScore(),
    ringModeHighScore: RingMode.getRingModeHighScore(),
    ringModeRingCount: RingMode.getRingModeRingCount(),
    ringModePosition: RingMode.getRingModePosition(),
    rings: RingMode.getRings(),
    isMobile: Input.getIsMobile(),
    currentDifficulty: RingMode.getCurrentDifficulty()
  });
}


let lastT = performance.now()/1000;
function tick(){
  const t = performance.now()/1000;
  const dt = Math.min(0.033, Math.max(0.001, t - lastT));
  lastT = t;

  if(orbitOn){ orbitPhase += dt; orbitStep(orbitPhase); }

  // Update input state from Input module
  Input.updateInput(dt);

  integrate(dt);

  renderer.setScissorTest(false);
  renderer.setViewport(0,0,innerWidth,innerHeight);
  renderer.render(scene, camera);

  if(Car.car){
    gizmoTarget.quaternion.copy(Car.car.quaternion);
    gizmoAxes.quaternion.copy(gizmoTarget.quaternion);
  }
  const gf = document.getElementById('gizmoFrame').getBoundingClientRect();
  const sx = Math.floor(gf.left), sy = Math.floor(innerHeight - gf.bottom);
  const sw = Math.floor(gf.width), sh = Math.floor(gf.height);
  renderer.setScissorTest(true);
  renderer.setScissor(sx,sy,sw,sh);
  renderer.setViewport(sx,sy,sw,sh);
  renderer.render(gizmoScene, gizmoCam);
  renderer.setScissorTest(false);

  renderHUD();
  requestAnimationFrame(tick);
}

/* Resize & boot */
function resize(){
  renderer.setSize(innerWidth, innerHeight);
  camera.aspect = innerWidth/innerHeight;
  camera.updateProjectionMatrix();
  Rendering.sizeHud();
  Input.handleResize();
  applyZoom();
}
addEventListener('resize', resize);

// Initialize Input module with callbacks
Input.initInput(hud, {
  execBinding: (action) => {
    // Handle gamepad button actions
    switch(action) {
      case 'toggleDAR':
        // Toggle DAR with last active air roll
        const currentAirRoll = Input.getAirRoll();
        const lastActive = Input.getLastActiveAirRoll();
        if (currentAirRoll === 0) {
          // Turn on DAR with last active direction
          Input.selectAirRoll(lastActive);
        } else {
          // Turn off DAR
          Input.selectAirRoll(0);
        }
        break;
      case 'rollLeft':
      case 'rollRight':
      case 'rollFree':
        // These are handled internally by Input module
        break;
      case 'boost':
        // Boost handled internally by Input module
        break;
      case 'pause':
        if (RingMode.getRingModeActive()) {
          const paused = RingMode.toggleRingModePaused();
          Input.setRingModePaused(paused);
          // Stop boost sound when pausing
          if (paused) {
            Audio.stopBoostRumble();
          }
        }
        break;
      case 'restart':
        if (RingMode.getRingModeActive()) {
          // In Ring Mode: Quick respawn (costs a life, respawns at next ring)
          const lives = RingMode.getRingModeLives();
          if (lives > 0) {
            // Lose a life
            RingMode.setRingModeLives(lives - 1);

            // Reset velocity and position to next ring
            const rings = RingMode.getRings();
            const nextRing = rings.find(r => !r.passed && !r.missed);
            if (nextRing) {
              RingMode.setRingModePosition(nextRing.mesh.position.x, nextRing.mesh.position.y);
            } else {
              RingMode.setRingModePosition(0, 0);
            }
            RingMode.setRingModeVelocity(0, 0);

            // Reset car rotation
            if (Car.car) {
              Car.car.quaternion.identity();
              Car.car.rotation.set(Math.PI * 1.5, 0, Math.PI);
            }
            w.set(0, 0, 0);

            console.log('Quick respawn! Lives remaining:', lives - 1);
          }
        } else {
          // Normal mode: Full restart (reset car orientation, camera, orbit)
          if (Car.car) {
            Car.car.quaternion.identity();
            Car.car.rotation.set(Math.PI * 1.5, 0, Math.PI);
          }
          w.set(0,0,0);
          orbitOn = false;
          orbitDir = 1;
          document.getElementById('orbitCW').classList.remove('active');
          document.getElementById('orbitCCW').classList.remove('active');
          orbitPhase = 0;
          camera.position.set(0, 220, 650);
          camera.lookAt(0,0,0);
          if (Car.faceArrow) Car.faceArrow.visible = false;
          if (Car.faceTip) Car.faceTip.visible = false;
        }
        break;
      case 'orbitCW':
        if (orbitOn && orbitDir === 1) {
          // Turn off if already orbiting CW
          orbitOn = false;
        } else {
          // If switching from CCW to CW, maintain camera position
          if (orbitOn && orbitDir === -1) {
            orbitPhase = -orbitPhase;
          }
          // Turn on CW orbit
          orbitOn = true;
          orbitDir = 1;
        }
        break;
      case 'orbitCCW':
        if (orbitOn && orbitDir === -1) {
          // Turn off if already orbiting CCW
          orbitOn = false;
        } else {
          // If switching from CW to CCW, maintain camera position
          if (orbitOn && orbitDir === 1) {
            orbitPhase = -orbitPhase;
          }
          // Turn on CCW orbit
          orbitOn = true;
          orbitDir = -1;
        }
        break;
      case 'toggleTheme':
        isDarkMode = !isDarkMode;
        applyTheme(isDarkMode);
        saveSettings();
        break;
      case 'openMenu':
        if (!chromeShown) {
          openMenu();
        } else {
          closeMenu();
        }
        break;
    }
  },
  openMenu: openMenu,
  closeMenu: closeMenu,
  retry: () => RingMode.resetRingMode(),
  getRingModeLives: () => RingMode.getRingModeLives()
});

// Restore saved car body or default to octane
const savedCarBody = savedSettings.selectedCarBody || 'octane';
if (CONST.CAR_PRESETS[savedCarBody]) {
  Car.buildCar(CONST.CAR_PRESETS[savedCarBody], savedCarBody, scene);
  presetSel.value = savedCarBody;
} else {
  Car.buildCar(CONST.CAR_PRESETS.octane, "octane", scene);
}

// Set initial menu button styling based on saved selection
updateMenuButtonStyling();

// Set initial rotation: roof facing camera, nose pointing up
// X: +270Â°, Y: 0Â°, Z: +180Â°
if (Car.car) {
  Car.car.rotation.set(Math.PI * 1.5, 0, Math.PI); // X: +270Â°, Y: 0Â°, Z: +180Â°
}

// Initialize Ring Mode module with scene references
const orbitOnRef = { get value() { return orbitOn; }, set value(v) { orbitOn = v; } };
RingMode.initRingMode(scene, camera, renderer, w, orbitOnRef);

// Air roll state and hint positioning managed by Input module
applyZoom();
applyTheme(isDarkMode); // Initialize theme

// Restore theme button state (main screen)
const themeBtn = document.getElementById('themeBtn');
themeBtn.textContent = isDarkMode ? 'ðŸŒ™' : 'â˜€ï¸';

// Restore arrow and circle toggle button states
const arrowToggleBtn = document.getElementById('arrowToggle');
arrowToggleBtn.classList.toggle('active', showArrow);
arrowToggleBtn.textContent = showArrow ? 'Show Arrow' : 'Hide Arrow';

const circleToggleBtn = document.getElementById('circleToggle');
circleToggleBtn.classList.toggle('active', showCircle);
circleToggleBtn.textContent = showCircle ? 'Show Circle' : 'Hide Circle';

// Restore toggle/hold mode button state
const toggleModeBtn = document.getElementById('toggleMode');
toggleModeBtn.classList.toggle('active', Input.getAirRollIsToggle());
toggleModeBtn.textContent = Input.getAirRollIsToggle() ? 'Toggle' : 'Hold';

// Gamepad state managed by Input module

// Restore Ring Mode difficulty selector
if (ringDifficultySelector) {
  ringDifficultySelector.value = RingMode.getCurrentDifficulty();
}

requestAnimationFrame(tick);
</script>
</body>
</html>
